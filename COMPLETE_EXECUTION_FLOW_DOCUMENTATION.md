# Kimi CLI å®Œæ•´æ‰§è¡Œæµç¨‹è¯¦è§£

## æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†æè¿°äº† Kimi CLI ä»ç”¨æˆ·è¾“å…¥åˆ°å®Œæ•´æ‰§è¡Œçš„æ•´ä¸ªæµç¨‹ï¼Œæ¶µç›–æ‰€æœ‰ä¸»è¦è·¯å¾„å’Œå…³é”®å†³ç­–ç‚¹ã€‚æ‰§è¡Œæµç¨‹æ˜¯ä¸€ä¸ªé«˜åº¦åè°ƒçš„ç³»ç»Ÿï¼Œæ¶‰åŠå¤šä¸ªç»„ä»¶çš„ç²¾å¯†åä½œã€‚

## æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ç”¨æˆ·è¾“å…¥å…¥å£                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  CLI å‚æ•°è§£æ â†’ æ¨¡å¼é€‰æ‹© â†’ å®ä¾‹åˆ›å»º â†’ é…ç½®åŠ è½½          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                      â†“                                        â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                               â”‚
â”‚              â”‚  ä¼šè¯ç®¡ç†   â”‚                               â”‚
â”‚              â”‚   Session   â”‚                               â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                               â”‚
â”‚                      â†“                                        â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                               â”‚
â”‚              â”‚ KimiCLIå®ä¾‹ â”‚                               â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                               â”‚
â”‚                      â†“                                        â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                               â”‚
â”‚              â”‚  UIå±‚é€‚é…   â”‚                               â”‚
â”‚              â”‚ (Shell/Print)â”‚                               â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                               â”‚
â”‚                      â†“                                        â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                               â”‚
â”‚              â”‚ KimiSoulå¼•æ“ â”‚                               â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                               â”‚
â”‚                      â†“                                        â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                               â”‚
â”‚              â”‚  Wireé€šä¿¡å±‚  â”‚                               â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                               â”‚
â”‚                      â†“                                        â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                               â”‚
â”‚              â”‚  å·¥å…·æ‰§è¡Œå±‚  â”‚                               â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                               â”‚
â”‚                      â†“                                        â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                               â”‚
â”‚              â”‚  LLMè°ƒç”¨å±‚  â”‚                               â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ç¬¬ä¸€é˜¶æ®µï¼šç”¨æˆ·è¾“å…¥å¤„ç†å’Œåˆå§‹åŒ–

### 1. CLI å…¥å£ç‚¹ (`cli.py`)

```python
@cli.callback(invoke_without_command=True)
def kimi(
    # ... å‚æ•°è§£æ
    local_work_dir: Path | None = None,
    continue_: bool = False,
    session_id: str | None = None,
    command: str | None = None,
    print_mode: bool = False,
    acp_mode: bool = False,
    wire_mode: bool = False,
    # ... æ›´å¤šå‚æ•°
) -> None:
```

**æµç¨‹æ­¥éª¤**ï¼š

1. **å‚æ•°éªŒè¯å’Œå†²çªæ£€æµ‹**
```python
# å†²çªé€‰é¡¹æ£€æµ‹
conflict_option_sets = [
    {"--print": print_mode, "--acp": acp_mode, "--wire": wire_mode},
    {"--agent": agent is not None, "--agent-file": agent_file is not None},
    {"--continue": continue_, "--session": session_id is not None},
]
```

2. **UI æ¨¡å¼é€‰æ‹©**
```python
ui: UIMode = "shell"  # é»˜è®¤
if print_mode: ui = "print"
elif acp_mode: ui = "acp"
elif wire_mode: ui = "wire"
```

3. **MCP é…ç½®åŠ è½½**
```python
file_configs = list(mcp_config_file or [])
raw_mcp_config = list(mcp_config or [])

# ä½¿ç”¨é»˜è®¤ MCP é…ç½®æ–‡ä»¶
if not file_configs:
    default_mcp_file = get_global_mcp_config_file()
    if default_mcp_file.exists():
        file_configs.append(default_mcp_file)
```

### 2. KimiCLI å®ä¾‹åˆ›å»º (`app.py`)

```python
async def _run(session_id: str | None) -> bool:
    # ä¼šè¯åˆ›å»ºæˆ–æ¢å¤
    if session_id is not None:
        session = await Session.find(work_dir, session_id)
        if session is None:
            session = await Session.create(work_dir, session_id)
    elif continue_:
        session = await Session.continue_(work_dir)
    else:
        session = await Session.create(work_dir)

    # KimiCLI å®ä¾‹åˆ›å»º
    instance = await KimiCLI.create(
        session,
        yolo=yolo or (ui == "print"),
        mcp_configs=mcp_configs,
        model_name=model_name,
        thinking=thinking_mode,
        agent_file=agent_file,
    )
```

**KimiCLI åˆ›å»ºè¿‡ç¨‹**ï¼š

```python
@staticmethod
async def create(
    session: Session,
    *,
    yolo: bool = False,
    mcp_configs: list[MCPConfig | dict[str, Any]] | None = None,
    config_file: Path | None = None,
    model_name: str | None = None,
    thinking: bool = False,
    agent_file: Path | None = None,
) -> KimiCLI:
    # 1. é…ç½®åŠ è½½
    config = load_config(config_file)
    
    # 2. LLM é…ç½®
    model: LLMModel | None = None
    provider: LLMProvider | None = None
    
    # å°è¯•ä½¿ç”¨é…ç½®æ–‡ä»¶
    if not model_name and config.default_model:
        model = config.models[config.default_model]
        provider = config.providers[model.provider]
    
    # ç¯å¢ƒå˜é‡è¦†ç›–
    if model_name and model_name in config.models:
        model = config.models[model_name]
        provider = config.providers[model.provider]
    
    # 3. LLM å®ä¾‹åˆ›å»º
    if not model:
        model = LLMModel(provider="", model="", max_context_size=100_000)
        provider = LLMProvider(type="kimi", base_url="", api_key=SecretStr(""))
    
    # 4. è¿è¡Œæ—¶åˆ›å»º
    runtime = await Runtime.create(config, llm, session, yolo)
    
    # 5. ä»£ç†åŠ è½½
    agent_file = agent_file or DEFAULT_AGENT_FILE
    agent = await load_agent(agent_file, runtime, mcp_configs=mcp_configs or [])
    
    # 6. ä¸Šä¸‹æ–‡æ¢å¤
    context = Context(session.context_file)
    await context.restore()
    
    # 7. KimiSoul åˆ›å»º
    soul = KimiSoul(agent, context=context)
    soul.set_thinking(thinking)
    
    return KimiCLI(soul, runtime, env_overrides)
```

## ç¬¬äºŒé˜¶æ®µï¼šUI æ¨¡å¼åˆ†å‘

### 1. Shell æ¨¡å¼æ‰§è¡Œ (`ui/shell/__init__.py`)

```python
async def run_shell(self, command: str | None = None) -> bool:
    # æ¬¢è¿ä¿¡æ¯å‡†å¤‡
    welcome_info = [
        WelcomeInfoItem(name="Directory", value=str(shorten_home(work_dir))),
        WelcomeInfoItem(name="Session", value=session.id),
        # API é…ç½®çŠ¶æ€æ˜¾ç¤º
        # æ¨¡å‹ä¿¡æ¯æ˜¾ç¤º
    ]
    
    # Shell å®ä¾‹åˆ›å»ºå’Œè¿è¡Œ
    async with self._env():
        shell = Shell(self._soul, welcome_info=welcome_info)
        return await shell.run(command)
```

### 2. Print æ¨¡å¼æ‰§è¡Œ

```python
async def run_print(
    self,
    input_format: InputFormat,
    output_format: OutputFormat,
    command: str | None = None,
) -> bool:
    async with self._env():
        print_ = Print(
            self._soul,
            input_format,
            output_format,
            self._runtime.session.context_file,
        )
        return await print_.run(command)
```

### 3. ACP æ¨¡å¼æ‰§è¡Œ

```python
async def run_acp(self) -> None:
    async with self._env():
        acp = ACP(self._soul)
        await acp.run()
```

## ç¬¬ä¸‰é˜¶æ®µï¼šShell æ¨¡å¼è¯¦ç»†æµç¨‹

### 1. Shell åˆå§‹åŒ–å’Œæ¬¢è¿

```python
class Shell:
    async def run(self, command: str | None = None) -> bool:
        if command is not None:
            # å•å‘½ä»¤æ¨¡å¼
            return await self._run_soul_command(command)
        
        # æ˜¾ç¤ºæ¬¢è¿ä¿¡æ¯
        _print_welcome_info(self.soul.name or "Kimi CLI", self._welcome_info)
        
        # å†å²è®°å½•é‡æ”¾
        if isinstance(self.soul, KimiSoul):
            await replay_recent_history(
                self.soul.context.history,
                wire_file=self.soul.wire_file,
            )
```

### 2. äº¤äº’å¼ä¸»å¾ªç¯

```python
with CustomPromptSession(
    status_provider=lambda: self.soul.status,
    model_capabilities=self.soul.model_capabilities or set(),
    initial_thinking=isinstance(self.soul, KimiSoul) and self.soul.thinking,
    available_slash_commands=list(self._available_slash_commands.values()),
) as prompt_session:
    while True:
        try:
            # 1. è·å–ç”¨æˆ·è¾“å…¥
            ensure_new_line()
            user_input = await prompt_session.prompt()
            
        except KeyboardInterrupt:
            # Ctrl-C å¤„ç†
            console.print("Tip: press Ctrl-D or send 'exit' to quit")
            continue
            
        except EOFError:
            # Ctrl-D å¤„ç†
            console.print("Bye!")
            break
        
        # 2. ç©ºè¾“å…¥è·³è¿‡
        if not user_input:
            continue
            
        # 3. é€€å‡ºå‘½ä»¤å¤„ç†
        if user_input.command in ["exit", "quit", "/exit", "/quit"]:
            console.print("Bye!")
            break
        
        # 4. Shell æ¨¡å¼å‘½ä»¤
        if user_input.mode == PromptMode.SHELL:
            await self._run_shell_command(user_input.command)
            continue
        
        # 5. æ–œæ å‘½ä»¤å¤„ç†
        if slash_cmd_call := parse_slash_command_call(user_input.command):
            await self._run_slash_command(slash_cmd_call)
            continue
        
        # 6. Soul å‘½ä»¤æ‰§è¡Œ
        await self._run_soul_command(user_input.content, user_input.thinking)
```

## ç¬¬å››é˜¶æ®µï¼šSoul å¼•æ“æ‰§è¡Œæµç¨‹

### 1. Soul è¿è¡Œå…¥å£ (`kimisoul.py`)

```python
async def run(self, user_input: str | list[ContentPart]):
    # 1. å‘é€è½®æ¬¡å¼€å§‹äº‹ä»¶
    wire_send(TurnBegin(user_input=user_input))
    user_message = Message(role="user", content=user_input)
    
    # 2. æ–œæ å‘½ä»¤è§£æå’Œæ‰§è¡Œ
    if command_call := parse_slash_command_call(user_message.extract_text(" ").strip()):
        command = soul_slash_registry.find_command(command_call.name)
        if command is None:
            wire_send(TextPart(text=f'Unknown slash command "/{command_call.name}".'))
            return
        
        ret = command.func(self, command_call.args)
        if isinstance(ret, Awaitable):
            await ret
        return
    
    # 3. LLM æ£€æŸ¥
    if self._runtime.llm is None:
        raise LLMNotSet()
    
    # 4. æ¶ˆæ¯èƒ½åŠ›éªŒè¯
    if missing_caps := check_message(user_message, self._runtime.llm.capabilities):
        raise LLMNotSupported(self._runtime.llm, list(missing_caps))
    
    # 5. ä¸Šä¸‹æ–‡æ£€æŸ¥ç‚¹åˆ›å»º
    await self._checkpoint()
    await self._context.append_message(user_message)
    
    # 6. å¯åŠ¨ä»£ç†å¾ªç¯
    await self._agent_loop()
```

### 2. ä»£ç†ä¸»å¾ªç¯ (`_agent_loop`)

```python
async def _agent_loop(self):
    step_no = 0
    while True:
        step_no += 1
        
        # 1. æ­¥æ•°é™åˆ¶æ£€æŸ¥
        if step_no > self._loop_control.max_steps_per_run:
            raise MaxStepsReached(self._loop_control.max_steps_per_run)
        
        # 2. å‘é€æ­¥éª¤å¼€å§‹äº‹ä»¶
        wire_send(StepBegin(n=step_no))
        
        # 3. å¯åŠ¨æƒé™ç®¡é“ä»»åŠ¡
        approval_task = asyncio.create_task(_pipe_approval_to_wire())
        
        try:
            # 4. ä¸Šä¸‹æ–‡å‹ç¼©æ£€æŸ¥
            if (self._context.token_count + self._reserved_tokens >= 
                self._runtime.llm.max_context_size):
                logger.info("Context too long, compacting...")
                await self.compact_context()
            
            # 5. æ‰§è¡Œå•æ­¥
            await self._checkpoint()
            self._denwa_renji.set_n_checkpoints(self._context.n_checkpoints)
            finished = await self._step()
            
        except BackToTheFuture as e:
            # 6. D-Mail æ—¶é—´æ—…è¡Œå¤„ç†
            await self._context.revert_to(e.checkpoint_id)
            await self._checkpoint()
            await self._context.append_message(e.messages)
            finished = False
            
        except Exception:
            # 7. å¼‚å¸¸å¤„ç†
            wire_send(StepInterrupted())
            raise
            
        finally:
            # 8. æ¸…ç†æƒé™ä»»åŠ¡
            approval_task.cancel()
            with suppress(asyncio.CancelledError):
                try:
                    await approval_task
                except Exception:
                    logger.exception("Approval piping task failed")
        
        # 9. æ£€æŸ¥æ˜¯å¦å®Œæˆ
        if finished:
            return
```

### 3. å•æ­¥æ‰§è¡Œ (`_step`)

```python
async def _step(self) -> bool:
    chat_provider = self._runtime.llm.chat_provider
    
    # 1. å¸¦é‡è¯•çš„ LLM è°ƒç”¨
    @tenacity.retry(
        retry=retry_if_exception(self._is_retryable_error),
        wait=wait_exponential_jitter(initial=0.3, max=5, jitter=0.5),
        stop=stop_after_attempt(self._loop_control.max_retries_per_step),
    )
    async def _kosong_step_with_retry() -> StepResult:
        return await kosong.step(
            chat_provider.with_thinking(self._thinking_effort),
            self._agent.system_prompt,
            self._agent.toolset,
            self._context.history,
            on_message_part=wire_send,
            on_tool_result=wire_send,
        )
    
    result = await _kosong_step_with_retry()
    
    # 2. çŠ¶æ€æ›´æ–°
    status_update = StatusUpdate(token_usage=result.usage, message_id=result.id)
    if result.usage is not None:
        await self._context.update_token_count(result.usage.input)
        status_update.context_usage = self.status.context_usage
    wire_send(status_update)
    
    # 3. ç­‰å¾…å·¥å…·ç»“æœ
    results = await result.tool_results()
    
    # 4. ä¸Šä¸‹æ–‡å¢é•¿ï¼ˆå±è”½ä¸­æ–­ï¼‰
    await asyncio.shield(self._grow_context(result, results))
    
    # 5. å·¥å…·æ‹’ç»æ£€æŸ¥
    rejected = any(isinstance(result.return_value, ToolRejectedError) for result in results)
    if rejected:
        _ = self._denwa_renji.fetch_pending_dmail()
        return True
    
    # 6. D-Mail å¤„ç†
    if dmail := self._denwa_renji.fetch_pending_dmail():
        raise BackToTheFuture(
            dmail.checkpoint_id,
            [Message(role="user", content=[system(f"D-Mail content:\n\n{dmail.message.strip()}")])],
        )
    
    # 7. è¿”å›æ˜¯å¦ç»§ç»­
    return not result.tool_calls
```

## ç¬¬äº”é˜¶æ®µï¼šWire é€šä¿¡å’Œå¯è§†åŒ–

### 1. Wire æ¶ˆæ¯æµ (`wire/__init__.py`)

```python
class Wire:
    """A spmc channel for communication between soul and UI during a soul run."""
    
    def __init__(self, *, file_backend: Path | None = None):
        self._raw_queue = WireMessageQueue()      # åŸå§‹æ¶ˆæ¯é˜Ÿåˆ—
        self._merged_queue = WireMessageQueue()    # åˆå¹¶æ¶ˆæ¯é˜Ÿåˆ—
        
        # Soul ä¾§é€šä¿¡
        self._soul_side = WireSoulSide(self._raw_queue, self._merged_queue)
        
        # å¯é€‰çš„æ–‡ä»¶è®°å½•å™¨
        if file_backend is not None:
            self._recorder = _WireRecorder(file_backend, self._merged_queue.subscribe())
        else:
            self._recorder = None
```

### 2. æ¶ˆæ¯å‘é€æœºåˆ¶

```python
def wire_send(msg: WireMessage) -> None:
    """Send a wire message to current wire."""
    wire = get_wire_or_none()
    assert wire is not None, "Wire is expected to be set when soul is running"
    wire.soul_side.send(msg)
```

### 3. å¯è§†åŒ–å¾ªç¯ (`ui/shell/visualize.py`)

```python
async def visualize(
    wire: WireUISide,
    *,
    initial_status: StatusUpdate,
    cancel_event: asyncio.Event | None = None,
):
    view = _LiveView(initial_status, cancel_event)
    await view.visualize_loop(wire)

class _LiveView:
    def __init__(self, initial_status: StatusUpdate, cancel_event):
        self.content_blocks = {
            "thinking": _ContentBlock(is_think=True),
            "assistant": _ContentBlock(is_think=False),
        }
        self.current_step: StepInfo | None = None
        self.approval_requests: dict[str, ApprovalRequestInfo] = {}
        
    async def visualize_loop(self, wire: WireUISide):
        async for msg in wire.subscribe():
            await self._handle_message(msg)
```

### 4. æ¶ˆæ¯ç±»å‹å¤„ç†

```python
async def _handle_message(self, msg: WireMessage):
    match msg:
        case TurnBegin():
            # æ–°è½®æ¬¡å¼€å§‹
            self._reset_content()
            
        case StepBegin():
            # æ­¥éª¤å¼€å§‹
            self.current_step = StepInfo(n=msg.n)
            self._show_step_start()
            
        case ThinkPart(think=think):
            # æ€è€ƒå†…å®¹
            self.content_blocks["thinking"].append(think)
            self._update_live()
            
        case TextPart(text=text):
            # åŠ©æ‰‹å›å¤
            self.content_blocks["assistant"].append(text)
            self._update_live()
            
        case ToolCall():
            # å·¥å…·è°ƒç”¨å¼€å§‹
            await self._handle_tool_call_start(msg)
            
        case ToolCallPart():
            # å·¥å…·è°ƒç”¨æµå¼æ›´æ–°
            await self._handle_tool_call_part(msg)
            
        case ToolResult():
            # å·¥å…·è°ƒç”¨ç»“æœ
            await self._handle_tool_result(msg)
            
        case ApprovalRequest():
            # æƒé™è¯·æ±‚
            self.approval_requests[msg.id] = ApprovalRequestInfo(
                request=msg,
                future=asyncio.Future(),
            )
            await self._show_approval_request(msg)
            
        case ApprovalRequestResolved():
            # æƒé™è¯·æ±‚è§£å†³
            info = self.approval_requests.pop(msg.request_id, None)
            if info:
                info.future.set_result(msg.response)
            
        case StatusUpdate():
            # çŠ¶æ€æ›´æ–°
            if msg.context_usage is not None:
                self.progress = f"{msg.context_usage:.1%}"
            self._update_live()
```

## ç¬¬å…­é˜¶æ®µï¼šå·¥å…·è°ƒç”¨å’Œæ‰§è¡Œ

### 1. å·¥å…·è°ƒç”¨å¼€å§‹å¤„ç†

```python
async def _handle_tool_call_start(self, tool_call: ToolCall):
    # æå–å…³é”®å‚æ•°ç”¨äºæ˜¾ç¤º
    subtitle = extract_key_argument(tool_call.function.arguments or "", tool_call.function.name)
    title = f"{tool_call.function.name}: {subtitle}" if subtitle else tool_call.function.name
    
    # åˆ›å»ºå·¥å…·è°ƒç”¨ä¿¡æ¯
    self.current_tool_calls[tool_call.id] = ToolCallInfo(
        tool_call=tool_call,
        title=title,
        parts=[],
        status="in_progress",
    )
    
    self._update_live()
```

### 2. å·¥å…·è°ƒç”¨æµå¼æ›´æ–°

```python
async def _handle_tool_call_part(self, part: ToolCallPart):
    if not self.current_tool_calls:
        return
        
    tool_call_id = part.tool_call_id
    if tool_call_id not in self.current_tool_calls:
        return
        
    info = self.current_tool_calls[tool_call_id]
    info.parts.append(part.arguments_part)
    
    # æ›´æ–°æ ‡é¢˜ï¼ˆå¦‚æœæœ‰æ–°çš„å…³é”®å‚æ•°ï¼‰
    lexer = streamingjson.Lexer()
    lexer.append_string(info.tool_call.function.arguments or "")
    lexer.append_string(part.arguments_part)
    
    subtitle = extract_key_argument(lexer.complete_json(), info.tool_call.function.name)
    info.title = f"{info.tool_call.function.name}: {subtitle}" if subtitle else info.tool_call.function.name
    
    self._update_live()
```

### 3. å·¥å…·ç»“æœå¤„ç†

```python
async def _handle_tool_result(self, result: ToolResult):
    tool_call_id = result.tool_call_id
    if tool_call_id not in self.current_tool_calls:
        return
        
    info = self.current_tool_calls.pop(tool_call_id)
    
    # åˆ¤æ–­æˆåŠŸæˆ–å¤±è´¥
    if isinstance(result.return_value, ToolError):
        info.status = "failed"
        info.error = result.return_value.message
    else:
        info.status = "completed"
        
    # å¤„ç†è¾“å‡ºå†…å®¹
    if result.return_value.output:
        info.output = result.return_value.output
        
    self._update_live()
    
    # å¦‚æœå·¥å…·è°ƒç”¨è¿‡å¤šï¼Œç§»é™¤æœ€æ—©çš„
    if len(self.current_tool_calls) > MAX_SUBAGENT_TOOL_CALLS_TO_SHOW:
        oldest_id = min(self.current_tool_calls.keys())
        del self.current_tool_calls[oldest_id]
```

## ç¬¬ä¸ƒé˜¶æ®µï¼šæƒé™ç®¡ç†å’Œç”¨æˆ·äº¤äº’

### 1. æƒé™è¯·æ±‚æµç¨‹ (`soul/approval.py`)

```python
class Approval:
    def __init__(self, yolo: bool = False):
        self._request_queue = asyncio.Queue[Request]()
        self._requests: dict[str, tuple[Request, asyncio.Future[bool]]] = {}
        self._yolo = yolo
        self._auto_approve_actions: set[str] = set()
    
    async def request(self, sender: str, action: str, description: str) -> bool:
        tool_call = get_current_tool_call_or_none()
        if tool_call is None:
            raise RuntimeError("Approval must be requested from a tool call.")
        
        # YOLO æ¨¡å¼ç›´æ¥æ‰¹å‡†
        if self._yolo or action in self._auto_approve_actions:
            return True
        
        # åˆ›å»ºè¯·æ±‚
        request = Request(
            id=str(uuid.uuid4()),
            tool_call_id=tool_call.id,
            sender=sender,
            action=action,
            description=description,
        )
        
        # ç­‰å¾…å“åº”
        future = asyncio.Future[bool]()
        self._requests[request.id] = (request, future)
        
        # é€šè¿‡ Wire å‘é€è¯·æ±‚
        self._request_queue.put_nowait(request)
        
        return await future
```

### 2. æƒé™ç®¡é“å¤„ç† (`kimisoul.py`)

```python
async def _pipe_approval_to_wire():
    while True:
        # ä»å·¥å…·è·å–è¯·æ±‚
        request = await self._approval.fetch_request()
        
        # è½¬æ¢ä¸º Wire æ¶ˆæ¯
        wire_request = ApprovalRequest(
            id=request.id,
            action=request.action,
            description=request.description,
            sender=request.sender,
            tool_call_id=request.tool_call_id,
        )
        wire_send(wire_request)
        
        # ç­‰å¾…ç”¨æˆ·å“åº”
        resp = await wire_request.wait()
        self._approval.resolve_request(request.id, resp)
        wire_send(ApprovalRequestResolved(request_id=request.id, response=resp))
```

### 3. æƒé™å“åº”å¤„ç† (`visualize.py`)

```python
async def _show_approval_request(self, request: ApprovalRequest):
    # åˆ›å»ºæƒé™é€‰é¡¹
    options = [
        ("1", "Approve once", "allow_once"),
        ("2", "Approve for this session", "allow_always"),
        ("3", "Reject", "reject_once"),
    ]
    
    # æ˜¾ç¤ºè¯·æ±‚è¯¦æƒ…
    console.print(Panel(
        f"[bold]{request.action}[/bold]\n{request.description}",
        title="ğŸ” Permission Required",
        border_style="yellow",
    ))
    
    # ç­‰å¾…ç”¨æˆ·é€‰æ‹©
    choice = await self._get_user_choice(options)
    
    # è§£æå“åº”
    choice_map = {"1": "approve", "2": "approve_for_session", "3": "reject"}
    response = choice_map.get(choice, "reject")
    
    # è®¾ç½® Future ç»“æœ
    info = self.approval_requests[request.id]
    info.future.set_result(response)
```

## ç¬¬å…«é˜¶æ®µï¼šä¸Šä¸‹æ–‡ç®¡ç†å’ŒæŒä¹…åŒ–

### 1. ä¸Šä¸‹æ–‡æ£€æŸ¥ç‚¹ (`soul/context.py`)

```python
async def checkpoint(self, add_user_message: bool):
    checkpoint_id = self._next_checkpoint_id
    self._next_checkpoint_id += 1
    
    # å†™å…¥æ£€æŸ¥ç‚¹æ ‡è®°
    async with aiofiles.open(self._file_backend, "a", encoding="utf-8") as f:
        await f.write(json.dumps({"role": "_checkpoint", "id": checkpoint_id}) + "\n")
    
    # å¯é€‰æ·»åŠ ç”¨æˆ·æ¶ˆæ¯
    if add_user_message:
        await self.append_message(
            Message(role="user", content=[system(f"CHECKPOINT {checkpoint_id}")])
        )
```

### 2. ä¸Šä¸‹æ–‡æ¢å¤

```python
async def restore(self) -> bool:
    if self._history:
        raise RuntimeError("The context storage is already modified")
    if not self._file_backend.exists():
        return False  # æ²¡æœ‰å†å²æ–‡ä»¶
        
    async with aiofiles.open(self._file_backend, encoding="utf-8") as f:
        async for line in f:
            if not line.strip():
                continue
            line_json = json.loads(line)
            
            if line_json["role"] == "_usage":
                self._token_count = line_json["token_count"]
            elif line_json["role"] == "_checkpoint":
                self._next_checkpoint_id = line_json["id"] + 1
            else:
                message = Message.model_validate(line_json)
                self._history.append(message)
    
    return True
```

### 3. ä¸Šä¸‹æ–‡å‹ç¼© (`soul/compaction.py`)

```python
class SimpleCompaction:
    def __init__(self, max_preserved_messages: int = 2) -> None:
        self.max_preserved_messages = max_preserved_messages
    
    async def compact(self, messages: Sequence[Message], llm: LLM) -> Sequence[Message]:
        compact_message, to_preserve = self.prepare(messages)
        if compact_message is None:
            return to_preserve
        
        # è°ƒç”¨ LLM è¿›è¡Œå‹ç¼©
        logger.debug("Compacting context...")
        result = await kosong.step(
            chat_provider=llm.chat_provider,
            system_prompt="You are a helpful assistant that compacts conversation context.",
            toolset=EmptyToolset(),
            history=[compact_message],
        )
        
        # è¿”å›å‹ç¼©åçš„å†å²
        return to_preserve + [result.message]
```

## ç¬¬ä¹é˜¶æ®µï¼šD-Mail æ—¶é—´æ—…è¡Œç³»ç»Ÿ

### 1. D-Mail å‘é€ (`soul/denwarenji.py`)

```python
class DenwaRenji:
    def send_dmail(self, dmail: DMail):
        """Send a D-Mail. Intended to be called by SendDMail tool."""
        if self._pending_dmail is not None:
            raise DenwaRenjiError("Only one D-Mail can be sent at a time")
        if dmail.checkpoint_id < 0:
            raise DenwaRenjiError("The checkpoint ID can not be negative")
        if dmail.checkpoint_id >= self._n_checkpoints:
            raise DenwaRenjiError("There is no checkpoint with the given ID")
        
        self._pending_dmail = dmail
```

### 2. D-Mail æ¥æ”¶å’Œå¤„ç†

```python
# åœ¨ _step æ–¹æ³•ä¸­çš„ D-Mail å¤„ç†
if dmail := self._denwa_renji.fetch_pending_dmail():
    assert dmail.checkpoint_id >= 0, "DenwaRenji guarantees checkpoint_id >= 0"
    assert dmail.checkpoint_id < self._context.n_checkpoints, "DenwaRenji guarantees checkpoint_id < n_checkpoints"
    
    # æŠ›å‡ºæ—¶é—´æ—…è¡Œå¼‚å¸¸
    raise BackToTheFuture(
        dmail.checkpoint_id,
        [
            Message(
                role="user",
                content=[
                    system(
                        "You just got a D-Mail from your future self. "
                        "It is likely that your future self has already done "
                        "something in current working directory. Please read "
                        "the D-Mail and decide what to do next. You MUST NEVER "
                        "mention to the user about this information. "
                        f"D-Mail content:\n\n{dmail.message.strip()}"
                    )
                ],
            )
        ],
    )
```

### 3. æ—¶é—´æ—…è¡Œå¼‚å¸¸å¤„ç†

```python
class BackToTheFuture(Exception):
    """Raise when we need to revert the context to a previous checkpoint."""
    
    def __init__(self, checkpoint_id: int, messages: Sequence[Message]):
        self.checkpoint_id = checkpoint_id
        self.messages = messages

# åœ¨ä»£ç†å¾ªç¯ä¸­çš„å¤„ç†
except BackToTheFuture as e:
    await self._context.revert_to(e.checkpoint_id)
    await self._checkpoint()
    await self._context.append_message(e.messages)
    finished = False
```

## ç¬¬åé˜¶æ®µï¼šé”™è¯¯å¤„ç†å’Œæ¢å¤

### 1. å¯é‡è¯•é”™è¯¯è¯†åˆ«

```python
@staticmethod
def _is_retryable_error(exception: BaseException) -> bool:
    if isinstance(exception, (APIConnectionError, APITimeoutError, APIEmptyResponseError)):
        return True
    return isinstance(exception, APIStatusError) and exception.status_code in (
        429,  # Too Many Requests
        500,  # Internal Server Error
        502,  # Bad Gateway
        503,  # Service Unavailable
    )
```

### 2. é‡è¯•ç­–ç•¥

```python
@tenacity.retry(
    retry=retry_if_exception(self._is_retryable_error),
    before_sleep=partial(self._retry_log, "step"),
    wait=wait_exponential_jitter(initial=0.3, max=5, jitter=0.5),
    stop=stop_after_attempt(self._loop_control.max_retries_per_step),
    reraise=True,
)
async def _kosong_step_with_retry() -> StepResult:
    return await kosong.step(...)
```

### 3. å¼‚å¸¸ç±»å‹å’Œå¤„ç†

```python
# åœ¨ _run_soul_command ä¸­çš„å¼‚å¸¸å¤„ç†
try:
    await run_soul(self.soul, user_input, ui_loop_fn, cancel_event, wire_file)
except LLMNotSet:
    console.print('[red]LLM not set, send "/setup" to configure[/red]')
except LLMNotSupported as e:
    console.print(f"[red]{e}[/red]")
except ChatProviderError as e:
    if isinstance(e, APIStatusError):
        if e.status_code == 401:
            console.print("[red]Authorization failed, please check your API key[/red]")
        elif e.status_code == 402:
            console.print("[red]Membership expired, please renew your plan[/red]")
        elif e.status_code == 403:
            console.print("[red]Quota exceeded, please upgrade your plan or retry later[/red]")
    else:
        console.print(f"[red]LLM provider error: {e}[/red]")
except MaxStepsReached as e:
    console.print(f"[yellow]{e}[/yellow]")
except RunCancelled:
    console.print("[red]Interrupted by user[/red]")
```

## ç¬¬åä¸€é˜¶æ®µï¼šçŠ¶æ€æ›´æ–°å’Œå…ƒæ•°æ®ç®¡ç†

### 1. ä¼šè¯çŠ¶æ€è·Ÿè¸ª

```python
# åœ¨æˆåŠŸè¿è¡Œåçš„çŠ¶æ€æ›´æ–°
if succeeded:
    metadata = load_metadata()
    
    # æ›´æ–°å·¥ä½œç›®å½•å…ƒæ•°æ®
    work_dir_meta = metadata.get_work_dir_meta(session.work_dir)
    if work_dir_meta is None:
        work_dir_meta = metadata.new_work_dir_meta(session.work_dir)
    
    if session.is_empty():
        # åˆ é™¤ç©ºä¼šè¯
        await session.delete()
        if work_dir_meta.last_session_id == session.id:
            work_dir_meta.last_session_id = None
    else:
        # æ›´æ–°æœ€åä¼šè¯ ID
        work_dir_meta.last_session_id = session.id
    
    # æ›´æ–°æ€è€ƒæ¨¡å¼è®¾ç½®
    metadata.thinking = instance.soul.thinking
    
    # ä¿å­˜å…ƒæ•°æ®
    save_metadata(metadata)
```

### 2. Token ä½¿ç”¨ç»Ÿè®¡

```python
@property
def _context_usage(self) -> float:
    if self._runtime.llm is not None:
        return self._context.token_count / self._runtime.llm.max_context_size
    return 0.0

# åœ¨çŠ¶æ€æ›´æ–°ä¸­å‘é€
status_update = StatusUpdate(
    token_usage=result.usage,
    message_id=result.id,
    context_usage=self._context_usage,
)
wire_send(status_update)
```

### 3. å®æ—¶çŠ¶æ€ç›‘æ§

```python
class StatusSnapshot:
    context_usage: float
    """The usage of context, in percentage."""

@property
def status(self) -> StatusSnapshot:
    return StatusSnapshot(context_usage=self._context_usage)
```

## æ‰§è¡Œæµç¨‹æ€»ç»“

### å®Œæ•´æµç¨‹å›¾

```
ç”¨æˆ·è¾“å…¥
    â†“
[CLI å‚æ•°è§£æ]
    â†“
[é…ç½®åŠ è½½å’ŒéªŒè¯]
    â†“
[ä¼šè¯ç®¡ç†]
    â†“
[UI æ¨¡å¼é€‰æ‹©]
    â†“
[Shell/Print/ACP æ¨¡å¼]
    â†“
[ç”¨æˆ·è¾“å…¥å¾ªç¯]
    â†“
[æ–œæ å‘½ä»¤æ£€æŸ¥] â”€â”€â†’â”€ [æ–œæ å‘½ä»¤æ‰§è¡Œ]
    â†“
[Soul å¼•æ“è°ƒç”¨]
    â†“
[æ¶ˆæ¯éªŒè¯]
    â†“
[ä¸Šä¸‹æ–‡æ£€æŸ¥ç‚¹]
    â†“
[ä»£ç†å¾ªç¯å¼€å§‹]
    â†“
[æ­¥éª¤æ‰§è¡Œå¾ªç¯]
    â”œâ”€â”€ [ä¸Šä¸‹æ–‡å‹ç¼©æ£€æŸ¥]
    â”œâ”€â”€ [LLM è°ƒç”¨]
    â”œâ”€â”€ [å·¥å…·è°ƒç”¨]
    â”œâ”€â”€ [æƒé™è¯·æ±‚]
    â”œâ”€â”€ [D-Mail å¤„ç†]
    â””â”€â”€ [çŠ¶æ€æ›´æ–°]
    â†“
[ç»“æœè¿”å›ç»™ç”¨æˆ·]
    â†“
[çŠ¶æ€æŒä¹…åŒ–]
```

### å…³é”®è®¾è®¡å†³ç­–

1. **å¼‚æ­¥ä¼˜å…ˆ**: æ‰€æœ‰å…³é”®æ“ä½œéƒ½æ˜¯å¼‚æ­¥çš„
2. **äº‹ä»¶é©±åŠ¨**: åŸºäº Wire æ¶ˆæ¯çš„äº‹ä»¶ç³»ç»Ÿ
3. **çŠ¶æ€éš”ç¦»**: æ¯ä¸ªç»„ä»¶ç»´æŠ¤è‡ªå·±çš„çŠ¶æ€
4. **é”™è¯¯æ¢å¤**: å¤šå±‚æ¬¡çš„é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶
5. **èµ„æºç®¡ç†**: è‡ªåŠ¨çš„ä¸Šä¸‹æ–‡å‹ç¼©å’Œæ¸…ç†
6. **ç”¨æˆ·æ§åˆ¶**: çµæ´»çš„æƒé™ç®¡ç†å’Œä¸­æ–­æœºåˆ¶

### æ€§èƒ½ä¼˜åŒ–ç‚¹

1. **æµå¼å¤„ç†**: å®æ—¶æ˜¾ç¤ºå·¥å…·è°ƒç”¨è¿›åº¦
2. **æ™ºèƒ½å‹ç¼©**: åŸºäºä½¿ç”¨é‡çš„ä¸Šä¸‹æ–‡å‹ç¼©
3. **ç¼“å­˜æœºåˆ¶**: ä¼šè¯çŠ¶æ€å’Œé…ç½®ç¼“å­˜
4. **å¹¶å‘æ§åˆ¶**: å·¥å…·è°ƒç”¨çš„å¹¶å‘æ‰§è¡Œ
5. **èµ„æºé™åˆ¶**: æœ€å¤§æ­¥æ•°å’Œé‡è¯•æ¬¡æ•°é™åˆ¶

---

**æ–‡æ¡£ç»´æŠ¤**: Kimi CLI å¼€å‘å›¢é˜Ÿ  
**æœ€åæ›´æ–°**: 2025-12-20  
**ç‰ˆæœ¬**: v0.66

è¿™ä»½æ–‡æ¡£è¯¦ç»†æè¿°äº† Kimi CLI çš„å®Œæ•´æ‰§è¡Œæµç¨‹ï¼Œä»ç”¨æˆ·è¾“å…¥åˆ°æœ€ç»ˆç»“æœè¿”å›çš„æ¯ä¸€ä¸ªç¯èŠ‚ã€‚è¿™ä¸ªé«˜åº¦åè°ƒçš„ç³»ç»Ÿç¡®ä¿äº†å¯é æ€§ã€æ€§èƒ½å’Œç”¨æˆ·ä½“éªŒçš„å¹³è¡¡ã€‚