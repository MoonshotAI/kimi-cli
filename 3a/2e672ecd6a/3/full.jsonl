{"type":"file-history-snapshot","messageId":"bb248cc5-0bf4-43a6-8944-26dee2cd25bf","snapshot":{"messageId":"bb248cc5-0bf4-43a6-8944-26dee2cd25bf","trackedFileBackups":{},"timestamp":"2026-02-25T08:04:32.535Z"},"isSnapshotUpdate":false}
{"parentUuid":null,"isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"progress","data":{"type":"hook_progress","hookEvent":"SessionStart","hookName":"SessionStart:clear","command":"entire hooks claude-code session-start"},"parentToolUseID":"8b9f2874-c689-4768-9302-c3d21a5bb427","toolUseID":"8b9f2874-c689-4768-9302-c3d21a5bb427","timestamp":"2026-02-25T08:04:32.236Z","uuid":"e2489ba4-67c3-49c7-beeb-67eb2f91fd3d"}
{"parentUuid":"e2489ba4-67c3-49c7-beeb-67eb2f91fd3d","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"user","message":{"role":"user","content":"Implement the following plan:\n\n# Fix: CLI 中 FetchURL 截断 URL 支持 Ctrl+Click 打开完整链接\n\n## Context\n\nWeb 端直接从 `toolCall.input.url` 读取完整 URL 用于超链接，与 `primaryParam`（截断文本）分离。CLI 端应采用相同模式：从 `self._lexer`（原始 JSON）提取完整 URL，不修改 `extract_key_argument`。\n\n## 方案\n\n**仅修改 `src/kimi_cli/ui/shell/visualize.py`**，与 web 端 `tool.tsx` 的模式对齐。\n\n### 修改详情\n\n#### 新增导入\n```python\nimport json\nfrom rich.style import Style\n```\n\n#### `_ToolCallBlock` 新增私有静态方法\n\n```python\n@staticmethod\ndef _extract_full_url(json_content: str | streamingjson.Lexer, tool_name: str) -> str | None:\n    if tool_name != \"FetchURL\":\n        return None\n    json_str = json_content.complete_json() if isinstance(json_content, streamingjson.Lexer) else json_content\n    try:\n        args = json.loads(json_str)\n    except (json.JSONDecodeError, ValueError):\n        return None\n    if isinstance(args, dict) and args.get(\"url\"):\n        return str(args[\"url\"])\n    return None\n```\n\n等价于 web 端的：\n```typescript\nconst fullUrl = rawName === \"FetchURL\" && input?.url ? input.url : null;\n```\n\n#### `__init__` 新增 `self._full_url`\n\n```python\nself._full_url = self._extract_full_url(self._lexer, self._tool_name)\n```\n\n#### `append_args_part` 同步更新\n\n```python\nself._full_url = self._extract_full_url(self._lexer, self._tool_name)\n```\n\n#### `_get_headline_markup()` → `_build_headline_text()` 返回 `Text`\n\n截断文本通过 `Style(link=full_url)` 附加 OSC 8 超链接（仅 FetchURL）：\n\n```python\ndef _build_headline_text(self, ...) -> Text:\n    text = Text()\n    text.append(\"Used \" if finished else \"Using \")\n    text.append(tool_name, style=\"blue\")\n    if argument:\n        text.append(\" (\", style=\"grey50\")\n        arg_style = Style(color=\"grey50\", link=full_url) if full_url else \"grey50\"\n        text.append(argument, style=arg_style)\n        text.append(\")\", style=\"grey50\")\n    return text\n```\n\n#### `_compose` 中追加完整 URL 提示行\n\n当 URL 被截断时（`full_url != argument`），在 headline 下方显示完整 URL：\n```\n● Used FetchURL (https://example.com/ver.../to/something)\n  ↳ https://full-url-here.com/very/long/path/to/something\n```\n\n#### 子代理工具调用同样处理\n\n### 不修改的文件\n\n- `tools/__init__.py` — 不修改\n- `acp/session.py` — 不修改\n\n## 验证\n\n1. FetchURL 长 URL（>50 字符）：截断文本可 Ctrl+Click，下方显示完整 URL\n2. FetchURL 短 URL（≤50 字符）：无额外提示行\n3. 非 FetchURL 工具：显示不受影响\n\n\nIf you need specific details from before exiting plan mode (like exact code snippets, error messages, or content you generated), read the full transcript at: /Users/moonshot/.REDACTED.jsonl"},"uuid":"bb248cc5-0bf4-43a6-8944-26dee2cd25bf","timestamp":"2026-02-25T08:04:31.768Z","planContent":"# Fix: CLI 中 FetchURL 截断 URL 支持 Ctrl+Click 打开完整链接\n\n## Context\n\nWeb 端直接从 `toolCall.input.url` 读取完整 URL 用于超链接，与 `primaryParam`（截断文本）分离。CLI 端应采用相同模式：从 `self._lexer`（原始 JSON）提取完整 URL，不修改 `extract_key_argument`。\n\n## 方案\n\n**仅修改 `src/kimi_cli/ui/shell/visualize.py`**，与 web 端 `tool.tsx` 的模式对齐。\n\n### 修改详情\n\n#### 新增导入\n```python\nimport json\nfrom rich.style import Style\n```\n\n#### `_ToolCallBlock` 新增私有静态方法\n\n```python\n@staticmethod\ndef _extract_full_url(json_content: str | streamingjson.Lexer, tool_name: str) -> str | None:\n    if tool_name != \"FetchURL\":\n        return None\n    json_str = json_content.complete_json() if isinstance(json_content, streamingjson.Lexer) else json_content\n    try:\n        args = json.loads(json_str)\n    except (json.JSONDecodeError, ValueError):\n        return None\n    if isinstance(args, dict) and args.get(\"url\"):\n        return str(args[\"url\"])\n    return None\n```\n\n等价于 web 端的：\n```typescript\nconst fullUrl = rawName === \"FetchURL\" && input?.url ? input.url : null;\n```\n\n#### `__init__` 新增 `self._full_url`\n\n```python\nself._full_url = self._extract_full_url(self._lexer, self._tool_name)\n```\n\n#### `append_args_part` 同步更新\n\n```python\nself._full_url = self._extract_full_url(self._lexer, self._tool_name)\n```\n\n#### `_get_headline_markup()` → `_build_headline_text()` 返回 `Text`\n\n截断文本通过 `Style(link=full_url)` 附加 OSC 8 超链接（仅 FetchURL）：\n\n```python\ndef _build_headline_text(self, ...) -> Text:\n    text = Text()\n    text.append(\"Used \" if finished else \"Using \")\n    text.append(tool_name, style=\"blue\")\n    if argument:\n        text.append(\" (\", style=\"grey50\")\n        arg_style = Style(color=\"grey50\", link=full_url) if full_url else \"grey50\"\n        text.append(argument, style=arg_style)\n        text.append(\")\", style=\"grey50\")\n    return text\n```\n\n#### `_compose` 中追加完整 URL 提示行\n\n当 URL 被截断时（`full_url != argument`），在 headline 下方显示完整 URL：\n```\n● Used FetchURL (https://example.com/ver.../to/something)\n  ↳ https://full-url-here.com/very/long/path/to/something\n```\n\n#### 子代理工具调用同样处理\n\n### 不修改的文件\n\n- `tools/__init__.py` — 不修改\n- `acp/session.py` — 不修改\n\n## 验证\n\n1. FetchURL 长 URL（>50 字符）：截断文本可 Ctrl+Click，下方显示完整 URL\n2. FetchURL 短 URL（≤50 字符）：无额外提示行\n3. 非 FetchURL 工具：显示不受影响\n"}
{"parentUuid":"bb248cc5-0bf4-43a6-8944-26dee2cd25bf","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_01BdgDmB6zvprb7ngxsXtzH3","type":"message","role":"assistant","content":[{"type":"text","text":"\n\nI'll start by reading the current state of the file to understand the existing code structure."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":1594,"cache_read_input_tokens":19877,"cache_creation":{"ephemeral_5m_input_tokens":1594,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"type":"assistant","uuid":"606bbcdc-e8cc-4cfd-9fac-1027fac255ea","timestamp":"2026-02-25T08:04:35.656Z"}
{"parentUuid":"606bbcdc-e8cc-4cfd-9fac-1027fac255ea","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_01BdgDmB6zvprb7ngxsXtzH3","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016N1up9Y3sCXyvr9heiP88R","name":"Read","input":{"file_path":"/Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/ui/shell/visualize.py"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":1594,"cache_read_input_tokens":19877,"cache_creation":{"ephemeral_5m_input_tokens":1594,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"type":"assistant","uuid":"186c5caf-00b0-4e7b-818d-87d0bac5c366","timestamp":"2026-02-25T08:04:36.190Z"}
{"parentUuid":"186c5caf-00b0-4e7b-818d-87d0bac5c366","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_016N1up9Y3sCXyvr9heiP88R","toolUseID":"toolu_016N1up9Y3sCXyvr9heiP88R","timestamp":"2026-02-25T08:04:36.694Z","uuid":"6d1f58d9-2c72-405e-8aa7-1759be468fa3"}
{"parentUuid":"186c5caf-00b0-4e7b-818d-87d0bac5c366","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016N1up9Y3sCXyvr9heiP88R","type":"tool_result","content":"     1→from __future__ import annotations\n     2→\n     3→import asyncio\n     4→from collections import deque\n     5→from collections.abc import Awaitable, Callable\n     6→from contextlib import asynccontextmanager, suppress\n     7→from typing import NamedTuple\n     8→\n     9→import streamingjson  # type: ignore[reportMissingTypeStubs]\n    10→from kosong.message import Message\n    11→from kosong.tooling import ToolError, ToolOk\n    12→from rich.console import Group, RenderableType\n    13→from rich.live import Live\n    14→from rich.markup import escape\n    15→from rich.padding import Padding\n    16→from rich.panel import Panel\n    17→from rich.spinner import Spinner\n    18→from rich.text import Text\n    19→\n    20→from kimi_cli.tools import extract_key_argument\n    21→from kimi_cli.ui.shell.console import console\n    22→from kimi_cli.ui.shell.keyboard import KeyboardListener, KeyEvent\n    23→from kimi_cli.utils.aioqueue import QueueShutDown\n    24→from kimi_cli.utils.diff import format_unified_diff\n    25→from kimi_cli.utils.logging import logger\n    26→from kimi_cli.utils.message import message_stringify\n    27→from kimi_cli.utils.rich.columns import BulletColumns\n    28→from kimi_cli.utils.rich.markdown import Markdown\n    29→from kimi_cli.utils.rich.syntax import KimiSyntax\n    30→from kimi_cli.wire import WireUISide\n    31→from kimi_cli.wire.types import (\n    32→    ApprovalRequest,\n    33→    ApprovalResponse,\n    34→    BriefDisplayBlock,\n    35→    CompactionBegin,\n    36→    CompactionEnd,\n    37→    ContentPart,\n    38→    DiffDisplayBlock,\n    39→    ShellDisplayBlock,\n    40→    StatusUpdate,\n    41→    StepBegin,\n    42→    StepInterrupted,\n    43→    SubagentEvent,\n    44→    TextPart,\n    45→    ThinkPart,\n    46→    TodoDisplayBlock,\n    47→    ToolCall,\n    48→    ToolCallPart,\n    49→    ToolCallRequest,\n    50→    ToolResult,\n    51→    ToolReturnValue,\n    52→    TurnBegin,\n    53→    TurnEnd,\n    54→    WireMessage,\n    55→)\n    56→\n    57→MAX_SUBAGENT_TOOL_CALLS_TO_SHOW = 4\n    58→\n    59→# Truncation limits for approval request display\n    60→MAX_PREVIEW_LINES = 4\n    61→\n    62→\n    63→async def visualize(\n    64→    wire: WireUISide,\n    65→    *,\n    66→    initial_status: StatusUpdate,\n    67→    cancel_event: asyncio.Event | None = None,\n    68→):\n    69→    \"\"\"\n    70→    A loop to consume agent events and visualize the agent behavior.\n    71→\n    72→    Args:\n    73→        wire: Communication channel with the agent\n    74→        initial_status: Initial status snapshot\n    75→        cancel_event: Event that can be set (e.g., by ESC key) to cancel the run\n    76→    \"\"\"\n    77→    view = _LiveView(initial_status, cancel_event)\n    78→    await view.visualize_loop(wire)\n    79→\n    80→\n    81→class _ContentBlock:\n    82→    def __init__(self, is_think: bool):\n    83→        self.is_think = is_think\n    84→        self._spinner = Spinner(\"dots\", \"Thinking...\" if is_think else \"Composing...\")\n    85→        self.raw_text = \"\"\n    86→\n    87→    def compose(self) -> RenderableType:\n    88→        return self._spinner\n    89→\n    90→    def compose_final(self) -> RenderableType:\n    91→        return BulletColumns(\n    92→            Markdown(\n    93→                self.raw_text,\n    94→                style=\"grey50 italic\" if self.is_think else \"\",\n    95→            ),\n    96→            bullet_style=\"grey50\" if self.is_think else None,\n    97→        )\n    98→\n    99→    def append(self, content: str) -> None:\n   100→        self.raw_text += content\n   101→\n   102→\n   103→class _ToolCallBlock:\n   104→    class FinishedSubCall(NamedTuple):\n   105→        call: ToolCall\n   106→        result: ToolReturnValue\n   107→\n   108→    def __init__(self, tool_call: ToolCall):\n   109→        self._tool_name = tool_call.function.name\n   110→        self._lexer = streamingjson.Lexer()\n   111→        if tool_call.function.arguments is not None:\n   112→            self._lexer.append_string(tool_call.function.arguments)\n   113→\n   114→        self._argument = extract_key_argument(self._lexer, self._tool_name)\n   115→        self._result: ToolReturnValue | None = None\n   116→\n   117→        self._ongoing_subagent_tool_calls: dict[str, ToolCall] = {}\n   118→        self._last_subagent_tool_call: ToolCall | None = None\n   119→        self._n_finished_subagent_tool_calls = 0\n   120→        self._finished_subagent_tool_calls = deque[_ToolCallBlock.FinishedSubCall](\n   121→            maxlen=MAX_SUBAGENT_TOOL_CALLS_TO_SHOW\n   122→        )\n   123→\n   124→        self._spinning_dots = Spinner(\"dots\", text=\"\")\n   125→        self._renderable: RenderableType = self._compose()\n   126→\n   127→    def compose(self) -> RenderableType:\n   128→        return self._renderable\n   129→\n   130→    @property\n   131→    def finished(self) -> bool:\n   132→        return self._result is not None\n   133→\n   134→    def append_args_part(self, args_part: str):\n   135→        if self.finished:\n   136→            return\n   137→        self._lexer.append_string(args_part)\n   138→        # TODO: maybe don't extract detail if it's already stable\n   139→        argument = extract_key_argument(self._lexer, self._tool_name)\n   140→        if argument and argument != self._argument:\n   141→            self._argument = argument\n   142→            self._renderable = BulletColumns(\n   143→                Text.from_markup(self._get_headline_markup()),\n   144→                bullet=self._spinning_dots,\n   145→            )\n   146→\n   147→    def finish(self, result: ToolReturnValue):\n   148→        self._result = result\n   149→        self._renderable = self._compose()\n   150→\n   151→    def append_sub_tool_call(self, tool_call: ToolCall):\n   152→        self._ongoing_subagent_tool_calls[tool_call.id] = tool_call\n   153→        self._last_subagent_tool_call = tool_call\n   154→\n   155→    def append_sub_tool_call_part(self, tool_call_part: ToolCallPart):\n   156→        if self._last_subagent_tool_call is None:\n   157→            return\n   158→        if not tool_call_part.arguments_part:\n   159→            return\n   160→        if self._last_subagent_tool_call.function.arguments is None:\n   161→            self._last_subagent_tool_call.function.arguments = tool_call_part.arguments_part\n   162→        else:\n   163→            self._last_subagent_tool_call.function.arguments += tool_call_part.arguments_part\n   164→\n   165→    def finish_sub_tool_call(self, tool_result: ToolResult):\n   166→        self._last_subagent_tool_call = None\n   167→        sub_tool_call = self._ongoing_subagent_tool_calls.pop(tool_result.tool_call_id, None)\n   168→        if sub_tool_call is None:\n   169→            return\n   170→\n   171→        self._finished_subagent_tool_calls.append(\n   172→            _ToolCallBlock.FinishedSubCall(\n   173→                call=sub_tool_call,\n   174→                result=tool_result.return_value,\n   175→            )\n   176→        )\n   177→        self._n_finished_subagent_tool_calls += 1\n   178→        self._renderable = self._compose()\n   179→\n   180→    def _compose(self) -> RenderableType:\n   181→        lines: list[RenderableType] = [\n   182→            Text.from_markup(self._get_headline_markup()),\n   183→        ]\n   184→\n   185→        if self._n_finished_subagent_tool_calls > MAX_SUBAGENT_TOOL_CALLS_TO_SHOW:\n   186→            n_hidden = self._n_finished_subagent_tool_calls - MAX_SUBAGENT_TOOL_CALLS_TO_SHOW\n   187→            lines.append(\n   188→                BulletColumns(\n   189→                    Text(\n   190→                        f\"{n_hidden} more tool call{'s' if n_hidden > 1 else ''} ...\",\n   191→                        style=\"grey50 italic\",\n   192→                    ),\n   193→                    bullet_style=\"grey50\",\n   194→                )\n   195→            )\n   196→        for sub_call, sub_result in self._finished_subagent_tool_calls:\n   197→            argument = extract_key_argument(\n   198→                sub_call.function.arguments or \"\", sub_call.function.name\n   199→            )\n   200→            lines.append(\n   201→                BulletColumns(\n   202→                    Text.from_markup(\n   203→                        f\"Used [blue]{sub_call.function.name}[/blue]\"\n   204→                        + (f\" [grey50]({argument})[/grey50]\" if argument else \"\")\n   205→                    ),\n   206→                    bullet_style=\"green\" if not sub_result.is_error else \"red\",\n   207→                )\n   208→            )\n   209→\n   210→        if self._result is not None:\n   211→            for block in self._result.display:\n   212→                if isinstance(block, BriefDisplayBlock):\n   213→                    style = \"grey50\" if not self._result.is_error else \"red\"\n   214→                    if block.text:\n   215→                        lines.append(Markdown(block.text, style=style))\n   216→                elif isinstance(block, TodoDisplayBlock):\n   217→                    markdown = self._render_todo_markdown(block)\n   218→                    if markdown:\n   219→                        lines.append(Markdown(markdown, style=\"grey50\"))\n   220→\n   221→        if self.finished:\n   222→            assert self._result is not None\n   223→            return BulletColumns(\n   224→                Group(*lines),\n   225→                bullet_style=\"green\" if not self._result.is_error else \"red\",\n   226→            )\n   227→        else:\n   228→            return BulletColumns(\n   229→                Group(*lines),\n   230→                bullet=self._spinning_dots,\n   231→            )\n   232→\n   233→    def _get_headline_markup(self) -> str:\n   234→        return f\"{'Used' if self.finished else 'Using'} [blue]{self._tool_name}[/blue]\" + (\n   235→            f\" [grey50]({escape(self._argument)})[/grey50]\" if self._argument else \"\"\n   236→        )\n   237→\n   238→    def _render_todo_markdown(self, block: TodoDisplayBlock) -> str:\n   239→        lines: list[str] = []\n   240→        for todo in block.items:\n   241→            normalized = todo.status.replace(\"_\", \" \").lower()\n   242→            match normalized:\n   243→                case \"pending\":\n   244→                    lines.append(f\"- {todo.title}\")\n   245→                case \"in progress\":\n   246→                    lines.append(f\"- {todo.title} ←\")\n   247→                case \"done\":\n   248→                    lines.append(f\"- ~~{todo.title}~~\")\n   249→                case _:\n   250→                    lines.append(f\"- {todo.title}\")\n   251→        return \"\\n\".join(lines)\n   252→\n   253→\n   254→class _ApprovalContentBlock(NamedTuple):\n   255→    \"\"\"A pre-rendered content block for approval request with line count.\"\"\"\n   256→\n   257→    text: str\n   258→    lines: int\n   259→    style: str = \"\"\n   260→    lexer: str = \"\"\n   261→\n   262→\n   263→class _ApprovalRequestPanel:\n   264→    def __init__(self, request: ApprovalRequest):\n   265→        self.request = request\n   266→        self.options: list[tuple[str, ApprovalResponse.Kind]] = [\n   267→            (\"Approve once\", \"approve\"),\n   268→            (\"Approve for this session\", \"approve_for_session\"),\n   269→            (\"Reject, tell Kimi what to do instead\", \"reject\"),\n   270→        ]\n   271→        self.selected_index = 0\n   272→\n   273→        # Pre-render all content blocks with line counts\n   274→        self._content_blocks: list[_ApprovalContentBlock] = []\n   275→        last_diff_path: str | None = None\n   276→\n   277→        # Handle description (only if no display blocks)\n   278→        if request.description and not request.display:\n   279→            text = request.description.rstrip(\"\\n\")\n   280→            self._content_blocks.append(\n   281→                _ApprovalContentBlock(text=text, lines=text.count(\"\\n\") + 1)\n   282→            )\n   283→\n   284→        # Handle display blocks\n   285→        for block in request.display:\n   286→            if isinstance(block, DiffDisplayBlock):\n   287→                # File path or ellipsis\n   288→                if block.path != last_diff_path:\n   289→                    self._content_blocks.append(\n   290→                        _ApprovalContentBlock(text=block.path, lines=1, style=\"bold\")\n   291→                    )\n   292→                    last_diff_path = block.path\n   293→                else:\n   294→                    self._content_blocks.append(\n   295→                        _ApprovalContentBlock(text=\"⋮\", lines=1, style=\"dim\")\n   296→                    )\n   297→                # Diff content\n   298→                diff_text = format_unified_diff(\n   299→                    block.old_text,\n   300→                    block.new_text,\n   301→                    block.path,\n   302→                    include_file_header=False,\n   303→                ).rstrip(\"\\n\")\n   304→                self._content_blocks.append(\n   305→                    _ApprovalContentBlock(\n   306→                        text=diff_text, lines=diff_text.count(\"\\n\") + 1, lexer=\"diff\"\n   307→                    )\n   308→                )\n   309→            elif isinstance(block, ShellDisplayBlock):\n   310→                text = block.command.rstrip(\"\\n\")\n   311→                self._content_blocks.append(\n   312→                    _ApprovalContentBlock(\n   313→                        text=text, lines=text.count(\"\\n\") + 1, lexer=block.language\n   314→                    )\n   315→                )\n   316→                last_diff_path = None\n   317→            elif isinstance(block, BriefDisplayBlock) and block.text:\n   318→                text = block.text.rstrip(\"\\n\")\n   319→                self._content_blocks.append(\n   320→                    _ApprovalContentBlock(text=text, lines=text.count(\"\\n\") + 1, style=\"grey50\")\n   321→                )\n   322→                last_diff_path = None\n   323→\n   324→        self._total_lines = sum(b.lines for b in self._content_blocks)\n   325→        self.has_expandable_content = self._total_lines > MAX_PREVIEW_LINES\n   326→\n   327→    def render(self) -> RenderableType:\n   328→        \"\"\"Render the approval menu as a panel.\"\"\"\n   329→        content_lines: list[RenderableType] = [\n   330→            Text.from_markup(\n   331→                \"[yellow]⚠ \"\n   332→                f\"{escape(self.request.sender)} is requesting approval to \"\n   333→                f\"{escape(self.request.action)}:[/yellow]\"\n   334→            )\n   335→        ]\n   336→        content_lines.append(Text(\"\"))\n   337→\n   338→        # Render content with line budget\n   339→        remaining = MAX_PREVIEW_LINES\n   340→        for block in self._content_blocks:\n   341→            if remaining <= 0:\n   342→                break\n   343→            content_lines.append(self._render_block(block, remaining))\n   344→            remaining -= min(block.lines, remaining)\n   345→\n   346→        if self.has_expandable_content:\n   347→            content_lines.append(Text(\"... (truncated, ctrl-e to expand)\", style=\"dim italic\"))\n   348→\n   349→        lines: list[RenderableType] = []\n   350→        if content_lines:\n   351→            lines.append(Padding(Group(*content_lines), (0, 0, 0, 2)))\n   352→\n   353→        # Add menu options\n   354→        if lines:\n   355→            lines.append(Text(\"\"))\n   356→        for i, (option_text, _) in enumerate(self.options):\n   357→            if i == self.selected_index:\n   358→                lines.append(Text(f\"→ {option_text}\", style=\"cyan\"))\n   359→            else:\n   360→                lines.append(Text(f\"  {option_text}\", style=\"grey50\"))\n   361→\n   362→        return Padding(Group(*lines), 1)\n   363→\n   364→    def _render_block(\n   365→        self, block: _ApprovalContentBlock, max_lines: int | None = None\n   366→    ) -> RenderableType:\n   367→        \"\"\"Render a content block, optionally truncated.\"\"\"\n   368→        text = block.text\n   369→        if max_lines is not None and block.lines > max_lines:\n   370→            # Truncate to max_lines\n   371→            text = \"\\n\".join(text.split(\"\\n\")[:max_lines])\n   372→\n   373→        if block.lexer:\n   374→            return KimiSyntax(text, block.lexer)\n   375→        return Text(text, style=block.style)\n   376→\n   377→    def render_full(self) -> list[RenderableType]:\n   378→        \"\"\"Render full content for pager (no truncation).\"\"\"\n   379→        return [self._render_block(block) for block in self._content_blocks]\n   380→\n   381→    def move_up(self):\n   382→        \"\"\"Move selection up.\"\"\"\n   383→        self.selected_index = (self.selected_index - 1) % len(self.options)\n   384→\n   385→    def move_down(self):\n   386→        \"\"\"Move selection down.\"\"\"\n   387→        self.selected_index = (self.selected_index + 1) % len(self.options)\n   388→\n   389→    def get_selected_response(self) -> ApprovalResponse.Kind:\n   390→        \"\"\"Get the approval response based on selected option.\"\"\"\n   391→        return self.options[self.selected_index][1]\n   392→\n   393→\n   394→def _show_approval_in_pager(panel: _ApprovalRequestPanel) -> None:\n   395→    \"\"\"Show the full approval request content in a pager.\"\"\"\n   396→    with console.screen(), console.pager(styles=True):\n   397→        # Header: matches the style in _ApprovalRequestPanel.render()\n   398→        console.print(\n   399→            Text.from_markup(\n   400→                \"[yellow]⚠ \"\n   401→                f\"{escape(panel.request.sender)} is requesting approval to \"\n   402→                f\"{escape(panel.request.action)}:[/yellow]\"\n   403→            )\n   404→        )\n   405→        console.print()\n   406→\n   407→        # Render full content (no truncation)\n   408→        for renderable in panel.render_full():\n   409→            console.print(renderable)\n   410→\n   411→\n   412→class _StatusBlock:\n   413→    def __init__(self, initial: StatusUpdate) -> None:\n   414→        self.text = Text(\"\", justify=\"right\")\n   415→        self.update(initial)\n   416→\n   417→    def render(self) -> RenderableType:\n   418→        return self.text\n   419→\n   420→    def update(self, status: StatusUpdate) -> None:\n   421→        if status.context_usage is not None:\n   422→            self.text.plain = f\"context: {status.context_usage:.1%}\"\n   423→\n   424→\n   425→@asynccontextmanager\n   426→async def _keyboard_listener(\n   427→    handler: Callable[[KeyboardListener, KeyEvent], Awaitable[None]],\n   428→):\n   429→    listener = KeyboardListener()\n   430→    await listener.start()\n   431→\n   432→    async def _keyboard():\n   433→        while True:\n   434→            event = await listener.get()\n   435→            await handler(listener, event)\n   436→\n   437→    task = asyncio.create_task(_keyboard())\n   438→    try:\n   439→        yield\n   440→    finally:\n   441→        task.cancel()\n   442→        with suppress(asyncio.CancelledError):\n   443→            await task\n   444→        await listener.stop()\n   445→\n   446→\n   447→class _LiveView:\n   448→    def __init__(self, initial_status: StatusUpdate, cancel_event: asyncio.Event | None = None):\n   449→        self._cancel_event = cancel_event\n   450→\n   451→        self._mooning_spinner: Spinner | None = None\n   452→        self._compacting_spinner: Spinner | None = None\n   453→\n   454→        self._current_content_block: _ContentBlock | None = None\n   455→        self._tool_call_blocks: dict[str, _ToolCallBlock] = {}\n   456→        self._last_tool_call_block: _ToolCallBlock | None = None\n   457→        self._approval_request_queue = deque[ApprovalRequest]()\n   458→        \"\"\"\n   459→        It is possible that multiple subagents request approvals at the same time,\n   460→        in which case we will have to queue them up and show them one by one.\n   461→        \"\"\"\n   462→        self._current_approval_request_panel: _ApprovalRequestPanel | None = None\n   463→        self._reject_all_following = False\n   464→        self._status_block = _StatusBlock(initial_status)\n   465→\n   466→        self._need_recompose = False\n   467→\n   468→    def _reset_live_shape(self, live: Live) -> None:\n   469→        # Rich doesn't expose a public API to clear Live's cached render height.\n   470→        # After leaving the pager, stale height causes cursor restores to jump,\n   471→        # so we reset the private _shape to re-anchor the next refresh.\n   472→        live._live_render._shape = None  # type: ignore[reportPrivateUsage]\n   473→\n   474→    async def visualize_loop(self, wire: WireUISide):\n   475→        with Live(\n   476→            self.compose(),\n   477→            console=console,\n   478→            refresh_per_second=10,\n   479→            transient=True,\n   480→            vertical_overflow=\"visible\",\n   481→        ) as live:\n   482→\n   483→            async def keyboard_handler(listener: KeyboardListener, event: KeyEvent) -> None:\n   484→                # Handle Ctrl+E specially - pause Live while the pager is active\n   485→                if event == KeyEvent.CTRL_E:\n   486→                    if (\n   487→                        self._current_approval_request_panel\n   488→                        and self._current_approval_request_panel.has_expandable_content\n   489→                    ):\n   490→                        await listener.pause()\n   491→                        live.stop()\n   492→                        try:\n   493→                            _show_approval_in_pager(self._current_approval_request_panel)\n   494→                        finally:\n   495→                            # Reset live render shape so the next refresh re-anchors cleanly.\n   496→                            self._reset_live_shape(live)\n   497→                            live.start()\n   498→                            live.update(self.compose(), refresh=True)\n   499→                            await listener.resume()\n   500→                    return\n   501→\n   502→                self.dispatch_keyboard_event(event)\n   503→                if self._need_recompose:\n   504→                    live.update(self.compose(), refresh=True)\n   505→                    self._need_recompose = False\n   506→\n   507→            async with _keyboard_listener(keyboard_handler):\n   508→                while True:\n   509→                    try:\n   510→                        msg = await wire.receive()\n   511→                    except QueueShutDown:\n   512→                        self.cleanup(is_interrupt=False)\n   513→                        live.update(self.compose(), refresh=True)\n   514→                        break\n   515→\n   516→                    if isinstance(msg, StepInterrupted):\n   517→                        self.cleanup(is_interrupt=True)\n   518→                        live.update(self.compose(), refresh=True)\n   519→                        break\n   520→\n   521→                    self.dispatch_wire_message(msg)\n   522→                    if self._need_recompose:\n   523→                        live.update(self.compose(), refresh=True)\n   524→                        self._need_recompose = False\n   525→\n   526→    def refresh_soon(self) -> None:\n   527→        self._need_recompose = True\n   528→\n   529→    def compose(self) -> RenderableType:\n   530→        \"\"\"Compose the live view display content.\"\"\"\n   531→        blocks: list[RenderableType] = []\n   532→        if self._mooning_spinner is not None:\n   533→            blocks.append(self._mooning_spinner)\n   534→        elif self._compacting_spinner is not None:\n   535→            blocks.append(self._compacting_spinner)\n   536→        else:\n   537→            if self._current_content_block is not None:\n   538→                blocks.append(self._current_content_block.compose())\n   539→            for tool_call in self._tool_call_blocks.values():\n   540→                blocks.append(tool_call.compose())\n   541→        if self._current_approval_request_panel:\n   542→            blocks.append(self._current_approval_request_panel.render())\n   543→        blocks.append(self._status_block.render())\n   544→        return Group(*blocks)\n   545→\n   546→    def dispatch_wire_message(self, msg: WireMessage) -> None:\n   547→        \"\"\"Dispatch the Wire message to UI components.\"\"\"\n   548→        assert not isinstance(msg, StepInterrupted)  # handled in visualize_loop\n   549→\n   550→        if isinstance(msg, StepBegin):\n   551→            self.cleanup(is_interrupt=False)\n   552→            self._mooning_spinner = Spinner(\"moon\", \"\")\n   553→            self.refresh_soon()\n   554→            return\n   555→\n   556→        if self._mooning_spinner is not None:\n   557→            # any message other than StepBegin should end the mooning state\n   558→            self._mooning_spinner = None\n   559→            self.refresh_soon()\n   560→\n   561→        match msg:\n   562→            case TurnBegin():\n   563→                self.flush_content()\n   564→                console.print(\n   565→                    Panel(\n   566→                        Text(message_stringify(Message(role=\"user\", content=msg.user_input))),\n   567→                        padding=(0, 1),\n   568→                    )\n   569→                )\n   570→            case TurnEnd():\n   571→                pass\n   572→            case CompactionBegin():\n   573→                self._compacting_spinner = Spinner(\"balloon\", \"Compacting...\")\n   574→                self.refresh_soon()\n   575→            case CompactionEnd():\n   576→                self._compacting_spinner = None\n   577→                self.refresh_soon()\n   578→            case StatusUpdate():\n   579→                self._status_block.update(msg)\n   580→            case ContentPart():\n   581→                self.append_content(msg)\n   582→            case ToolCall():\n   583→                self.append_tool_call(msg)\n   584→            case ToolCallPart():\n   585→                self.append_tool_call_part(msg)\n   586→            case ToolResult():\n   587→                self.append_tool_result(msg)\n   588→            case ApprovalResponse():\n   589→                # we don't need to handle this because the request is resolved on UI\n   590→                pass\n   591→            case SubagentEvent():\n   592→                self.handle_subagent_event(msg)\n   593→            case ApprovalRequest():\n   594→                self.request_approval(msg)\n   595→            case ToolCallRequest():\n   596→                logger.warning(\"Unexpected ToolCallRequest in shell UI: {msg}\", msg=msg)\n   597→\n   598→    def dispatch_keyboard_event(self, event: KeyEvent) -> None:\n   599→        # handle ESC key to cancel the run\n   600→        if event == KeyEvent.ESCAPE and self._cancel_event is not None:\n   601→            self._cancel_event.set()\n   602→            return\n   603→\n   604→        if not self._current_approval_request_panel:\n   605→            # just ignore any keyboard event when there's no approval request\n   606→            return\n   607→\n   608→        match event:\n   609→            case KeyEvent.UP:\n   610→                self._current_approval_request_panel.move_up()\n   611→                self.refresh_soon()\n   612→            case KeyEvent.DOWN:\n   613→                self._current_approval_request_panel.move_down()\n   614→                self.refresh_soon()\n   615→            case KeyEvent.ENTER:\n   616→                resp = self._current_approval_request_panel.get_selected_response()\n   617→                self._current_approval_request_panel.request.resolve(resp)\n   618→                if resp == \"approve_for_session\":\n   619→                    to_remove_from_queue: list[ApprovalRequest] = []\n   620→                    for request in self._approval_request_queue:\n   621→                        # approve all queued requests with the same action\n   622→                        if request.action == self._current_approval_request_panel.request.action:\n   623→                            request.resolve(\"approve_for_session\")\n   624→                            to_remove_from_queue.append(request)\n   625→                    for request in to_remove_from_queue:\n   626→                        self._approval_request_queue.remove(request)\n   627→                elif resp == \"reject\":\n   628→                    # one rejection should stop the step immediately\n   629→                    while self._approval_request_queue:\n   630→                        self._approval_request_queue.popleft().resolve(\"reject\")\n   631→                    self._reject_all_following = True\n   632→                self.show_next_approval_request()\n   633→            case _:\n   634→                # just ignore any other keyboard event\n   635→                return\n   636→\n   637→    def cleanup(self, is_interrupt: bool) -> None:\n   638→        \"\"\"Cleanup the live view on step end or interruption.\"\"\"\n   639→        self.flush_content()\n   640→\n   641→        for block in self._tool_call_blocks.values():\n   642→            if not block.finished:\n   643→                # this should not happen, but just in case\n   644→                block.finish(\n   645→                    ToolError(message=\"\", brief=\"Interrupted\")\n   646→                    if is_interrupt\n   647→                    else ToolOk(output=\"\")\n   648→                )\n   649→        self._last_tool_call_block = None\n   650→        self.flush_finished_tool_calls()\n   651→\n   652→        while self._approval_request_queue:\n   653→            # should not happen, but just in case\n   654→            self._approval_request_queue.popleft().resolve(\"reject\")\n   655→        self._current_approval_request_panel = None\n   656→        self._reject_all_following = False\n   657→\n   658→    def flush_content(self) -> None:\n   659→        \"\"\"Flush the current content block.\"\"\"\n   660→        if self._current_content_block is not None:\n   661→            console.print(self._current_content_block.compose_final())\n   662→            self._current_content_block = None\n   663→            self.refresh_soon()\n   664→\n   665→    def flush_finished_tool_calls(self) -> None:\n   666→        \"\"\"Flush all leading finished tool call blocks.\"\"\"\n   667→        tool_call_ids = list(self._tool_call_blocks.keys())\n   668→        for tool_call_id in tool_call_ids:\n   669→            block = self._tool_call_blocks[tool_call_id]\n   670→            if not block.finished:\n   671→                break\n   672→\n   673→            self._tool_call_blocks.pop(tool_call_id)\n   674→            console.print(block.compose())\n   675→            if self._last_tool_call_block == block:\n   676→                self._last_tool_call_block = None\n   677→            self.refresh_soon()\n   678→\n   679→    def append_content(self, part: ContentPart) -> None:\n   680→        match part:\n   681→            case ThinkPart(think=text) | TextPart(text=text):\n   682→                if not text:\n   683→                    return\n   684→                is_think = isinstance(part, ThinkPart)\n   685→                if self._current_content_block is None:\n   686→                    self._current_content_block = _ContentBlock(is_think)\n   687→                    self.refresh_soon()\n   688→                elif self._current_content_block.is_think != is_think:\n   689→                    self.flush_content()\n   690→                    self._current_content_block = _ContentBlock(is_think)\n   691→                    self.refresh_soon()\n   692→                self._current_content_block.append(text)\n   693→            case _:\n   694→                # TODO: support more content part types\n   695→                pass\n   696→\n   697→    def append_tool_call(self, tool_call: ToolCall) -> None:\n   698→        self.flush_content()\n   699→        self._tool_call_blocks[tool_call.id] = _ToolCallBlock(tool_call)\n   700→        self._last_tool_call_block = self._tool_call_blocks[tool_call.id]\n   701→        self.refresh_soon()\n   702→\n   703→    def append_tool_call_part(self, part: ToolCallPart) -> None:\n   704→        if not part.arguments_part:\n   705→            return\n   706→        if self._last_tool_call_block is None:\n   707→            return\n   708→        self._last_tool_call_block.append_args_part(part.arguments_part)\n   709→        self.refresh_soon()\n   710→\n   711→    def append_tool_result(self, result: ToolResult) -> None:\n   712→        if block := self._tool_call_blocks.get(result.tool_call_id):\n   713→            block.finish(result.return_value)\n   714→            self.flush_finished_tool_calls()\n   715→            self.refresh_soon()\n   716→\n   717→    def request_approval(self, request: ApprovalRequest) -> None:\n   718→        # If we're rejecting all following requests, reject immediately\n   719→        if self._reject_all_following:\n   720→            request.resolve(\"reject\")\n   721→            return\n   722→\n   723→        self._approval_request_queue.append(request)\n   724→\n   725→        if self._current_approval_request_panel is None:\n   726→            console.bell()\n   727→            self.show_next_approval_request()\n   728→\n   729→    def show_next_approval_request(self) -> None:\n   730→        \"\"\"\n   731→        Show the next approval request from the queue.\n   732→        If there are no pending requests, clear the current approval panel.\n   733→        \"\"\"\n   734→        if not self._approval_request_queue:\n   735→            if self._current_approval_request_panel is not None:\n   736→                self._current_approval_request_panel = None\n   737→                self.refresh_soon()\n   738→            return\n   739→\n   740→        while self._approval_request_queue:\n   741→            request = self._approval_request_queue.popleft()\n   742→            if request.resolved:\n   743→                # skip resolved requests\n   744→                continue\n   745→            self._current_approval_request_panel = _ApprovalRequestPanel(request)\n   746→            self.refresh_soon()\n   747→            break\n   748→\n   749→    def handle_subagent_event(self, event: SubagentEvent) -> None:\n   750→        block = self._tool_call_blocks.get(event.task_tool_call_id)\n   751→        if block is None:\n   752→            return\n   753→\n   754→        match event.event:\n   755→            case ToolCall() as tool_call:\n   756→                block.append_sub_tool_call(tool_call)\n   757→            case ToolCallPart() as tool_call_part:\n   758→                block.append_sub_tool_call_part(tool_call_part)\n   759→            case ToolResult() as tool_result:\n   760→                block.finish_sub_tool_call(tool_result)\n   761→                self.refresh_soon()\n   762→            case _:\n   763→                # ignore other events for now\n   764→                # TODO: may need to handle multi-level nested subagents\n   765→                pass\n   766→"}]},"uuid":"c953fb2b-fda5-463a-b38b-1bc14f1def1e","timestamp":"2026-02-25T08:04:36.692Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/ui/shell/visualize.py","content":"from __future__ import annotations\n\nimport asyncio\nfrom collections import deque\nfrom collections.abc import Awaitable, Callable\nfrom contextlib import asynccontextmanager, suppress\nfrom typing import NamedTuple\n\nimport streamingjson  # type: ignore[reportMissingTypeStubs]\nfrom kosong.message import Message\nfrom kosong.tooling import ToolError, ToolOk\nfrom rich.console import Group, RenderableType\nfrom rich.live import Live\nfrom rich.markup import escape\nfrom rich.padding import Padding\nfrom rich.panel import Panel\nfrom rich.spinner import Spinner\nfrom rich.text import Text\n\nfrom kimi_cli.tools import extract_key_argument\nfrom kimi_cli.ui.shell.console import console\nfrom kimi_cli.ui.shell.keyboard import KeyboardListener, KeyEvent\nfrom kimi_cli.utils.aioqueue import QueueShutDown\nfrom kimi_cli.utils.diff import format_unified_diff\nfrom kimi_cli.utils.logging import logger\nfrom kimi_cli.utils.message import message_stringify\nfrom kimi_cli.utils.rich.columns import BulletColumns\nfrom kimi_cli.utils.rich.markdown import Markdown\nfrom kimi_cli.utils.rich.syntax import KimiSyntax\nfrom kimi_cli.wire import WireUISide\nfrom kimi_cli.wire.types import (\n    ApprovalRequest,\n    ApprovalResponse,\n    BriefDisplayBlock,\n    CompactionBegin,\n    CompactionEnd,\n    ContentPart,\n    DiffDisplayBlock,\n    ShellDisplayBlock,\n    StatusUpdate,\n    StepBegin,\n    StepInterrupted,\n    SubagentEvent,\n    TextPart,\n    ThinkPart,\n    TodoDisplayBlock,\n    ToolCall,\n    ToolCallPart,\n    ToolCallRequest,\n    ToolResult,\n    ToolReturnValue,\n    TurnBegin,\n    TurnEnd,\n    WireMessage,\n)\n\nMAX_SUBAGENT_TOOL_CALLS_TO_SHOW = 4\n\n# Truncation limits for approval request display\nMAX_PREVIEW_LINES = 4\n\n\nasync def visualize(\n    wire: WireUISide,\n    *,\n    initial_status: StatusUpdate,\n    cancel_event: asyncio.Event | None = None,\n):\n    \"\"\"\n    A loop to consume agent events and visualize the agent behavior.\n\n    Args:\n        wire: Communication channel with the agent\n        initial_status: Initial status snapshot\n        cancel_event: Event that can be set (e.g., by ESC key) to cancel the run\n    \"\"\"\n    view = _LiveView(initial_status, cancel_event)\n    await view.visualize_loop(wire)\n\n\nclass _ContentBlock:\n    def __init__(self, is_think: bool):\n        self.is_think = is_think\n        self._spinner = Spinner(\"dots\", \"Thinking...\" if is_think else \"Composing...\")\n        self.raw_text = \"\"\n\n    def compose(self) -> RenderableType:\n        return self._spinner\n\n    def compose_final(self) -> RenderableType:\n        return BulletColumns(\n            Markdown(\n                self.raw_text,\n                style=\"grey50 italic\" if self.is_think else \"\",\n            ),\n            bullet_style=\"grey50\" if self.is_think else None,\n        )\n\n    def append(self, content: str) -> None:\n        self.raw_text += content\n\n\nclass _ToolCallBlock:\n    class FinishedSubCall(NamedTuple):\n        call: ToolCall\n        result: ToolReturnValue\n\n    def __init__(self, tool_call: ToolCall):\n        self._tool_name = tool_call.function.name\n        self._lexer = streamingjson.Lexer()\n        if tool_call.function.arguments is not None:\n            self._lexer.append_string(tool_call.function.arguments)\n\n        self._argument = extract_key_argument(self._lexer, self._tool_name)\n        self._result: ToolReturnValue | None = None\n\n        self._ongoing_subagent_tool_calls: dict[str, ToolCall] = {}\n        self._last_subagent_tool_call: ToolCall | None = None\n        self._n_finished_subagent_tool_calls = 0\n        self._finished_subagent_tool_calls = deque[_ToolCallBlock.FinishedSubCall](\n            maxlen=MAX_SUBAGENT_TOOL_CALLS_TO_SHOW\n        )\n\n        self._spinning_dots = Spinner(\"dots\", text=\"\")\n        self._renderable: RenderableType = self._compose()\n\n    def compose(self) -> RenderableType:\n        return self._renderable\n\n    @property\n    def finished(self) -> bool:\n        return self._result is not None\n\n    def append_args_part(self, args_part: str):\n        if self.finished:\n            return\n        self._lexer.append_string(args_part)\n        # TODO: maybe don't extract detail if it's already stable\n        argument = extract_key_argument(self._lexer, self._tool_name)\n        if argument and argument != self._argument:\n            self._argument = argument\n            self._renderable = BulletColumns(\n                Text.from_markup(self._get_headline_markup()),\n                bullet=self._spinning_dots,\n            )\n\n    def finish(self, result: ToolReturnValue):\n        self._result = result\n        self._renderable = self._compose()\n\n    def append_sub_tool_call(self, tool_call: ToolCall):\n        self._ongoing_subagent_tool_calls[tool_call.id] = tool_call\n        self._last_subagent_tool_call = tool_call\n\n    def append_sub_tool_call_part(self, tool_call_part: ToolCallPart):\n        if self._last_subagent_tool_call is None:\n            return\n        if not tool_call_part.arguments_part:\n            return\n        if self._last_subagent_tool_call.function.arguments is None:\n            self._last_subagent_tool_call.function.arguments = tool_call_part.arguments_part\n        else:\n            self._last_subagent_tool_call.function.arguments += tool_call_part.arguments_part\n\n    def finish_sub_tool_call(self, tool_result: ToolResult):\n        self._last_subagent_tool_call = None\n        sub_tool_call = self._ongoing_subagent_tool_calls.pop(tool_result.tool_call_id, None)\n        if sub_tool_call is None:\n            return\n\n        self._finished_subagent_tool_calls.append(\n            _ToolCallBlock.FinishedSubCall(\n                call=sub_tool_call,\n                result=tool_result.return_value,\n            )\n        )\n        self._n_finished_subagent_tool_calls += 1\n        self._renderable = self._compose()\n\n    def _compose(self) -> RenderableType:\n        lines: list[RenderableType] = [\n            Text.from_markup(self._get_headline_markup()),\n        ]\n\n        if self._n_finished_subagent_tool_calls > MAX_SUBAGENT_TOOL_CALLS_TO_SHOW:\n            n_hidden = self._n_finished_subagent_tool_calls - MAX_SUBAGENT_TOOL_CALLS_TO_SHOW\n            lines.append(\n                BulletColumns(\n                    Text(\n                        f\"{n_hidden} more tool call{'s' if n_hidden > 1 else ''} ...\",\n                        style=\"grey50 italic\",\n                    ),\n                    bullet_style=\"grey50\",\n                )\n            )\n        for sub_call, sub_result in self._finished_subagent_tool_calls:\n            argument = extract_key_argument(\n                sub_call.function.arguments or \"\", sub_call.function.name\n            )\n            lines.append(\n                BulletColumns(\n                    Text.from_markup(\n                        f\"Used [blue]{sub_call.function.name}[/blue]\"\n                        + (f\" [grey50]({argument})[/grey50]\" if argument else \"\")\n                    ),\n                    bullet_style=\"green\" if not sub_result.is_error else \"red\",\n                )\n            )\n\n        if self._result is not None:\n            for block in self._result.display:\n                if isinstance(block, BriefDisplayBlock):\n                    style = \"grey50\" if not self._result.is_error else \"red\"\n                    if block.text:\n                        lines.append(Markdown(block.text, style=style))\n                elif isinstance(block, TodoDisplayBlock):\n                    markdown = self._render_todo_markdown(block)\n                    if markdown:\n                        lines.append(Markdown(markdown, style=\"grey50\"))\n\n        if self.finished:\n            assert self._result is not None\n            return BulletColumns(\n                Group(*lines),\n                bullet_style=\"green\" if not self._result.is_error else \"red\",\n            )\n        else:\n            return BulletColumns(\n                Group(*lines),\n                bullet=self._spinning_dots,\n            )\n\n    def _get_headline_markup(self) -> str:\n        return f\"{'Used' if self.finished else 'Using'} [blue]{self._tool_name}[/blue]\" + (\n            f\" [grey50]({escape(self._argument)})[/grey50]\" if self._argument else \"\"\n        )\n\n    def _render_todo_markdown(self, block: TodoDisplayBlock) -> str:\n        lines: list[str] = []\n        for todo in block.items:\n            normalized = todo.status.replace(\"_\", \" \").lower()\n            match normalized:\n                case \"pending\":\n                    lines.append(f\"- {todo.title}\")\n                case \"in progress\":\n                    lines.append(f\"- {todo.title} ←\")\n                case \"done\":\n                    lines.append(f\"- ~~{todo.title}~~\")\n                case _:\n                    lines.append(f\"- {todo.title}\")\n        return \"\\n\".join(lines)\n\n\nclass _ApprovalContentBlock(NamedTuple):\n    \"\"\"A pre-rendered content block for approval request with line count.\"\"\"\n\n    text: str\n    lines: int\n    style: str = \"\"\n    lexer: str = \"\"\n\n\nclass _ApprovalRequestPanel:\n    def __init__(self, request: ApprovalRequest):\n        self.request = request\n        self.options: list[tuple[str, ApprovalResponse.Kind]] = [\n            (\"Approve once\", \"approve\"),\n            (\"Approve for this session\", \"approve_for_session\"),\n            (\"Reject, tell Kimi what to do instead\", \"reject\"),\n        ]\n        self.selected_index = 0\n\n        # Pre-render all content blocks with line counts\n        self._content_blocks: list[_ApprovalContentBlock] = []\n        last_diff_path: str | None = None\n\n        # Handle description (only if no display blocks)\n        if request.description and not request.display:\n            text = request.description.rstrip(\"\\n\")\n            self._content_blocks.append(\n                _ApprovalContentBlock(text=text, lines=text.count(\"\\n\") + 1)\n            )\n\n        # Handle display blocks\n        for block in request.display:\n            if isinstance(block, DiffDisplayBlock):\n                # File path or ellipsis\n                if block.path != last_diff_path:\n                    self._content_blocks.append(\n                        _ApprovalContentBlock(text=block.path, lines=1, style=\"bold\")\n                    )\n                    last_diff_path = block.path\n                else:\n                    self._content_blocks.append(\n                        _ApprovalContentBlock(text=\"⋮\", lines=1, style=\"dim\")\n                    )\n                # Diff content\n                diff_text = format_unified_diff(\n                    block.old_text,\n                    block.new_text,\n                    block.path,\n                    include_file_header=False,\n                ).rstrip(\"\\n\")\n                self._content_blocks.append(\n                    _ApprovalContentBlock(\n                        text=diff_text, lines=diff_text.count(\"\\n\") + 1, lexer=\"diff\"\n                    )\n                )\n            elif isinstance(block, ShellDisplayBlock):\n                text = block.command.rstrip(\"\\n\")\n                self._content_blocks.append(\n                    _ApprovalContentBlock(\n                        text=text, lines=text.count(\"\\n\") + 1, lexer=block.language\n                    )\n                )\n                last_diff_path = None\n            elif isinstance(block, BriefDisplayBlock) and block.text:\n                text = block.text.rstrip(\"\\n\")\n                self._content_blocks.append(\n                    _ApprovalContentBlock(text=text, lines=text.count(\"\\n\") + 1, style=\"grey50\")\n                )\n                last_diff_path = None\n\n        self._total_lines = sum(b.lines for b in self._content_blocks)\n        self.has_expandable_content = self._total_lines > MAX_PREVIEW_LINES\n\n    def render(self) -> RenderableType:\n        \"\"\"Render the approval menu as a panel.\"\"\"\n        content_lines: list[RenderableType] = [\n            Text.from_markup(\n                \"[yellow]⚠ \"\n                f\"{escape(self.request.sender)} is requesting approval to \"\n                f\"{escape(self.request.action)}:[/yellow]\"\n            )\n        ]\n        content_lines.append(Text(\"\"))\n\n        # Render content with line budget\n        remaining = MAX_PREVIEW_LINES\n        for block in self._content_blocks:\n            if remaining <= 0:\n                break\n            content_lines.append(self._render_block(block, remaining))\n            remaining -= min(block.lines, remaining)\n\n        if self.has_expandable_content:\n            content_lines.append(Text(\"... (truncated, ctrl-e to expand)\", style=\"dim italic\"))\n\n        lines: list[RenderableType] = []\n        if content_lines:\n            lines.append(Padding(Group(*content_lines), (0, 0, 0, 2)))\n\n        # Add menu options\n        if lines:\n            lines.append(Text(\"\"))\n        for i, (option_text, _) in enumerate(self.options):\n            if i == self.selected_index:\n                lines.append(Text(f\"→ {option_text}\", style=\"cyan\"))\n            else:\n                lines.append(Text(f\"  {option_text}\", style=\"grey50\"))\n\n        return Padding(Group(*lines), 1)\n\n    def _render_block(\n        self, block: _ApprovalContentBlock, max_lines: int | None = None\n    ) -> RenderableType:\n        \"\"\"Render a content block, optionally truncated.\"\"\"\n        text = block.text\n        if max_lines is not None and block.lines > max_lines:\n            # Truncate to max_lines\n            text = \"\\n\".join(text.split(\"\\n\")[:max_lines])\n\n        if block.lexer:\n            return KimiSyntax(text, block.lexer)\n        return Text(text, style=block.style)\n\n    def render_full(self) -> list[RenderableType]:\n        \"\"\"Render full content for pager (no truncation).\"\"\"\n        return [self._render_block(block) for block in self._content_blocks]\n\n    def move_up(self):\n        \"\"\"Move selection up.\"\"\"\n        self.selected_index = (self.selected_index - 1) % len(self.options)\n\n    def move_down(self):\n        \"\"\"Move selection down.\"\"\"\n        self.selected_index = (self.selected_index + 1) % len(self.options)\n\n    def get_selected_response(self) -> ApprovalResponse.Kind:\n        \"\"\"Get the approval response based on selected option.\"\"\"\n        return self.options[self.selected_index][1]\n\n\ndef _show_approval_in_pager(panel: _ApprovalRequestPanel) -> None:\n    \"\"\"Show the full approval request content in a pager.\"\"\"\n    with console.screen(), console.pager(styles=True):\n        # Header: matches the style in _ApprovalRequestPanel.render()\n        console.print(\n            Text.from_markup(\n                \"[yellow]⚠ \"\n                f\"{escape(panel.request.sender)} is requesting approval to \"\n                f\"{escape(panel.request.action)}:[/yellow]\"\n            )\n        )\n        console.print()\n\n        # Render full content (no truncation)\n        for renderable in panel.render_full():\n            console.print(renderable)\n\n\nclass _StatusBlock:\n    def __init__(self, initial: StatusUpdate) -> None:\n        self.text = Text(\"\", justify=\"right\")\n        self.update(initial)\n\n    def render(self) -> RenderableType:\n        return self.text\n\n    def update(self, status: StatusUpdate) -> None:\n        if status.context_usage is not None:\n            self.text.plain = f\"context: {status.context_usage:.1%}\"\n\n\n@asynccontextmanager\nasync def _keyboard_listener(\n    handler: Callable[[KeyboardListener, KeyEvent], Awaitable[None]],\n):\n    listener = KeyboardListener()\n    await listener.start()\n\n    async def _keyboard():\n        while True:\n            event = await listener.get()\n            await handler(listener, event)\n\n    task = asyncio.create_task(_keyboard())\n    try:\n        yield\n    finally:\n        task.cancel()\n        with suppress(asyncio.CancelledError):\n            await task\n        await listener.stop()\n\n\nclass _LiveView:\n    def __init__(self, initial_status: StatusUpdate, cancel_event: asyncio.Event | None = None):\n        self._cancel_event = cancel_event\n\n        self._mooning_spinner: Spinner | None = None\n        self._compacting_spinner: Spinner | None = None\n\n        self._current_content_block: _ContentBlock | None = None\n        self._tool_call_blocks: dict[str, _ToolCallBlock] = {}\n        self._last_tool_call_block: _ToolCallBlock | None = None\n        self._approval_request_queue = deque[ApprovalRequest]()\n        \"\"\"\n        It is possible that multiple subagents request approvals at the same time,\n        in which case we will have to queue them up and show them one by one.\n        \"\"\"\n        self._current_approval_request_panel: _ApprovalRequestPanel | None = None\n        self._reject_all_following = False\n        self._status_block = _StatusBlock(initial_status)\n\n        self._need_recompose = False\n\n    def _reset_live_shape(self, live: Live) -> None:\n        # Rich doesn't expose a public API to clear Live's cached render height.\n        # After leaving the pager, stale height causes cursor restores to jump,\n        # so we reset the private _shape to re-anchor the next refresh.\n        live._live_render._shape = None  # type: ignore[reportPrivateUsage]\n\n    async def visualize_loop(self, wire: WireUISide):\n        with Live(\n            self.compose(),\n            console=console,\n            refresh_per_second=10,\n            transient=True,\n            vertical_overflow=\"visible\",\n        ) as live:\n\n            async def keyboard_handler(listener: KeyboardListener, event: KeyEvent) -> None:\n                # Handle Ctrl+E specially - pause Live while the pager is active\n                if event == KeyEvent.CTRL_E:\n                    if (\n                        self._current_approval_request_panel\n                        and self._current_approval_request_panel.has_expandable_content\n                    ):\n                        await listener.pause()\n                        live.stop()\n                        try:\n                            _show_approval_in_pager(self._current_approval_request_panel)\n                        finally:\n                            # Reset live render shape so the next refresh re-anchors cleanly.\n                            self._reset_live_shape(live)\n                            live.start()\n                            live.update(self.compose(), refresh=True)\n                            await listener.resume()\n                    return\n\n                self.dispatch_keyboard_event(event)\n                if self._need_recompose:\n                    live.update(self.compose(), refresh=True)\n                    self._need_recompose = False\n\n            async with _keyboard_listener(keyboard_handler):\n                while True:\n                    try:\n                        msg = await wire.receive()\n                    except QueueShutDown:\n                        self.cleanup(is_interrupt=False)\n                        live.update(self.compose(), refresh=True)\n                        break\n\n                    if isinstance(msg, StepInterrupted):\n                        self.cleanup(is_interrupt=True)\n                        live.update(self.compose(), refresh=True)\n                        break\n\n                    self.dispatch_wire_message(msg)\n                    if self._need_recompose:\n                        live.update(self.compose(), refresh=True)\n                        self._need_recompose = False\n\n    def refresh_soon(self) -> None:\n        self._need_recompose = True\n\n    def compose(self) -> RenderableType:\n        \"\"\"Compose the live view display content.\"\"\"\n        blocks: list[RenderableType] = []\n        if self._mooning_spinner is not None:\n            blocks.append(self._mooning_spinner)\n        elif self._compacting_spinner is not None:\n            blocks.append(self._compacting_spinner)\n        else:\n            if self._current_content_block is not None:\n                blocks.append(self._current_content_block.compose())\n            for tool_call in self._tool_call_blocks.values():\n                blocks.append(tool_call.compose())\n        if self._current_approval_request_panel:\n            blocks.append(self._current_approval_request_panel.render())\n        blocks.append(self._status_block.render())\n        return Group(*blocks)\n\n    def dispatch_wire_message(self, msg: WireMessage) -> None:\n        \"\"\"Dispatch the Wire message to UI components.\"\"\"\n        assert not isinstance(msg, StepInterrupted)  # handled in visualize_loop\n\n        if isinstance(msg, StepBegin):\n            self.cleanup(is_interrupt=False)\n            self._mooning_spinner = Spinner(\"moon\", \"\")\n            self.refresh_soon()\n            return\n\n        if self._mooning_spinner is not None:\n            # any message other than StepBegin should end the mooning state\n            self._mooning_spinner = None\n            self.refresh_soon()\n\n        match msg:\n            case TurnBegin():\n                self.flush_content()\n                console.print(\n                    Panel(\n                        Text(message_stringify(Message(role=\"user\", content=msg.user_input))),\n                        padding=(0, 1),\n                    )\n                )\n            case TurnEnd():\n                pass\n            case CompactionBegin():\n                self._compacting_spinner = Spinner(\"balloon\", \"Compacting...\")\n                self.refresh_soon()\n            case CompactionEnd():\n                self._compacting_spinner = None\n                self.refresh_soon()\n            case StatusUpdate():\n                self._status_block.update(msg)\n            case ContentPart():\n                self.append_content(msg)\n            case ToolCall():\n                self.append_tool_call(msg)\n            case ToolCallPart():\n                self.append_tool_call_part(msg)\n            case ToolResult():\n                self.append_tool_result(msg)\n            case ApprovalResponse():\n                # we don't need to handle this because the request is resolved on UI\n                pass\n            case SubagentEvent():\n                self.handle_subagent_event(msg)\n            case ApprovalRequest():\n                self.request_approval(msg)\n            case ToolCallRequest():\n                logger.warning(\"Unexpected ToolCallRequest in shell UI: {msg}\", msg=msg)\n\n    def dispatch_keyboard_event(self, event: KeyEvent) -> None:\n        # handle ESC key to cancel the run\n        if event == KeyEvent.ESCAPE and self._cancel_event is not None:\n            self._cancel_event.set()\n            return\n\n        if not self._current_approval_request_panel:\n            # just ignore any keyboard event when there's no approval request\n            return\n\n        match event:\n            case KeyEvent.UP:\n                self._current_approval_request_panel.move_up()\n                self.refresh_soon()\n            case KeyEvent.DOWN:\n                self._current_approval_request_panel.move_down()\n                self.refresh_soon()\n            case KeyEvent.ENTER:\n                resp = self._current_approval_request_panel.get_selected_response()\n                self._current_approval_request_panel.request.resolve(resp)\n                if resp == \"approve_for_session\":\n                    to_remove_from_queue: list[ApprovalRequest] = []\n                    for request in self._approval_request_queue:\n                        # approve all queued requests with the same action\n                        if request.action == self._current_approval_request_panel.request.action:\n                            request.resolve(\"approve_for_session\")\n                            to_remove_from_queue.append(request)\n                    for request in to_remove_from_queue:\n                        self._approval_request_queue.remove(request)\n                elif resp == \"reject\":\n                    # one rejection should stop the step immediately\n                    while self._approval_request_queue:\n                        self._approval_request_queue.popleft().resolve(\"reject\")\n                    self._reject_all_following = True\n                self.show_next_approval_request()\n            case _:\n                # just ignore any other keyboard event\n                return\n\n    def cleanup(self, is_interrupt: bool) -> None:\n        \"\"\"Cleanup the live view on step end or interruption.\"\"\"\n        self.flush_content()\n\n        for block in self._tool_call_blocks.values():\n            if not block.finished:\n                # this should not happen, but just in case\n                block.finish(\n                    ToolError(message=\"\", brief=\"Interrupted\")\n                    if is_interrupt\n                    else ToolOk(output=\"\")\n                )\n        self._last_tool_call_block = None\n        self.flush_finished_tool_calls()\n\n        while self._approval_request_queue:\n            # should not happen, but just in case\n            self._approval_request_queue.popleft().resolve(\"reject\")\n        self._current_approval_request_panel = None\n        self._reject_all_following = False\n\n    def flush_content(self) -> None:\n        \"\"\"Flush the current content block.\"\"\"\n        if self._current_content_block is not None:\n            console.print(self._current_content_block.compose_final())\n            self._current_content_block = None\n            self.refresh_soon()\n\n    def flush_finished_tool_calls(self) -> None:\n        \"\"\"Flush all leading finished tool call blocks.\"\"\"\n        tool_call_ids = list(self._tool_call_blocks.keys())\n        for tool_call_id in tool_call_ids:\n            block = self._tool_call_blocks[tool_call_id]\n            if not block.finished:\n                break\n\n            self._tool_call_blocks.pop(tool_call_id)\n            console.print(block.compose())\n            if self._last_tool_call_block == block:\n                self._last_tool_call_block = None\n            self.refresh_soon()\n\n    def append_content(self, part: ContentPart) -> None:\n        match part:\n            case ThinkPart(think=text) | TextPart(text=text):\n                if not text:\n                    return\n                is_think = isinstance(part, ThinkPart)\n                if self._current_content_block is None:\n                    self._current_content_block = _ContentBlock(is_think)\n                    self.refresh_soon()\n                elif self._current_content_block.is_think != is_think:\n                    self.flush_content()\n                    self._current_content_block = _ContentBlock(is_think)\n                    self.refresh_soon()\n                self._current_content_block.append(text)\n            case _:\n                # TODO: support more content part types\n                pass\n\n    def append_tool_call(self, tool_call: ToolCall) -> None:\n        self.flush_content()\n        self._tool_call_blocks[tool_call.id] = _ToolCallBlock(tool_call)\n        self._last_tool_call_block = self._tool_call_blocks[tool_call.id]\n        self.refresh_soon()\n\n    def append_tool_call_part(self, part: ToolCallPart) -> None:\n        if not part.arguments_part:\n            return\n        if self._last_tool_call_block is None:\n            return\n        self._last_tool_call_block.append_args_part(part.arguments_part)\n        self.refresh_soon()\n\n    def append_tool_result(self, result: ToolResult) -> None:\n        if block := self._tool_call_blocks.get(result.tool_call_id):\n            block.finish(result.return_value)\n            self.flush_finished_tool_calls()\n            self.refresh_soon()\n\n    def request_approval(self, request: ApprovalRequest) -> None:\n        # If we're rejecting all following requests, reject immediately\n        if self._reject_all_following:\n            request.resolve(\"reject\")\n            return\n\n        self._approval_request_queue.append(request)\n\n        if self._current_approval_request_panel is None:\n            console.bell()\n            self.show_next_approval_request()\n\n    def show_next_approval_request(self) -> None:\n        \"\"\"\n        Show the next approval request from the queue.\n        If there are no pending requests, clear the current approval panel.\n        \"\"\"\n        if not self._approval_request_queue:\n            if self._current_approval_request_panel is not None:\n                self._current_approval_request_panel = None\n                self.refresh_soon()\n            return\n\n        while self._approval_request_queue:\n            request = self._approval_request_queue.popleft()\n            if request.resolved:\n                # skip resolved requests\n                continue\n            self._current_approval_request_panel = _ApprovalRequestPanel(request)\n            self.refresh_soon()\n            break\n\n    def handle_subagent_event(self, event: SubagentEvent) -> None:\n        block = self._tool_call_blocks.get(event.task_tool_call_id)\n        if block is None:\n            return\n\n        match event.event:\n            case ToolCall() as tool_call:\n                block.append_sub_tool_call(tool_call)\n            case ToolCallPart() as tool_call_part:\n                block.append_sub_tool_call_part(tool_call_part)\n            case ToolResult() as tool_result:\n                block.finish_sub_tool_call(tool_result)\n                self.refresh_soon()\n            case _:\n                # ignore other events for now\n                # TODO: may need to handle multi-level nested subagents\n                pass\n","numLines":766,"startLine":1,"totalLines":766}},"sourceToolAssistantUUID":"186c5caf-00b0-4e7b-818d-87d0bac5c366"}
{"parentUuid":"c953fb2b-fda5-463a-b38b-1bc14f1def1e","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_013TabETYh9rSpbJjJUZoNjy","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Now I have a clear picture of the file. Let me also check what `extract_key_argument` does to understand the truncation behavior.","signature":"EqoCCkYICxgCKkAvolONJzGrPMxwoavDMtY0vFTZYYvFO+eF27vQq9Kd73w4/hDao+vDY+nnVHNhO/xSbzpWldpq2S7DdgT6cUptEgzevfoRvSiOmKIMGrgaDDrmLKPdFzlKhn72NyIwrI1oqDX5YpDGPyoOatKYXEwffEJ9HiFISBEdnBKojO5CJsptxWJn4pMCBXUdZ7YyKpEBgQ61frDLm0DXJsCQmSqee8f8ofc8iuVHDGLexrs0BW77a+UR1cdDX+Tj/AXRhM+1EkfWAB6ftI+vmgjezXKEJOr+3RWj4hjb274XqJ4Yy45XmAF6aoa086lD2ETnckXXU09PZ43CWr820yWmHuzQuJrKGQiuNH0dj5gyBSE9AReUqXSr1BBuNunAzrqufIwnCBgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":10440,"cache_read_input_tokens":21471,"cache_creation":{"ephemeral_5m_input_tokens":10440,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"type":"assistant","uuid":"7f9e2ef4-4751-44d2-b05f-7cd463268d75","timestamp":"2026-02-25T08:04:39.777Z"}
{"parentUuid":"7f9e2ef4-4751-44d2-b05f-7cd463268d75","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_013TabETYh9rSpbJjJUZoNjy","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me check the `extract_key_argument` function to understand the truncation behavior."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":10440,"cache_read_input_tokens":21471,"cache_creation":{"ephemeral_5m_input_tokens":10440,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"type":"assistant","uuid":"1de3e018-7158-4bf3-bb6b-72e306b3e5fe","timestamp":"2026-02-25T08:04:40.349Z"}
{"parentUuid":"1de3e018-7158-4bf3-bb6b-72e306b3e5fe","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_013TabETYh9rSpbJjJUZoNjy","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0155qNv8MkDA2noxUYuKHERz","name":"Task","input":{"description":"Find extract_key_argument impl","subagent_type":"Explore","prompt":"Find the implementation of `extract_key_argument` in the kimi-cli codebase. I need to see the function body, particularly how it handles FetchURL tool and any truncation logic. Search in src/kimi_cli/tools/. Quick search.","model":"haiku"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":10440,"cache_read_input_tokens":21471,"cache_creation":{"ephemeral_5m_input_tokens":10440,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"type":"assistant","uuid":"0dc1d7dd-f2f4-4c81-932a-334d5e50675d","timestamp":"2026-02-25T08:04:42.991Z"}
{"parentUuid":"0dc1d7dd-f2f4-4c81-932a-334d5e50675d","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Task","command":"entire hooks claude-code pre-task"},"toolUseID":"toolu_0155qNv8MkDA2noxUYuKHERz","parentToolUseID":"toolu_0155qNv8MkDA2noxUYuKHERz","uuid":"32b0da14-4ad9-40e6-a291-acc482ec38ff","timestamp":"2026-02-25T08:04:42.995Z"}
{"parentUuid":"32b0da14-4ad9-40e6-a291-acc482ec38ff","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"type":"text","text":"Find the implementation of `extract_key_argument` in the kimi-cli codebase. I need to see the function body, particularly how it handles FetchURL tool and any truncation logic. Search in src/kimi_cli/tools/. Quick search."}]},"uuid":"5aa5a2c2-7828-4e26-8ea1-162be74b33c8","timestamp":"2026-02-25T08:04:44.964Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Find the implementation of `extract_key_argument` in the kimi-cli codebase. I need to see the function body, particularly how it handles FetchURL tool and any truncation logic. Search in src/kimi_cli/tools/. Quick search.","agentId":"a3145cdba40b06901"},"toolUseID":"agent_msg_013TabETYh9rSpbJjJUZoNjy","parentToolUseID":"toolu_0155qNv8MkDA2noxUYuKHERz","uuid":"81a689bc-f9a1-41b9-9b85-0bb319d77bda","timestamp":"2026-02-25T08:04:44.964Z"}
{"parentUuid":"81a689bc-f9a1-41b9-9b85-0bb319d77bda","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-25T08:04:46.874Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_014FwxNm1ee34KyhfvzDZmfw","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WP2TfH8ypgGTuEYij4MruA","name":"Grep","input":{"pattern":"extract_key_argument","path":"/Users/moonshot/dev/working/kimi/kimi-cli"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":11464,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":11464,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"uuid":"7052595b-ca79-4518-9e6f-f752068a09df"},"normalizedMessages":[],"type":"agent_progress","prompt":"Find the implementation of `extract_key_argument` in the kimi-cli codebase. I need to see the function body, particularly how it handles FetchURL tool and any truncation logic. Search in src/kimi_cli/tools/. Quick search.","agentId":"a3145cdba40b06901"},"toolUseID":"agent_msg_013TabETYh9rSpbJjJUZoNjy","parentToolUseID":"toolu_0155qNv8MkDA2noxUYuKHERz","uuid":"f5dd4327-3510-44a3-a56a-5546fa4528d9","timestamp":"2026-02-25T08:04:46.874Z"}
{"parentUuid":"f5dd4327-3510-44a3-a56a-5546fa4528d9","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WP2TfH8ypgGTuEYij4MruA","type":"tool_result","content":"Found 3 files\nsrc/kimi_cli/ui/shell/visualize.py\nsrc/kimi_cli/tools/__init__.py\nsrc/kimi_cli/acp/session.py"}]},"uuid":"d255ef4d-35b4-4fea-bc01-d4381de84abf","timestamp":"2026-02-25T08:04:47.550Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Find the implementation of `extract_key_argument` in the kimi-cli codebase. I need to see the function body, particularly how it handles FetchURL tool and any truncation logic. Search in src/kimi_cli/tools/. Quick search.","agentId":"a3145cdba40b06901"},"toolUseID":"agent_msg_013TabETYh9rSpbJjJUZoNjy","parentToolUseID":"toolu_0155qNv8MkDA2noxUYuKHERz","uuid":"2c69a729-2da3-48d0-8418-aa26da31f68b","timestamp":"2026-02-25T08:04:47.553Z"}
{"parentUuid":"2c69a729-2da3-48d0-8418-aa26da31f68b","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-25T08:04:49.077Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01ABLMPJaBkKPJMgFdfPaYUX","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017zR6FxAQ9czZgG2AeeVg6F","name":"Read","input":{"file_path":"/Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/tools/__init__.py"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":206,"cache_read_input_tokens":11464,"cache_creation":{"ephemeral_5m_input_tokens":206,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"uuid":"2d8e5784-8a7a-4d9b-86f6-3feeef31e64d"},"normalizedMessages":[],"type":"agent_progress","prompt":"Find the implementation of `extract_key_argument` in the kimi-cli codebase. I need to see the function body, particularly how it handles FetchURL tool and any truncation logic. Search in src/kimi_cli/tools/. Quick search.","agentId":"a3145cdba40b06901"},"toolUseID":"agent_msg_013TabETYh9rSpbJjJUZoNjy","parentToolUseID":"toolu_0155qNv8MkDA2noxUYuKHERz","uuid":"77a8f53e-13d4-4776-957d-6ff553551047","timestamp":"2026-02-25T08:04:49.078Z"}
{"parentUuid":"77a8f53e-13d4-4776-957d-6ff553551047","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017zR6FxAQ9czZgG2AeeVg6F","type":"tool_result","content":"     1→import json\n     2→from typing import cast\n     3→\n     4→import streamingjson  # type: ignore[reportMissingTypeStubs]\n     5→from kaos.path import KaosPath\n     6→from kosong.utils.typing import JsonType\n     7→\n     8→from kimi_cli.utils.string import shorten_middle\n     9→\n    10→\n    11→class SkipThisTool(Exception):\n    12→    \"\"\"Raised when a tool decides to skip itself from the loading process.\"\"\"\n    13→\n    14→    pass\n    15→\n    16→\n    17→def extract_key_argument(json_content: str | streamingjson.Lexer, tool_name: str) -> str | None:\n    18→    if isinstance(json_content, streamingjson.Lexer):\n    19→        json_str = json_content.complete_json()\n    20→    else:\n    21→        json_str = json_content\n    22→    try:\n    23→        curr_args: JsonType = json.loads(json_str)\n    24→    except json.JSONDecodeError:\n    25→        return None\n    26→    if not curr_args:\n    27→        return None\n    28→    key_argument: str = \"\"\n    29→    match tool_name:\n    30→        case \"Task\":\n    31→            if not isinstance(curr_args, dict) or not curr_args.get(\"description\"):\n    32→                return None\n    33→            key_argument = str(curr_args[\"description\"])\n    34→        case \"CreateSubagent\":\n    35→            if not isinstance(curr_args, dict) or not curr_args.get(\"name\"):\n    36→                return None\n    37→            key_argument = str(curr_args[\"name\"])\n    38→        case \"SendDMail\":\n    39→            return None\n    40→        case \"Think\":\n    41→            if not isinstance(curr_args, dict) or not curr_args.get(\"thought\"):\n    42→                return None\n    43→            key_argument = str(curr_args[\"thought\"])\n    44→        case \"SetTodoList\":\n    45→            return None\n    46→        case \"Shell\":\n    47→            if not isinstance(curr_args, dict) or not curr_args.get(\"command\"):\n    48→                return None\n    49→            key_argument = str(curr_args[\"command\"])\n    50→        case \"ReadFile\":\n    51→            if not isinstance(curr_args, dict) or not curr_args.get(\"path\"):\n    52→                return None\n    53→            key_argument = _normalize_path(str(curr_args[\"path\"]))\n    54→        case \"ReadMediaFile\":\n    55→            if not isinstance(curr_args, dict) or not curr_args.get(\"path\"):\n    56→                return None\n    57→            key_argument = _normalize_path(str(curr_args[\"path\"]))\n    58→        case \"Glob\":\n    59→            if not isinstance(curr_args, dict) or not curr_args.get(\"pattern\"):\n    60→                return None\n    61→            key_argument = str(curr_args[\"pattern\"])\n    62→        case \"Grep\":\n    63→            if not isinstance(curr_args, dict) or not curr_args.get(\"pattern\"):\n    64→                return None\n    65→            key_argument = str(curr_args[\"pattern\"])\n    66→        case \"WriteFile\":\n    67→            if not isinstance(curr_args, dict) or not curr_args.get(\"path\"):\n    68→                return None\n    69→            key_argument = _normalize_path(str(curr_args[\"path\"]))\n    70→        case \"StrReplaceFile\":\n    71→            if not isinstance(curr_args, dict) or not curr_args.get(\"path\"):\n    72→                return None\n    73→            key_argument = _normalize_path(str(curr_args[\"path\"]))\n    74→        case \"SearchWeb\":\n    75→            if not isinstance(curr_args, dict) or not curr_args.get(\"query\"):\n    76→                return None\n    77→            key_argument = str(curr_args[\"query\"])\n    78→        case \"FetchURL\":\n    79→            if not isinstance(curr_args, dict) or not curr_args.get(\"url\"):\n    80→                return None\n    81→            key_argument = str(curr_args[\"url\"])\n    82→        case _:\n    83→            if isinstance(json_content, streamingjson.Lexer):\n    84→                # lexer.json_content is list[str] based on streamingjson source code\n    85→                content: list[str] = cast(list[str], json_content.json_content)  # type: ignore[reportUnknownMemberType]\n    86→                key_argument = \"\".join(content)\n    87→            else:\n    88→                key_argument = json_content\n    89→    key_argument = shorten_middle(key_argument, width=50)\n    90→    return key_argument\n    91→\n    92→\n    93→def _normalize_path(path: str) -> str:\n    94→    cwd = str(KaosPath.cwd().canonical())\n    95→    if path.startswith(cwd):\n    96→        path = path[len(cwd) :].lstrip(\"/\\\\\")\n    97→    return path\n    98→"}]},"uuid":"709ef4d6-1aba-4f71-90b3-e26795d37fba","timestamp":"2026-02-25T08:04:49.093Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Find the implementation of `extract_key_argument` in the kimi-cli codebase. I need to see the function body, particularly how it handles FetchURL tool and any truncation logic. Search in src/kimi_cli/tools/. Quick search.","agentId":"a3145cdba40b06901"},"toolUseID":"agent_msg_013TabETYh9rSpbJjJUZoNjy","parentToolUseID":"toolu_0155qNv8MkDA2noxUYuKHERz","uuid":"e1cbe32d-39fa-4df2-a77c-0891115c0276","timestamp":"2026-02-25T08:04:49.094Z"}
{"parentUuid":"e1cbe32d-39fa-4df2-a77c-0891115c0276","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Task","command":"entire hooks claude-code post-task"},"parentToolUseID":"toolu_0155qNv8MkDA2noxUYuKHERz","toolUseID":"toolu_0155qNv8MkDA2noxUYuKHERz","timestamp":"2026-02-25T08:04:53.702Z","uuid":"b8eac489-bfcb-4e53-937f-fd833d994590"}
{"parentUuid":"0dc1d7dd-f2f4-4c81-932a-334d5e50675d","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0155qNv8MkDA2noxUYuKHERz","type":"tool_result","content":[{"type":"text","text":"Perfect! I found the implementation. Here's what I found:\n\n## `extract_key_argument` Function\n\n**File:** `/Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/tools/__init__.py`\n\n### Function Body (lines 17-90):\n\nThe function extracts a key argument from a tool's JSON arguments based on the tool name. Here's how it handles **FetchURL** specifically:\n\n```python\ncase \"FetchURL\":\n    if not isinstance(curr_args, dict) or not curr_args.get(\"url\"):\n        return None\n    key_argument = str(curr_args[\"url\"])\n```\n\n**Key Details:**\n\n1. **FetchURL handling (lines 78-81):** \n   - Validates that arguments are a dictionary with a \"url\" key\n   - Returns `None` if either check fails\n   - Extracts the URL as the key argument\n\n2. **Truncation Logic (line 89):**\n   - After extracting the key argument, ALL tool key arguments are passed through `shorten_middle(key_argument, width=50)`\n   - This means FetchURL URLs are truncated to 50 characters max with \"...\" in the middle if needed\n\n3. **General Pattern:**\n   - For each tool type, the function identifies which argument is \"key\" (Task → description, Grep → pattern, FetchURL → url, etc.)\n   - Returns `None` for tools without appropriate arguments (e.g., SendDMail, SetTodoList always return None)\n   - Falls back to the raw JSON content for unknown tool types\n\nThe truncation via `shorten_middle()` is applied uniformly to all extracted key arguments at line 89."},{"type":"text","text":"agentId: a3145cdba40b06901 (for resuming to continue this agent's work if needed)\n<usage>total_tokens: 13572\ntool_uses: 2\nduration_ms: 8733</usage>"}]}]},"uuid":"2b289a84-4f84-4724-b7ef-253ad7d8fe6f","timestamp":"2026-02-25T08:04:53.701Z","toolUseResult":{"status":"completed","prompt":"Find the implementation of `extract_key_argument` in the kimi-cli codebase. I need to see the function body, particularly how it handles FetchURL tool and any truncation logic. Search in src/kimi_cli/tools/. Quick search.","agentId":"a3145cdba40b06901","content":[{"type":"text","text":"Perfect! I found the implementation. Here's what I found:\n\n## `extract_key_argument` Function\n\n**File:** `/Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/tools/__init__.py`\n\n### Function Body (lines 17-90):\n\nThe function extracts a key argument from a tool's JSON arguments based on the tool name. Here's how it handles **FetchURL** specifically:\n\n```python\ncase \"FetchURL\":\n    if not isinstance(curr_args, dict) or not curr_args.get(\"url\"):\n        return None\n    key_argument = str(curr_args[\"url\"])\n```\n\n**Key Details:**\n\n1. **FetchURL handling (lines 78-81):** \n   - Validates that arguments are a dictionary with a \"url\" key\n   - Returns `None` if either check fails\n   - Extracts the URL as the key argument\n\n2. **Truncation Logic (line 89):**\n   - After extracting the key argument, ALL tool key arguments are passed through `shorten_middle(key_argument, width=50)`\n   - This means FetchURL URLs are truncated to 50 characters max with \"...\" in the middle if needed\n\n3. **General Pattern:**\n   - For each tool type, the function identifies which argument is \"key\" (Task → description, Grep → pattern, FetchURL → url, etc.)\n   - Returns `None` for tools without appropriate arguments (e.g., SendDMail, SetTodoList always return None)\n   - Falls back to the raw JSON content for unknown tool types\n\nThe truncation via `shorten_middle()` is applied uniformly to all extracted key arguments at line 89."}],"totalDurationMs":8733,"totalTokens":13572,"totalToolUseCount":2,"usage":{"input_tokens":4,"cache_creation_input_tokens":1498,"cache_read_input_tokens":11670,"output_tokens":400,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":1498},"inference_geo":"","iterations":[],"speed":"standard"}},"sourceToolAssistantUUID":"0dc1d7dd-f2f4-4c81-932a-334d5e50675d"}
{"parentUuid":"2b289a84-4f84-4724-b7ef-253ad7d8fe6f","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_017pPm7cTUNgdazNyg1jWYtL","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Now I have all the context I need. Let me implement the changes:\n\n1. Add `import json` and `from rich.style import Style` imports\n2. Add `_extract_full_url` static method to `_ToolCallBlock`\n3. Add `self._full_url` to `__init__`\n4. Update `append_args_part` to sync `_full_url`\n5. Replace `_get_headline_markup` with `_build_headline_text` returning `Text`\n6. Update `_compose` to use `_build_headline_text` and add full URL hint line\n\n\n7. Now I need to apply the same changes to the subagent tool call display to keep them consistent.","signature":"Eq0FCkYICxgCKkB4YtMIDIXEk/PqxobDi/bZ2rK9RXskhDBm8IlqwkoWnWDnEbeSytHCnA2kCG9TerrNy2mo/PQF9NGNI4VnDSXcEgxCXsdSeKZXQR7eRbgaDAyy+FpvgQGIlawAPSIwC2Nt4CHbqOI3awysa6cShuZ6PDU7cCoWwU//hZp1hz1Zx4GomrRrCl5Bc0REfAxzKpQEsEtfTRo77A7PSkPiMXOn5DZbpTLM9shN7lXE+v47o/GXH8ATYAZRQv/ywE4xsJUK7ZC6nGwBHQ5Aw1gzu6l4iDbqSzknCIGKWhe8+oiFQFWp+9kfQDOYVDLg55Q5a4Pojeddkn/g+eshuEqwCgrAsNqPYOPF4jyMDcsxT22N9QS24S9F1N/Ccp7Ao2vCryKlaS8EmaNS+RK8CR/0ZQVyX6swxBrxAxxouDJBoq7ZzZ+WlAEl0V3/HH9Wep/4Rp7Cwg28tuGeLgrHecoDcGEbXf27mrqQFlRPh+Kv81ijciIwrLN6WR8I7eesSUQy32MNPdTEXSsfFgSebyiycwUY2DMkJcc3XJWyY9vAwt8+2i1GOzcKkeqaczY7BJlor6YcTwzufxScbrhnAmEdP7p9CeEG00dQ+GJ203GFnGDA3HtJsStHayvgz3sv78UE2SH6qOtIfFzAoVKcYBVRLnnyfSJsRzGGb16XmBp5ziT6f6+JfuIly9bmPZLS3ezq+UOS0tgGL3bgocJdaEglfCYpf6cvVtbGaDa+Gbc7GmhPYbTpCMgSWLnWjiGFmFxM9q8gUHnJRDp9p+NMcW3J0fPE0tKLLTWKlfpzooFADoYgCNT8YZIE7H511zSzVsk8ZAaijNfuIGLmt2rpA3pq6V7LXNqrfZ1ORxR3AO2vOOfIFK6RMw5WtKhdADgrp/97YB17pafX4BgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":700,"cache_read_input_tokens":31911,"cache_creation":{"ephemeral_5m_input_tokens":700,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"type":"assistant","uuid":"9cb1e6f9-d456-43fc-9550-b726ec13fec6","timestamp":"2026-02-25T08:05:01.696Z"}
{"parentUuid":"9cb1e6f9-d456-43fc-9550-b726ec13fec6","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_017pPm7cTUNgdazNyg1jWYtL","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have everything I need. Let me implement the changes."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":700,"cache_read_input_tokens":31911,"cache_creation":{"ephemeral_5m_input_tokens":700,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"type":"assistant","uuid":"dc42717b-f98b-46d2-bea0-f11172b4c107","timestamp":"2026-02-25T08:05:01.697Z"}
{"parentUuid":"dc42717b-f98b-46d2-bea0-f11172b4c107","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_017pPm7cTUNgdazNyg1jWYtL","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01ACVkrWZ4PiDPUHvtVLXcA9","name":"TaskCreate","input":{"subject":"Implement FetchURL Ctrl+Click and full URL hint in CLI","description":"Modify _ToolCallBlock in visualize.py to:\n1. Add import json and Style\n2. Add _extract_full_url static method\n3. Track self._full_url in __init__ and append_args_part\n4. Replace _get_headline_markup with _build_headline_text returning Text with OSC 8 link\n5. Add full URL hint line when URL is truncated\n6. Handle subagent FetchURL calls similarly","activeForm":"Implementing FetchURL link support"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":700,"cache_read_input_tokens":31911,"output_tokens":399,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":700},"inference_geo":"","iterations":[],"speed":"standard"}},"type":"assistant","uuid":"156eeac9-9c82-4d06-93ee-d97fd1dff2c6","timestamp":"2026-02-25T08:05:04.340Z"}
{"parentUuid":"156eeac9-9c82-4d06-93ee-d97fd1dff2c6","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01ACVkrWZ4PiDPUHvtVLXcA9","type":"tool_result","content":"Task #1 created successfully: Implement FetchURL Ctrl+Click and full URL hint in CLI"}]},"uuid":"421c075a-afb2-4373-9674-21c0f11e5f8a","timestamp":"2026-02-25T08:05:04.355Z","toolUseResult":{"task":{"id":"1","subject":"Implement FetchURL Ctrl+Click and full URL hint in CLI"}},"sourceToolAssistantUUID":"156eeac9-9c82-4d06-93ee-d97fd1dff2c6"}
{"parentUuid":"421c075a-afb2-4373-9674-21c0f11e5f8a","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_01EAe1PNumE5h4jVuiRHKVEQ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LLTv9Y616H8D7sWtR1QjtT","name":"TaskUpdate","input":{"taskId":"1","status":"in_progress"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":430,"cache_read_input_tokens":32611,"cache_creation":{"ephemeral_5m_input_tokens":430,"ephemeral_1h_input_tokens":0},"output_tokens":26,"service_tier":"standard","inference_geo":"global"}},"type":"assistant","uuid":"93871229-4c58-44b2-be45-4481cb8accbe","timestamp":"2026-02-25T08:05:07.526Z"}
{"parentUuid":"93871229-4c58-44b2-be45-4481cb8accbe","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LLTv9Y616H8D7sWtR1QjtT","type":"tool_result","content":"Updated task #1 status"}]},"uuid":"fa7b0c9b-262f-48f1-b04b-ebc399a110e7","timestamp":"2026-02-25T08:05:07.533Z","toolUseResult":{"success":true,"taskId":"1","updatedFields":["status"],"statusChange":{"from":"pending","to":"in_progress"}},"sourceToolAssistantUUID":"93871229-4c58-44b2-be45-4481cb8accbe"}
{"parentUuid":"fa7b0c9b-262f-48f1-b04b-ebc399a110e7","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_019uUCTtWiw84C3KoEGzjwbo","type":"message","role":"assistant","content":[{"type":"text","text":"**Step 1: Add imports** — `json` and `Style`"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":90,"cache_read_input_tokens":33041,"cache_creation":{"ephemeral_5m_input_tokens":90,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"type":"assistant","uuid":"3ec80a77-e0b5-47a3-a432-18ae832c4de6","timestamp":"2026-02-25T08:05:10.473Z"}
{"parentUuid":"3ec80a77-e0b5-47a3-a432-18ae832c4de6","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_019uUCTtWiw84C3KoEGzjwbo","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BkqE1sY187JvCN3CsFaqfQ","name":"Edit","input":{"replace_all":false,"file_path":"/Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/ui/shell/visualize.py","old_string":"from __future__ import annotations\n\nimport asyncio\nfrom collections import deque\nfrom collections.abc import Awaitable, Callable\nfrom contextlib import asynccontextmanager, suppress\nfrom typing import NamedTuple\n\nimport streamingjson  # type: ignore[reportMissingTypeStubs]","new_string":"from __future__ import annotations\n\nimport asyncio\nimport json\nfrom collections import deque\nfrom collections.abc import Awaitable, Callable\nfrom contextlib import asynccontextmanager, suppress\nfrom typing import NamedTuple\n\nimport streamingjson  # type: ignore[reportMissingTypeStubs]"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":90,"cache_read_input_tokens":33041,"output_tokens":279,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":90},"inference_geo":"","iterations":[],"speed":"standard"}},"type":"assistant","uuid":"a7e99a1e-ab5f-4ae7-92e9-f82a2ba9ecac","timestamp":"2026-02-25T08:05:13.241Z"}
{"type":"file-history-snapshot","messageId":"a7e99a1e-ab5f-4ae7-92e9-f82a2ba9ecac","snapshot":{"messageId":"bb248cc5-0bf4-43a6-8944-26dee2cd25bf","trackedFileBackups":{"src/kimi_cli/ui/shell/visualize.py":{"backupFileName":"3f980b47889cf5ea@v1","version":1,"backupTime":"2026-02-25T08:05:13.268Z"}},"timestamp":"2026-02-25T08:04:32.535Z"},"isSnapshotUpdate":true}
{"parentUuid":"a7e99a1e-ab5f-4ae7-92e9-f82a2ba9ecac","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01BkqE1sY187JvCN3CsFaqfQ","toolUseID":"toolu_01BkqE1sY187JvCN3CsFaqfQ","timestamp":"2026-02-25T08:05:13.293Z","uuid":"c5b243a9-0f84-48cc-bf43-ecc461737e22"}
{"parentUuid":"a7e99a1e-ab5f-4ae7-92e9-f82a2ba9ecac","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BkqE1sY187JvCN3CsFaqfQ","type":"tool_result","content":"The file /Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/ui/shell/visualize.py has been updated successfully."}]},"uuid":"8f8afb11-8c05-465d-aaa7-f0ec163a649d","timestamp":"2026-02-25T08:05:13.291Z","toolUseResult":{"filePath":"/Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/ui/shell/visualize.py","oldString":"from __future__ import annotations\n\nimport asyncio\nfrom collections import deque\nfrom collections.abc import Awaitable, Callable\nfrom contextlib import asynccontextmanager, suppress\nfrom typing import NamedTuple\n\nimport streamingjson  # type: ignore[reportMissingTypeStubs]","newString":"from __future__ import annotations\n\nimport asyncio\nimport json\nfrom collections import deque\nfrom collections.abc import Awaitable, Callable\nfrom contextlib import asynccontextmanager, suppress\nfrom typing import NamedTuple\n\nimport streamingjson  # type: ignore[reportMissingTypeStubs]","originalFile":"from __future__ import annotations\n\nimport asyncio\nfrom collections import deque\nfrom collections.abc import Awaitable, Callable\nfrom contextlib import asynccontextmanager, suppress\nfrom typing import NamedTuple\n\nimport streamingjson  # type: ignore[reportMissingTypeStubs]\nfrom kosong.message import Message\nfrom kosong.tooling import ToolError, ToolOk\nfrom rich.console import Group, RenderableType\nfrom rich.live import Live\nfrom rich.markup import escape\nfrom rich.padding import Padding\nfrom rich.panel import Panel\nfrom rich.spinner import Spinner\nfrom rich.text import Text\n\nfrom kimi_cli.tools import extract_key_argument\nfrom kimi_cli.ui.shell.console import console\nfrom kimi_cli.ui.shell.keyboard import KeyboardListener, KeyEvent\nfrom kimi_cli.utils.aioqueue import QueueShutDown\nfrom kimi_cli.utils.diff import format_unified_diff\nfrom kimi_cli.utils.logging import logger\nfrom kimi_cli.utils.message import message_stringify\nfrom kimi_cli.utils.rich.columns import BulletColumns\nfrom kimi_cli.utils.rich.markdown import Markdown\nfrom kimi_cli.utils.rich.syntax import KimiSyntax\nfrom kimi_cli.wire import WireUISide\nfrom kimi_cli.wire.types import (\n    ApprovalRequest,\n    ApprovalResponse,\n    BriefDisplayBlock,\n    CompactionBegin,\n    CompactionEnd,\n    ContentPart,\n    DiffDisplayBlock,\n    ShellDisplayBlock,\n    StatusUpdate,\n    StepBegin,\n    StepInterrupted,\n    SubagentEvent,\n    TextPart,\n    ThinkPart,\n    TodoDisplayBlock,\n    ToolCall,\n    ToolCallPart,\n    ToolCallRequest,\n    ToolResult,\n    ToolReturnValue,\n    TurnBegin,\n    TurnEnd,\n    WireMessage,\n)\n\nMAX_SUBAGENT_TOOL_CALLS_TO_SHOW = 4\n\n# Truncation limits for approval request display\nMAX_PREVIEW_LINES = 4\n\n\nasync def visualize(\n    wire: WireUISide,\n    *,\n    initial_status: StatusUpdate,\n    cancel_event: asyncio.Event | None = None,\n):\n    \"\"\"\n    A loop to consume agent events and visualize the agent behavior.\n\n    Args:\n        wire: Communication channel with the agent\n        initial_status: Initial status snapshot\n        cancel_event: Event that can be set (e.g., by ESC key) to cancel the run\n    \"\"\"\n    view = _LiveView(initial_status, cancel_event)\n    await view.visualize_loop(wire)\n\n\nclass _ContentBlock:\n    def __init__(self, is_think: bool):\n        self.is_think = is_think\n        self._spinner = Spinner(\"dots\", \"Thinking...\" if is_think else \"Composing...\")\n        self.raw_text = \"\"\n\n    def compose(self) -> RenderableType:\n        return self._spinner\n\n    def compose_final(self) -> RenderableType:\n        return BulletColumns(\n            Markdown(\n                self.raw_text,\n                style=\"grey50 italic\" if self.is_think else \"\",\n            ),\n            bullet_style=\"grey50\" if self.is_think else None,\n        )\n\n    def append(self, content: str) -> None:\n        self.raw_text += content\n\n\nclass _ToolCallBlock:\n    class FinishedSubCall(NamedTuple):\n        call: ToolCall\n        result: ToolReturnValue\n\n    def __init__(self, tool_call: ToolCall):\n        self._tool_name = tool_call.function.name\n        self._lexer = streamingjson.Lexer()\n        if tool_call.function.arguments is not None:\n            self._lexer.append_string(tool_call.function.arguments)\n\n        self._argument = extract_key_argument(self._lexer, self._tool_name)\n        self._result: ToolReturnValue | None = None\n\n        self._ongoing_subagent_tool_calls: dict[str, ToolCall] = {}\n        self._last_subagent_tool_call: ToolCall | None = None\n        self._n_finished_subagent_tool_calls = 0\n        self._finished_subagent_tool_calls = deque[_ToolCallBlock.FinishedSubCall](\n            maxlen=MAX_SUBAGENT_TOOL_CALLS_TO_SHOW\n        )\n\n        self._spinning_dots = Spinner(\"dots\", text=\"\")\n        self._renderable: RenderableType = self._compose()\n\n    def compose(self) -> RenderableType:\n        return self._renderable\n\n    @property\n    def finished(self) -> bool:\n        return self._result is not None\n\n    def append_args_part(self, args_part: str):\n        if self.finished:\n            return\n        self._lexer.append_string(args_part)\n        # TODO: maybe don't extract detail if it's already stable\n        argument = extract_key_argument(self._lexer, self._tool_name)\n        if argument and argument != self._argument:\n            self._argument = argument\n            self._renderable = BulletColumns(\n                Text.from_markup(self._get_headline_markup()),\n                bullet=self._spinning_dots,\n            )\n\n    def finish(self, result: ToolReturnValue):\n        self._result = result\n        self._renderable = self._compose()\n\n    def append_sub_tool_call(self, tool_call: ToolCall):\n        self._ongoing_subagent_tool_calls[tool_call.id] = tool_call\n        self._last_subagent_tool_call = tool_call\n\n    def append_sub_tool_call_part(self, tool_call_part: ToolCallPart):\n        if self._last_subagent_tool_call is None:\n            return\n        if not tool_call_part.arguments_part:\n            return\n        if self._last_subagent_tool_call.function.arguments is None:\n            self._last_subagent_tool_call.function.arguments = tool_call_part.arguments_part\n        else:\n            self._last_subagent_tool_call.function.arguments += tool_call_part.arguments_part\n\n    def finish_sub_tool_call(self, tool_result: ToolResult):\n        self._last_subagent_tool_call = None\n        sub_tool_call = self._ongoing_subagent_tool_calls.pop(tool_result.tool_call_id, None)\n        if sub_tool_call is None:\n            return\n\n        self._finished_subagent_tool_calls.append(\n            _ToolCallBlock.FinishedSubCall(\n                call=sub_tool_call,\n                result=tool_result.return_value,\n            )\n        )\n        self._n_finished_subagent_tool_calls += 1\n        self._renderable = self._compose()\n\n    def _compose(self) -> RenderableType:\n        lines: list[RenderableType] = [\n            Text.from_markup(self._get_headline_markup()),\n        ]\n\n        if self._n_finished_subagent_tool_calls > MAX_SUBAGENT_TOOL_CALLS_TO_SHOW:\n            n_hidden = self._n_finished_subagent_tool_calls - MAX_SUBAGENT_TOOL_CALLS_TO_SHOW\n            lines.append(\n                BulletColumns(\n                    Text(\n                        f\"{n_hidden} more tool call{'s' if n_hidden > 1 else ''} ...\",\n                        style=\"grey50 italic\",\n                    ),\n                    bullet_style=\"grey50\",\n                )\n            )\n        for sub_call, sub_result in self._finished_subagent_tool_calls:\n            argument = extract_key_argument(\n                sub_call.function.arguments or \"\", sub_call.function.name\n            )\n            lines.append(\n                BulletColumns(\n                    Text.from_markup(\n                        f\"Used [blue]{sub_call.function.name}[/blue]\"\n                        + (f\" [grey50]({argument})[/grey50]\" if argument else \"\")\n                    ),\n                    bullet_style=\"green\" if not sub_result.is_error else \"red\",\n                )\n            )\n\n        if self._result is not None:\n            for block in self._result.display:\n                if isinstance(block, BriefDisplayBlock):\n                    style = \"grey50\" if not self._result.is_error else \"red\"\n                    if block.text:\n                        lines.append(Markdown(block.text, style=style))\n                elif isinstance(block, TodoDisplayBlock):\n                    markdown = self._render_todo_markdown(block)\n                    if markdown:\n                        lines.append(Markdown(markdown, style=\"grey50\"))\n\n        if self.finished:\n            assert self._result is not None\n            return BulletColumns(\n                Group(*lines),\n                bullet_style=\"green\" if not self._result.is_error else \"red\",\n            )\n        else:\n            return BulletColumns(\n                Group(*lines),\n                bullet=self._spinning_dots,\n            )\n\n    def _get_headline_markup(self) -> str:\n        return f\"{'Used' if self.finished else 'Using'} [blue]{self._tool_name}[/blue]\" + (\n            f\" [grey50]({escape(self._argument)})[/grey50]\" if self._argument else \"\"\n        )\n\n    def _render_todo_markdown(self, block: TodoDisplayBlock) -> str:\n        lines: list[str] = []\n        for todo in block.items:\n            normalized = todo.status.replace(\"_\", \" \").lower()\n            match normalized:\n                case \"pending\":\n                    lines.append(f\"- {todo.title}\")\n                case \"in progress\":\n                    lines.append(f\"- {todo.title} ←\")\n                case \"done\":\n                    lines.append(f\"- ~~{todo.title}~~\")\n                case _:\n                    lines.append(f\"- {todo.title}\")\n        return \"\\n\".join(lines)\n\n\nclass _ApprovalContentBlock(NamedTuple):\n    \"\"\"A pre-rendered content block for approval request with line count.\"\"\"\n\n    text: str\n    lines: int\n    style: str = \"\"\n    lexer: str = \"\"\n\n\nclass _ApprovalRequestPanel:\n    def __init__(self, request: ApprovalRequest):\n        self.request = request\n        self.options: list[tuple[str, ApprovalResponse.Kind]] = [\n            (\"Approve once\", \"approve\"),\n            (\"Approve for this session\", \"approve_for_session\"),\n            (\"Reject, tell Kimi what to do instead\", \"reject\"),\n        ]\n        self.selected_index = 0\n\n        # Pre-render all content blocks with line counts\n        self._content_blocks: list[_ApprovalContentBlock] = []\n        last_diff_path: str | None = None\n\n        # Handle description (only if no display blocks)\n        if request.description and not request.display:\n            text = request.description.rstrip(\"\\n\")\n            self._content_blocks.append(\n                _ApprovalContentBlock(text=text, lines=text.count(\"\\n\") + 1)\n            )\n\n        # Handle display blocks\n        for block in request.display:\n            if isinstance(block, DiffDisplayBlock):\n                # File path or ellipsis\n                if block.path != last_diff_path:\n                    self._content_blocks.append(\n                        _ApprovalContentBlock(text=block.path, lines=1, style=\"bold\")\n                    )\n                    last_diff_path = block.path\n                else:\n                    self._content_blocks.append(\n                        _ApprovalContentBlock(text=\"⋮\", lines=1, style=\"dim\")\n                    )\n                # Diff content\n                diff_text = format_unified_diff(\n                    block.old_text,\n                    block.new_text,\n                    block.path,\n                    include_file_header=False,\n                ).rstrip(\"\\n\")\n                self._content_blocks.append(\n                    _ApprovalContentBlock(\n                        text=diff_text, lines=diff_text.count(\"\\n\") + 1, lexer=\"diff\"\n                    )\n                )\n            elif isinstance(block, ShellDisplayBlock):\n                text = block.command.rstrip(\"\\n\")\n                self._content_blocks.append(\n                    _ApprovalContentBlock(\n                        text=text, lines=text.count(\"\\n\") + 1, lexer=block.language\n                    )\n                )\n                last_diff_path = None\n            elif isinstance(block, BriefDisplayBlock) and block.text:\n                text = block.text.rstrip(\"\\n\")\n                self._content_blocks.append(\n                    _ApprovalContentBlock(text=text, lines=text.count(\"\\n\") + 1, style=\"grey50\")\n                )\n                last_diff_path = None\n\n        self._total_lines = sum(b.lines for b in self._content_blocks)\n        self.has_expandable_content = self._total_lines > MAX_PREVIEW_LINES\n\n    def render(self) -> RenderableType:\n        \"\"\"Render the approval menu as a panel.\"\"\"\n        content_lines: list[RenderableType] = [\n            Text.from_markup(\n                \"[yellow]⚠ \"\n                f\"{escape(self.request.sender)} is requesting approval to \"\n                f\"{escape(self.request.action)}:[/yellow]\"\n            )\n        ]\n        content_lines.append(Text(\"\"))\n\n        # Render content with line budget\n        remaining = MAX_PREVIEW_LINES\n        for block in self._content_blocks:\n            if remaining <= 0:\n                break\n            content_lines.append(self._render_block(block, remaining))\n            remaining -= min(block.lines, remaining)\n\n        if self.has_expandable_content:\n            content_lines.append(Text(\"... (truncated, ctrl-e to expand)\", style=\"dim italic\"))\n\n        lines: list[RenderableType] = []\n        if content_lines:\n            lines.append(Padding(Group(*content_lines), (0, 0, 0, 2)))\n\n        # Add menu options\n        if lines:\n            lines.append(Text(\"\"))\n        for i, (option_text, _) in enumerate(self.options):\n            if i == self.selected_index:\n                lines.append(Text(f\"→ {option_text}\", style=\"cyan\"))\n            else:\n                lines.append(Text(f\"  {option_text}\", style=\"grey50\"))\n\n        return Padding(Group(*lines), 1)\n\n    def _render_block(\n        self, block: _ApprovalContentBlock, max_lines: int | None = None\n    ) -> RenderableType:\n        \"\"\"Render a content block, optionally truncated.\"\"\"\n        text = block.text\n        if max_lines is not None and block.lines > max_lines:\n            # Truncate to max_lines\n            text = \"\\n\".join(text.split(\"\\n\")[:max_lines])\n\n        if block.lexer:\n            return KimiSyntax(text, block.lexer)\n        return Text(text, style=block.style)\n\n    def render_full(self) -> list[RenderableType]:\n        \"\"\"Render full content for pager (no truncation).\"\"\"\n        return [self._render_block(block) for block in self._content_blocks]\n\n    def move_up(self):\n        \"\"\"Move selection up.\"\"\"\n        self.selected_index = (self.selected_index - 1) % len(self.options)\n\n    def move_down(self):\n        \"\"\"Move selection down.\"\"\"\n        self.selected_index = (self.selected_index + 1) % len(self.options)\n\n    def get_selected_response(self) -> ApprovalResponse.Kind:\n        \"\"\"Get the approval response based on selected option.\"\"\"\n        return self.options[self.selected_index][1]\n\n\ndef _show_approval_in_pager(panel: _ApprovalRequestPanel) -> None:\n    \"\"\"Show the full approval request content in a pager.\"\"\"\n    with console.screen(), console.pager(styles=True):\n        # Header: matches the style in _ApprovalRequestPanel.render()\n        console.print(\n            Text.from_markup(\n                \"[yellow]⚠ \"\n                f\"{escape(panel.request.sender)} is requesting approval to \"\n                f\"{escape(panel.request.action)}:[/yellow]\"\n            )\n        )\n        console.print()\n\n        # Render full content (no truncation)\n        for renderable in panel.render_full():\n            console.print(renderable)\n\n\nclass _StatusBlock:\n    def __init__(self, initial: StatusUpdate) -> None:\n        self.text = Text(\"\", justify=\"right\")\n        self.update(initial)\n\n    def render(self) -> RenderableType:\n        return self.text\n\n    def update(self, status: StatusUpdate) -> None:\n        if status.context_usage is not None:\n            self.text.plain = f\"context: {status.context_usage:.1%}\"\n\n\n@asynccontextmanager\nasync def _keyboard_listener(\n    handler: Callable[[KeyboardListener, KeyEvent], Awaitable[None]],\n):\n    listener = KeyboardListener()\n    await listener.start()\n\n    async def _keyboard():\n        while True:\n            event = await listener.get()\n            await handler(listener, event)\n\n    task = asyncio.create_task(_keyboard())\n    try:\n        yield\n    finally:\n        task.cancel()\n        with suppress(asyncio.CancelledError):\n            await task\n        await listener.stop()\n\n\nclass _LiveView:\n    def __init__(self, initial_status: StatusUpdate, cancel_event: asyncio.Event | None = None):\n        self._cancel_event = cancel_event\n\n        self._mooning_spinner: Spinner | None = None\n        self._compacting_spinner: Spinner | None = None\n\n        self._current_content_block: _ContentBlock | None = None\n        self._tool_call_blocks: dict[str, _ToolCallBlock] = {}\n        self._last_tool_call_block: _ToolCallBlock | None = None\n        self._approval_request_queue = deque[ApprovalRequest]()\n        \"\"\"\n        It is possible that multiple subagents request approvals at the same time,\n        in which case we will have to queue them up and show them one by one.\n        \"\"\"\n        self._current_approval_request_panel: _ApprovalRequestPanel | None = None\n        self._reject_all_following = False\n        self._status_block = _StatusBlock(initial_status)\n\n        self._need_recompose = False\n\n    def _reset_live_shape(self, live: Live) -> None:\n        # Rich doesn't expose a public API to clear Live's cached render height.\n        # After leaving the pager, stale height causes cursor restores to jump,\n        # so we reset the private _shape to re-anchor the next refresh.\n        live._live_render._shape = None  # type: ignore[reportPrivateUsage]\n\n    async def visualize_loop(self, wire: WireUISide):\n        with Live(\n            self.compose(),\n            console=console,\n            refresh_per_second=10,\n            transient=True,\n            vertical_overflow=\"visible\",\n        ) as live:\n\n            async def keyboard_handler(listener: KeyboardListener, event: KeyEvent) -> None:\n                # Handle Ctrl+E specially - pause Live while the pager is active\n                if event == KeyEvent.CTRL_E:\n                    if (\n                        self._current_approval_request_panel\n                        and self._current_approval_request_panel.has_expandable_content\n                    ):\n                        await listener.pause()\n                        live.stop()\n                        try:\n                            _show_approval_in_pager(self._current_approval_request_panel)\n                        finally:\n                            # Reset live render shape so the next refresh re-anchors cleanly.\n                            self._reset_live_shape(live)\n                            live.start()\n                            live.update(self.compose(), refresh=True)\n                            await listener.resume()\n                    return\n\n                self.dispatch_keyboard_event(event)\n                if self._need_recompose:\n                    live.update(self.compose(), refresh=True)\n                    self._need_recompose = False\n\n            async with _keyboard_listener(keyboard_handler):\n                while True:\n                    try:\n                        msg = await wire.receive()\n                    except QueueShutDown:\n                        self.cleanup(is_interrupt=False)\n                        live.update(self.compose(), refresh=True)\n                        break\n\n                    if isinstance(msg, StepInterrupted):\n                        self.cleanup(is_interrupt=True)\n                        live.update(self.compose(), refresh=True)\n                        break\n\n                    self.dispatch_wire_message(msg)\n                    if self._need_recompose:\n                        live.update(self.compose(), refresh=True)\n                        self._need_recompose = False\n\n    def refresh_soon(self) -> None:\n        self._need_recompose = True\n\n    def compose(self) -> RenderableType:\n        \"\"\"Compose the live view display content.\"\"\"\n        blocks: list[RenderableType] = []\n        if self._mooning_spinner is not None:\n            blocks.append(self._mooning_spinner)\n        elif self._compacting_spinner is not None:\n            blocks.append(self._compacting_spinner)\n        else:\n            if self._current_content_block is not None:\n                blocks.append(self._current_content_block.compose())\n            for tool_call in self._tool_call_blocks.values():\n                blocks.append(tool_call.compose())\n        if self._current_approval_request_panel:\n            blocks.append(self._current_approval_request_panel.render())\n        blocks.append(self._status_block.render())\n        return Group(*blocks)\n\n    def dispatch_wire_message(self, msg: WireMessage) -> None:\n        \"\"\"Dispatch the Wire message to UI components.\"\"\"\n        assert not isinstance(msg, StepInterrupted)  # handled in visualize_loop\n\n        if isinstance(msg, StepBegin):\n            self.cleanup(is_interrupt=False)\n            self._mooning_spinner = Spinner(\"moon\", \"\")\n            self.refresh_soon()\n            return\n\n        if self._mooning_spinner is not None:\n            # any message other than StepBegin should end the mooning state\n            self._mooning_spinner = None\n            self.refresh_soon()\n\n        match msg:\n            case TurnBegin():\n                self.flush_content()\n                console.print(\n                    Panel(\n                        Text(message_stringify(Message(role=\"user\", content=msg.user_input))),\n                        padding=(0, 1),\n                    )\n                )\n            case TurnEnd():\n                pass\n            case CompactionBegin():\n                self._compacting_spinner = Spinner(\"balloon\", \"Compacting...\")\n                self.refresh_soon()\n            case CompactionEnd():\n                self._compacting_spinner = None\n                self.refresh_soon()\n            case StatusUpdate():\n                self._status_block.update(msg)\n            case ContentPart():\n                self.append_content(msg)\n            case ToolCall():\n                self.append_tool_call(msg)\n            case ToolCallPart():\n                self.append_tool_call_part(msg)\n            case ToolResult():\n                self.append_tool_result(msg)\n            case ApprovalResponse():\n                # we don't need to handle this because the request is resolved on UI\n                pass\n            case SubagentEvent():\n                self.handle_subagent_event(msg)\n            case ApprovalRequest():\n                self.request_approval(msg)\n            case ToolCallRequest():\n                logger.warning(\"Unexpected ToolCallRequest in shell UI: {msg}\", msg=msg)\n\n    def dispatch_keyboard_event(self, event: KeyEvent) -> None:\n        # handle ESC key to cancel the run\n        if event == KeyEvent.ESCAPE and self._cancel_event is not None:\n            self._cancel_event.set()\n            return\n\n        if not self._current_approval_request_panel:\n            # just ignore any keyboard event when there's no approval request\n            return\n\n        match event:\n            case KeyEvent.UP:\n                self._current_approval_request_panel.move_up()\n                self.refresh_soon()\n            case KeyEvent.DOWN:\n                self._current_approval_request_panel.move_down()\n                self.refresh_soon()\n            case KeyEvent.ENTER:\n                resp = self._current_approval_request_panel.get_selected_response()\n                self._current_approval_request_panel.request.resolve(resp)\n                if resp == \"approve_for_session\":\n                    to_remove_from_queue: list[ApprovalRequest] = []\n                    for request in self._approval_request_queue:\n                        # approve all queued requests with the same action\n                        if request.action == self._current_approval_request_panel.request.action:\n                            request.resolve(\"approve_for_session\")\n                            to_remove_from_queue.append(request)\n                    for request in to_remove_from_queue:\n                        self._approval_request_queue.remove(request)\n                elif resp == \"reject\":\n                    # one rejection should stop the step immediately\n                    while self._approval_request_queue:\n                        self._approval_request_queue.popleft().resolve(\"reject\")\n                    self._reject_all_following = True\n                self.show_next_approval_request()\n            case _:\n                # just ignore any other keyboard event\n                return\n\n    def cleanup(self, is_interrupt: bool) -> None:\n        \"\"\"Cleanup the live view on step end or interruption.\"\"\"\n        self.flush_content()\n\n        for block in self._tool_call_blocks.values():\n            if not block.finished:\n                # this should not happen, but just in case\n                block.finish(\n                    ToolError(message=\"\", brief=\"Interrupted\")\n                    if is_interrupt\n                    else ToolOk(output=\"\")\n                )\n        self._last_tool_call_block = None\n        self.flush_finished_tool_calls()\n\n        while self._approval_request_queue:\n            # should not happen, but just in case\n            self._approval_request_queue.popleft().resolve(\"reject\")\n        self._current_approval_request_panel = None\n        self._reject_all_following = False\n\n    def flush_content(self) -> None:\n        \"\"\"Flush the current content block.\"\"\"\n        if self._current_content_block is not None:\n            console.print(self._current_content_block.compose_final())\n            self._current_content_block = None\n            self.refresh_soon()\n\n    def flush_finished_tool_calls(self) -> None:\n        \"\"\"Flush all leading finished tool call blocks.\"\"\"\n        tool_call_ids = list(self._tool_call_blocks.keys())\n        for tool_call_id in tool_call_ids:\n            block = self._tool_call_blocks[tool_call_id]\n            if not block.finished:\n                break\n\n            self._tool_call_blocks.pop(tool_call_id)\n            console.print(block.compose())\n            if self._last_tool_call_block == block:\n                self._last_tool_call_block = None\n            self.refresh_soon()\n\n    def append_content(self, part: ContentPart) -> None:\n        match part:\n            case ThinkPart(think=text) | TextPart(text=text):\n                if not text:\n                    return\n                is_think = isinstance(part, ThinkPart)\n                if self._current_content_block is None:\n                    self._current_content_block = _ContentBlock(is_think)\n                    self.refresh_soon()\n                elif self._current_content_block.is_think != is_think:\n                    self.flush_content()\n                    self._current_content_block = _ContentBlock(is_think)\n                    self.refresh_soon()\n                self._current_content_block.append(text)\n            case _:\n                # TODO: support more content part types\n                pass\n\n    def append_tool_call(self, tool_call: ToolCall) -> None:\n        self.flush_content()\n        self._tool_call_blocks[tool_call.id] = _ToolCallBlock(tool_call)\n        self._last_tool_call_block = self._tool_call_blocks[tool_call.id]\n        self.refresh_soon()\n\n    def append_tool_call_part(self, part: ToolCallPart) -> None:\n        if not part.arguments_part:\n            return\n        if self._last_tool_call_block is None:\n            return\n        self._last_tool_call_block.append_args_part(part.arguments_part)\n        self.refresh_soon()\n\n    def append_tool_result(self, result: ToolResult) -> None:\n        if block := self._tool_call_blocks.get(result.tool_call_id):\n            block.finish(result.return_value)\n            self.flush_finished_tool_calls()\n            self.refresh_soon()\n\n    def request_approval(self, request: ApprovalRequest) -> None:\n        # If we're rejecting all following requests, reject immediately\n        if self._reject_all_following:\n            request.resolve(\"reject\")\n            return\n\n        self._approval_request_queue.append(request)\n\n        if self._current_approval_request_panel is None:\n            console.bell()\n            self.show_next_approval_request()\n\n    def show_next_approval_request(self) -> None:\n        \"\"\"\n        Show the next approval request from the queue.\n        If there are no pending requests, clear the current approval panel.\n        \"\"\"\n        if not self._approval_request_queue:\n            if self._current_approval_request_panel is not None:\n                self._current_approval_request_panel = None\n                self.refresh_soon()\n            return\n\n        while self._approval_request_queue:\n            request = self._approval_request_queue.popleft()\n            if request.resolved:\n                # skip resolved requests\n                continue\n            self._current_approval_request_panel = _ApprovalRequestPanel(request)\n            self.refresh_soon()\n            break\n\n    def handle_subagent_event(self, event: SubagentEvent) -> None:\n        block = self._tool_call_blocks.get(event.task_tool_call_id)\n        if block is None:\n            return\n\n        match event.event:\n            case ToolCall() as tool_call:\n                block.append_sub_tool_call(tool_call)\n            case ToolCallPart() as tool_call_part:\n                block.append_sub_tool_call_part(tool_call_part)\n            case ToolResult() as tool_result:\n                block.finish_sub_tool_call(tool_result)\n                self.refresh_soon()\n            case _:\n                # ignore other events for now\n                # TODO: may need to handle multi-level nested subagents\n                pass\n","structuredPatch":[{"oldStart":1,"oldLines":6,"newStart":1,"newLines":7,"lines":[" from __future__ import annotations"," "," import asyncio","+import json"," from collections import deque"," from collections.abc import Awaitable, Callable"," from contextlib import asynccontextmanager, suppress"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"a7e99a1e-ab5f-4ae7-92e9-f82a2ba9ecac"}
{"parentUuid":"8f8afb11-8c05-465d-aaa7-f0ec163a649d","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_015ck43r3by7qekksbmwDCGU","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014k61i2sxmrgdfpXBcoqf1g","name":"Edit","input":{"replace_all":false,"file_path":"/Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/ui/shell/visualize.py","old_string":"from rich.spinner import Spinner\nfrom rich.text import Text","new_string":"from rich.spinner import Spinner\nfrom rich.style import Style\nfrom rich.text import Text"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":349,"cache_read_input_tokens":33131,"output_tokens":175,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":349},"inference_geo":"","iterations":[],"speed":"standard"}},"type":"assistant","uuid":"8ac1044d-3afc-4ea4-8448-a91c6422668b","timestamp":"2026-02-25T08:05:17.459Z"}
{"parentUuid":"8ac1044d-3afc-4ea4-8448-a91c6422668b","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_014k61i2sxmrgdfpXBcoqf1g","toolUseID":"toolu_014k61i2sxmrgdfpXBcoqf1g","timestamp":"2026-02-25T08:05:17.482Z","uuid":"82e00c4f-9d07-4593-9595-e6832772895e"}
{"parentUuid":"8ac1044d-3afc-4ea4-8448-a91c6422668b","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014k61i2sxmrgdfpXBcoqf1g","type":"tool_result","content":"The file /Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/ui/shell/visualize.py has been updated successfully."}]},"uuid":"c51613a2-9983-4dc7-bbf3-39b8c8fa1902","timestamp":"2026-02-25T08:05:17.481Z","toolUseResult":{"filePath":"/Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/ui/shell/visualize.py","oldString":"from rich.spinner import Spinner\nfrom rich.text import Text","newString":"from rich.spinner import Spinner\nfrom rich.style import Style\nfrom rich.text import Text","originalFile":"from __future__ import annotations\n\nimport asyncio\nimport json\nfrom collections import deque\nfrom collections.abc import Awaitable, Callable\nfrom contextlib import asynccontextmanager, suppress\nfrom typing import NamedTuple\n\nimport streamingjson  # type: ignore[reportMissingTypeStubs]\nfrom kosong.message import Message\nfrom kosong.tooling import ToolError, ToolOk\nfrom rich.console import Group, RenderableType\nfrom rich.live import Live\nfrom rich.markup import escape\nfrom rich.padding import Padding\nfrom rich.panel import Panel\nfrom rich.spinner import Spinner\nfrom rich.text import Text\n\nfrom kimi_cli.tools import extract_key_argument\nfrom kimi_cli.ui.shell.console import console\nfrom kimi_cli.ui.shell.keyboard import KeyboardListener, KeyEvent\nfrom kimi_cli.utils.aioqueue import QueueShutDown\nfrom kimi_cli.utils.diff import format_unified_diff\nfrom kimi_cli.utils.logging import logger\nfrom kimi_cli.utils.message import message_stringify\nfrom kimi_cli.utils.rich.columns import BulletColumns\nfrom kimi_cli.utils.rich.markdown import Markdown\nfrom kimi_cli.utils.rich.syntax import KimiSyntax\nfrom kimi_cli.wire import WireUISide\nfrom kimi_cli.wire.types import (\n    ApprovalRequest,\n    ApprovalResponse,\n    BriefDisplayBlock,\n    CompactionBegin,\n    CompactionEnd,\n    ContentPart,\n    DiffDisplayBlock,\n    ShellDisplayBlock,\n    StatusUpdate,\n    StepBegin,\n    StepInterrupted,\n    SubagentEvent,\n    TextPart,\n    ThinkPart,\n    TodoDisplayBlock,\n    ToolCall,\n    ToolCallPart,\n    ToolCallRequest,\n    ToolResult,\n    ToolReturnValue,\n    TurnBegin,\n    TurnEnd,\n    WireMessage,\n)\n\nMAX_SUBAGENT_TOOL_CALLS_TO_SHOW = 4\n\n# Truncation limits for approval request display\nMAX_PREVIEW_LINES = 4\n\n\nasync def visualize(\n    wire: WireUISide,\n    *,\n    initial_status: StatusUpdate,\n    cancel_event: asyncio.Event | None = None,\n):\n    \"\"\"\n    A loop to consume agent events and visualize the agent behavior.\n\n    Args:\n        wire: Communication channel with the agent\n        initial_status: Initial status snapshot\n        cancel_event: Event that can be set (e.g., by ESC key) to cancel the run\n    \"\"\"\n    view = _LiveView(initial_status, cancel_event)\n    await view.visualize_loop(wire)\n\n\nclass _ContentBlock:\n    def __init__(self, is_think: bool):\n        self.is_think = is_think\n        self._spinner = Spinner(\"dots\", \"Thinking...\" if is_think else \"Composing...\")\n        self.raw_text = \"\"\n\n    def compose(self) -> RenderableType:\n        return self._spinner\n\n    def compose_final(self) -> RenderableType:\n        return BulletColumns(\n            Markdown(\n                self.raw_text,\n                style=\"grey50 italic\" if self.is_think else \"\",\n            ),\n            bullet_style=\"grey50\" if self.is_think else None,\n        )\n\n    def append(self, content: str) -> None:\n        self.raw_text += content\n\n\nclass _ToolCallBlock:\n    class FinishedSubCall(NamedTuple):\n        call: ToolCall\n        result: ToolReturnValue\n\n    def __init__(self, tool_call: ToolCall):\n        self._tool_name = tool_call.function.name\n        self._lexer = streamingjson.Lexer()\n        if tool_call.function.arguments is not None:\n            self._lexer.append_string(tool_call.function.arguments)\n\n        self._argument = extract_key_argument(self._lexer, self._tool_name)\n        self._result: ToolReturnValue | None = None\n\n        self._ongoing_subagent_tool_calls: dict[str, ToolCall] = {}\n        self._last_subagent_tool_call: ToolCall | None = None\n        self._n_finished_subagent_tool_calls = 0\n        self._finished_subagent_tool_calls = deque[_ToolCallBlock.FinishedSubCall](\n            maxlen=MAX_SUBAGENT_TOOL_CALLS_TO_SHOW\n        )\n\n        self._spinning_dots = Spinner(\"dots\", text=\"\")\n        self._renderable: RenderableType = self._compose()\n\n    def compose(self) -> RenderableType:\n        return self._renderable\n\n    @property\n    def finished(self) -> bool:\n        return self._result is not None\n\n    def append_args_part(self, args_part: str):\n        if self.finished:\n            return\n        self._lexer.append_string(args_part)\n        # TODO: maybe don't extract detail if it's already stable\n        argument = extract_key_argument(self._lexer, self._tool_name)\n        if argument and argument != self._argument:\n            self._argument = argument\n            self._renderable = BulletColumns(\n                Text.from_markup(self._get_headline_markup()),\n                bullet=self._spinning_dots,\n            )\n\n    def finish(self, result: ToolReturnValue):\n        self._result = result\n        self._renderable = self._compose()\n\n    def append_sub_tool_call(self, tool_call: ToolCall):\n        self._ongoing_subagent_tool_calls[tool_call.id] = tool_call\n        self._last_subagent_tool_call = tool_call\n\n    def append_sub_tool_call_part(self, tool_call_part: ToolCallPart):\n        if self._last_subagent_tool_call is None:\n            return\n        if not tool_call_part.arguments_part:\n            return\n        if self._last_subagent_tool_call.function.arguments is None:\n            self._last_subagent_tool_call.function.arguments = tool_call_part.arguments_part\n        else:\n            self._last_subagent_tool_call.function.arguments += tool_call_part.arguments_part\n\n    def finish_sub_tool_call(self, tool_result: ToolResult):\n        self._last_subagent_tool_call = None\n        sub_tool_call = self._ongoing_subagent_tool_calls.pop(tool_result.tool_call_id, None)\n        if sub_tool_call is None:\n            return\n\n        self._finished_subagent_tool_calls.append(\n            _ToolCallBlock.FinishedSubCall(\n                call=sub_tool_call,\n                result=tool_result.return_value,\n            )\n        )\n        self._n_finished_subagent_tool_calls += 1\n        self._renderable = self._compose()\n\n    def _compose(self) -> RenderableType:\n        lines: list[RenderableType] = [\n            Text.from_markup(self._get_headline_markup()),\n        ]\n\n        if self._n_finished_subagent_tool_calls > MAX_SUBAGENT_TOOL_CALLS_TO_SHOW:\n            n_hidden = self._n_finished_subagent_tool_calls - MAX_SUBAGENT_TOOL_CALLS_TO_SHOW\n            lines.append(\n                BulletColumns(\n                    Text(\n                        f\"{n_hidden} more tool call{'s' if n_hidden > 1 else ''} ...\",\n                        style=\"grey50 italic\",\n                    ),\n                    bullet_style=\"grey50\",\n                )\n            )\n        for sub_call, sub_result in self._finished_subagent_tool_calls:\n            argument = extract_key_argument(\n                sub_call.function.arguments or \"\", sub_call.function.name\n            )\n            lines.append(\n                BulletColumns(\n                    Text.from_markup(\n                        f\"Used [blue]{sub_call.function.name}[/blue]\"\n                        + (f\" [grey50]({argument})[/grey50]\" if argument else \"\")\n                    ),\n                    bullet_style=\"green\" if not sub_result.is_error else \"red\",\n                )\n            )\n\n        if self._result is not None:\n            for block in self._result.display:\n                if isinstance(block, BriefDisplayBlock):\n                    style = \"grey50\" if not self._result.is_error else \"red\"\n                    if block.text:\n                        lines.append(Markdown(block.text, style=style))\n                elif isinstance(block, TodoDisplayBlock):\n                    markdown = self._render_todo_markdown(block)\n                    if markdown:\n                        lines.append(Markdown(markdown, style=\"grey50\"))\n\n        if self.finished:\n            assert self._result is not None\n            return BulletColumns(\n                Group(*lines),\n                bullet_style=\"green\" if not self._result.is_error else \"red\",\n            )\n        else:\n            return BulletColumns(\n                Group(*lines),\n                bullet=self._spinning_dots,\n            )\n\n    def _get_headline_markup(self) -> str:\n        return f\"{'Used' if self.finished else 'Using'} [blue]{self._tool_name}[/blue]\" + (\n            f\" [grey50]({escape(self._argument)})[/grey50]\" if self._argument else \"\"\n        )\n\n    def _render_todo_markdown(self, block: TodoDisplayBlock) -> str:\n        lines: list[str] = []\n        for todo in block.items:\n            normalized = todo.status.replace(\"_\", \" \").lower()\n            match normalized:\n                case \"pending\":\n                    lines.append(f\"- {todo.title}\")\n                case \"in progress\":\n                    lines.append(f\"- {todo.title} ←\")\n                case \"done\":\n                    lines.append(f\"- ~~{todo.title}~~\")\n                case _:\n                    lines.append(f\"- {todo.title}\")\n        return \"\\n\".join(lines)\n\n\nclass _ApprovalContentBlock(NamedTuple):\n    \"\"\"A pre-rendered content block for approval request with line count.\"\"\"\n\n    text: str\n    lines: int\n    style: str = \"\"\n    lexer: str = \"\"\n\n\nclass _ApprovalRequestPanel:\n    def __init__(self, request: ApprovalRequest):\n        self.request = request\n        self.options: list[tuple[str, ApprovalResponse.Kind]] = [\n            (\"Approve once\", \"approve\"),\n            (\"Approve for this session\", \"approve_for_session\"),\n            (\"Reject, tell Kimi what to do instead\", \"reject\"),\n        ]\n        self.selected_index = 0\n\n        # Pre-render all content blocks with line counts\n        self._content_blocks: list[_ApprovalContentBlock] = []\n        last_diff_path: str | None = None\n\n        # Handle description (only if no display blocks)\n        if request.description and not request.display:\n            text = request.description.rstrip(\"\\n\")\n            self._content_blocks.append(\n                _ApprovalContentBlock(text=text, lines=text.count(\"\\n\") + 1)\n            )\n\n        # Handle display blocks\n        for block in request.display:\n            if isinstance(block, DiffDisplayBlock):\n                # File path or ellipsis\n                if block.path != last_diff_path:\n                    self._content_blocks.append(\n                        _ApprovalContentBlock(text=block.path, lines=1, style=\"bold\")\n                    )\n                    last_diff_path = block.path\n                else:\n                    self._content_blocks.append(\n                        _ApprovalContentBlock(text=\"⋮\", lines=1, style=\"dim\")\n                    )\n                # Diff content\n                diff_text = format_unified_diff(\n                    block.old_text,\n                    block.new_text,\n                    block.path,\n                    include_file_header=False,\n                ).rstrip(\"\\n\")\n                self._content_blocks.append(\n                    _ApprovalContentBlock(\n                        text=diff_text, lines=diff_text.count(\"\\n\") + 1, lexer=\"diff\"\n                    )\n                )\n            elif isinstance(block, ShellDisplayBlock):\n                text = block.command.rstrip(\"\\n\")\n                self._content_blocks.append(\n                    _ApprovalContentBlock(\n                        text=text, lines=text.count(\"\\n\") + 1, lexer=block.language\n                    )\n                )\n                last_diff_path = None\n            elif isinstance(block, BriefDisplayBlock) and block.text:\n                text = block.text.rstrip(\"\\n\")\n                self._content_blocks.append(\n                    _ApprovalContentBlock(text=text, lines=text.count(\"\\n\") + 1, style=\"grey50\")\n                )\n                last_diff_path = None\n\n        self._total_lines = sum(b.lines for b in self._content_blocks)\n        self.has_expandable_content = self._total_lines > MAX_PREVIEW_LINES\n\n    def render(self) -> RenderableType:\n        \"\"\"Render the approval menu as a panel.\"\"\"\n        content_lines: list[RenderableType] = [\n            Text.from_markup(\n                \"[yellow]⚠ \"\n                f\"{escape(self.request.sender)} is requesting approval to \"\n                f\"{escape(self.request.action)}:[/yellow]\"\n            )\n        ]\n        content_lines.append(Text(\"\"))\n\n        # Render content with line budget\n        remaining = MAX_PREVIEW_LINES\n        for block in self._content_blocks:\n            if remaining <= 0:\n                break\n            content_lines.append(self._render_block(block, remaining))\n            remaining -= min(block.lines, remaining)\n\n        if self.has_expandable_content:\n            content_lines.append(Text(\"... (truncated, ctrl-e to expand)\", style=\"dim italic\"))\n\n        lines: list[RenderableType] = []\n        if content_lines:\n            lines.append(Padding(Group(*content_lines), (0, 0, 0, 2)))\n\n        # Add menu options\n        if lines:\n            lines.append(Text(\"\"))\n        for i, (option_text, _) in enumerate(self.options):\n            if i == self.selected_index:\n                lines.append(Text(f\"→ {option_text}\", style=\"cyan\"))\n            else:\n                lines.append(Text(f\"  {option_text}\", style=\"grey50\"))\n\n        return Padding(Group(*lines), 1)\n\n    def _render_block(\n        self, block: _ApprovalContentBlock, max_lines: int | None = None\n    ) -> RenderableType:\n        \"\"\"Render a content block, optionally truncated.\"\"\"\n        text = block.text\n        if max_lines is not None and block.lines > max_lines:\n            # Truncate to max_lines\n            text = \"\\n\".join(text.split(\"\\n\")[:max_lines])\n\n        if block.lexer:\n            return KimiSyntax(text, block.lexer)\n        return Text(text, style=block.style)\n\n    def render_full(self) -> list[RenderableType]:\n        \"\"\"Render full content for pager (no truncation).\"\"\"\n        return [self._render_block(block) for block in self._content_blocks]\n\n    def move_up(self):\n        \"\"\"Move selection up.\"\"\"\n        self.selected_index = (self.selected_index - 1) % len(self.options)\n\n    def move_down(self):\n        \"\"\"Move selection down.\"\"\"\n        self.selected_index = (self.selected_index + 1) % len(self.options)\n\n    def get_selected_response(self) -> ApprovalResponse.Kind:\n        \"\"\"Get the approval response based on selected option.\"\"\"\n        return self.options[self.selected_index][1]\n\n\ndef _show_approval_in_pager(panel: _ApprovalRequestPanel) -> None:\n    \"\"\"Show the full approval request content in a pager.\"\"\"\n    with console.screen(), console.pager(styles=True):\n        # Header: matches the style in _ApprovalRequestPanel.render()\n        console.print(\n            Text.from_markup(\n                \"[yellow]⚠ \"\n                f\"{escape(panel.request.sender)} is requesting approval to \"\n                f\"{escape(panel.request.action)}:[/yellow]\"\n            )\n        )\n        console.print()\n\n        # Render full content (no truncation)\n        for renderable in panel.render_full():\n            console.print(renderable)\n\n\nclass _StatusBlock:\n    def __init__(self, initial: StatusUpdate) -> None:\n        self.text = Text(\"\", justify=\"right\")\n        self.update(initial)\n\n    def render(self) -> RenderableType:\n        return self.text\n\n    def update(self, status: StatusUpdate) -> None:\n        if status.context_usage is not None:\n            self.text.plain = f\"context: {status.context_usage:.1%}\"\n\n\n@asynccontextmanager\nasync def _keyboard_listener(\n    handler: Callable[[KeyboardListener, KeyEvent], Awaitable[None]],\n):\n    listener = KeyboardListener()\n    await listener.start()\n\n    async def _keyboard():\n        while True:\n            event = await listener.get()\n            await handler(listener, event)\n\n    task = asyncio.create_task(_keyboard())\n    try:\n        yield\n    finally:\n        task.cancel()\n        with suppress(asyncio.CancelledError):\n            await task\n        await listener.stop()\n\n\nclass _LiveView:\n    def __init__(self, initial_status: StatusUpdate, cancel_event: asyncio.Event | None = None):\n        self._cancel_event = cancel_event\n\n        self._mooning_spinner: Spinner | None = None\n        self._compacting_spinner: Spinner | None = None\n\n        self._current_content_block: _ContentBlock | None = None\n        self._tool_call_blocks: dict[str, _ToolCallBlock] = {}\n        self._last_tool_call_block: _ToolCallBlock | None = None\n        self._approval_request_queue = deque[ApprovalRequest]()\n        \"\"\"\n        It is possible that multiple subagents request approvals at the same time,\n        in which case we will have to queue them up and show them one by one.\n        \"\"\"\n        self._current_approval_request_panel: _ApprovalRequestPanel | None = None\n        self._reject_all_following = False\n        self._status_block = _StatusBlock(initial_status)\n\n        self._need_recompose = False\n\n    def _reset_live_shape(self, live: Live) -> None:\n        # Rich doesn't expose a public API to clear Live's cached render height.\n        # After leaving the pager, stale height causes cursor restores to jump,\n        # so we reset the private _shape to re-anchor the next refresh.\n        live._live_render._shape = None  # type: ignore[reportPrivateUsage]\n\n    async def visualize_loop(self, wire: WireUISide):\n        with Live(\n            self.compose(),\n            console=console,\n            refresh_per_second=10,\n            transient=True,\n            vertical_overflow=\"visible\",\n        ) as live:\n\n            async def keyboard_handler(listener: KeyboardListener, event: KeyEvent) -> None:\n                # Handle Ctrl+E specially - pause Live while the pager is active\n                if event == KeyEvent.CTRL_E:\n                    if (\n                        self._current_approval_request_panel\n                        and self._current_approval_request_panel.has_expandable_content\n                    ):\n                        await listener.pause()\n                        live.stop()\n                        try:\n                            _show_approval_in_pager(self._current_approval_request_panel)\n                        finally:\n                            # Reset live render shape so the next refresh re-anchors cleanly.\n                            self._reset_live_shape(live)\n                            live.start()\n                            live.update(self.compose(), refresh=True)\n                            await listener.resume()\n                    return\n\n                self.dispatch_keyboard_event(event)\n                if self._need_recompose:\n                    live.update(self.compose(), refresh=True)\n                    self._need_recompose = False\n\n            async with _keyboard_listener(keyboard_handler):\n                while True:\n                    try:\n                        msg = await wire.receive()\n                    except QueueShutDown:\n                        self.cleanup(is_interrupt=False)\n                        live.update(self.compose(), refresh=True)\n                        break\n\n                    if isinstance(msg, StepInterrupted):\n                        self.cleanup(is_interrupt=True)\n                        live.update(self.compose(), refresh=True)\n                        break\n\n                    self.dispatch_wire_message(msg)\n                    if self._need_recompose:\n                        live.update(self.compose(), refresh=True)\n                        self._need_recompose = False\n\n    def refresh_soon(self) -> None:\n        self._need_recompose = True\n\n    def compose(self) -> RenderableType:\n        \"\"\"Compose the live view display content.\"\"\"\n        blocks: list[RenderableType] = []\n        if self._mooning_spinner is not None:\n            blocks.append(self._mooning_spinner)\n        elif self._compacting_spinner is not None:\n            blocks.append(self._compacting_spinner)\n        else:\n            if self._current_content_block is not None:\n                blocks.append(self._current_content_block.compose())\n            for tool_call in self._tool_call_blocks.values():\n                blocks.append(tool_call.compose())\n        if self._current_approval_request_panel:\n            blocks.append(self._current_approval_request_panel.render())\n        blocks.append(self._status_block.render())\n        return Group(*blocks)\n\n    def dispatch_wire_message(self, msg: WireMessage) -> None:\n        \"\"\"Dispatch the Wire message to UI components.\"\"\"\n        assert not isinstance(msg, StepInterrupted)  # handled in visualize_loop\n\n        if isinstance(msg, StepBegin):\n            self.cleanup(is_interrupt=False)\n            self._mooning_spinner = Spinner(\"moon\", \"\")\n            self.refresh_soon()\n            return\n\n        if self._mooning_spinner is not None:\n            # any message other than StepBegin should end the mooning state\n            self._mooning_spinner = None\n            self.refresh_soon()\n\n        match msg:\n            case TurnBegin():\n                self.flush_content()\n                console.print(\n                    Panel(\n                        Text(message_stringify(Message(role=\"user\", content=msg.user_input))),\n                        padding=(0, 1),\n                    )\n                )\n            case TurnEnd():\n                pass\n            case CompactionBegin():\n                self._compacting_spinner = Spinner(\"balloon\", \"Compacting...\")\n                self.refresh_soon()\n            case CompactionEnd():\n                self._compacting_spinner = None\n                self.refresh_soon()\n            case StatusUpdate():\n                self._status_block.update(msg)\n            case ContentPart():\n                self.append_content(msg)\n            case ToolCall():\n                self.append_tool_call(msg)\n            case ToolCallPart():\n                self.append_tool_call_part(msg)\n            case ToolResult():\n                self.append_tool_result(msg)\n            case ApprovalResponse():\n                # we don't need to handle this because the request is resolved on UI\n                pass\n            case SubagentEvent():\n                self.handle_subagent_event(msg)\n            case ApprovalRequest():\n                self.request_approval(msg)\n            case ToolCallRequest():\n                logger.warning(\"Unexpected ToolCallRequest in shell UI: {msg}\", msg=msg)\n\n    def dispatch_keyboard_event(self, event: KeyEvent) -> None:\n        # handle ESC key to cancel the run\n        if event == KeyEvent.ESCAPE and self._cancel_event is not None:\n            self._cancel_event.set()\n            return\n\n        if not self._current_approval_request_panel:\n            # just ignore any keyboard event when there's no approval request\n            return\n\n        match event:\n            case KeyEvent.UP:\n                self._current_approval_request_panel.move_up()\n                self.refresh_soon()\n            case KeyEvent.DOWN:\n                self._current_approval_request_panel.move_down()\n                self.refresh_soon()\n            case KeyEvent.ENTER:\n                resp = self._current_approval_request_panel.get_selected_response()\n                self._current_approval_request_panel.request.resolve(resp)\n                if resp == \"approve_for_session\":\n                    to_remove_from_queue: list[ApprovalRequest] = []\n                    for request in self._approval_request_queue:\n                        # approve all queued requests with the same action\n                        if request.action == self._current_approval_request_panel.request.action:\n                            request.resolve(\"approve_for_session\")\n                            to_remove_from_queue.append(request)\n                    for request in to_remove_from_queue:\n                        self._approval_request_queue.remove(request)\n                elif resp == \"reject\":\n                    # one rejection should stop the step immediately\n                    while self._approval_request_queue:\n                        self._approval_request_queue.popleft().resolve(\"reject\")\n                    self._reject_all_following = True\n                self.show_next_approval_request()\n            case _:\n                # just ignore any other keyboard event\n                return\n\n    def cleanup(self, is_interrupt: bool) -> None:\n        \"\"\"Cleanup the live view on step end or interruption.\"\"\"\n        self.flush_content()\n\n        for block in self._tool_call_blocks.values():\n            if not block.finished:\n                # this should not happen, but just in case\n                block.finish(\n                    ToolError(message=\"\", brief=\"Interrupted\")\n                    if is_interrupt\n                    else ToolOk(output=\"\")\n                )\n        self._last_tool_call_block = None\n        self.flush_finished_tool_calls()\n\n        while self._approval_request_queue:\n            # should not happen, but just in case\n            self._approval_request_queue.popleft().resolve(\"reject\")\n        self._current_approval_request_panel = None\n        self._reject_all_following = False\n\n    def flush_content(self) -> None:\n        \"\"\"Flush the current content block.\"\"\"\n        if self._current_content_block is not None:\n            console.print(self._current_content_block.compose_final())\n            self._current_content_block = None\n            self.refresh_soon()\n\n    def flush_finished_tool_calls(self) -> None:\n        \"\"\"Flush all leading finished tool call blocks.\"\"\"\n        tool_call_ids = list(self._tool_call_blocks.keys())\n        for tool_call_id in tool_call_ids:\n            block = self._tool_call_blocks[tool_call_id]\n            if not block.finished:\n                break\n\n            self._tool_call_blocks.pop(tool_call_id)\n            console.print(block.compose())\n            if self._last_tool_call_block == block:\n                self._last_tool_call_block = None\n            self.refresh_soon()\n\n    def append_content(self, part: ContentPart) -> None:\n        match part:\n            case ThinkPart(think=text) | TextPart(text=text):\n                if not text:\n                    return\n                is_think = isinstance(part, ThinkPart)\n                if self._current_content_block is None:\n                    self._current_content_block = _ContentBlock(is_think)\n                    self.refresh_soon()\n                elif self._current_content_block.is_think != is_think:\n                    self.flush_content()\n                    self._current_content_block = _ContentBlock(is_think)\n                    self.refresh_soon()\n                self._current_content_block.append(text)\n            case _:\n                # TODO: support more content part types\n                pass\n\n    def append_tool_call(self, tool_call: ToolCall) -> None:\n        self.flush_content()\n        self._tool_call_blocks[tool_call.id] = _ToolCallBlock(tool_call)\n        self._last_tool_call_block = self._tool_call_blocks[tool_call.id]\n        self.refresh_soon()\n\n    def append_tool_call_part(self, part: ToolCallPart) -> None:\n        if not part.arguments_part:\n            return\n        if self._last_tool_call_block is None:\n            return\n        self._last_tool_call_block.append_args_part(part.arguments_part)\n        self.refresh_soon()\n\n    def append_tool_result(self, result: ToolResult) -> None:\n        if block := self._tool_call_blocks.get(result.tool_call_id):\n            block.finish(result.return_value)\n            self.flush_finished_tool_calls()\n            self.refresh_soon()\n\n    def request_approval(self, request: ApprovalRequest) -> None:\n        # If we're rejecting all following requests, reject immediately\n        if self._reject_all_following:\n            request.resolve(\"reject\")\n            return\n\n        self._approval_request_queue.append(request)\n\n        if self._current_approval_request_panel is None:\n            console.bell()\n            self.show_next_approval_request()\n\n    def show_next_approval_request(self) -> None:\n        \"\"\"\n        Show the next approval request from the queue.\n        If there are no pending requests, clear the current approval panel.\n        \"\"\"\n        if not self._approval_request_queue:\n            if self._current_approval_request_panel is not None:\n                self._current_approval_request_panel = None\n                self.refresh_soon()\n            return\n\n        while self._approval_request_queue:\n            request = self._approval_request_queue.popleft()\n            if request.resolved:\n                # skip resolved requests\n                continue\n            self._current_approval_request_panel = _ApprovalRequestPanel(request)\n            self.refresh_soon()\n            break\n\n    def handle_subagent_event(self, event: SubagentEvent) -> None:\n        block = self._tool_call_blocks.get(event.task_tool_call_id)\n        if block is None:\n            return\n\n        match event.event:\n            case ToolCall() as tool_call:\n                block.append_sub_tool_call(tool_call)\n            case ToolCallPart() as tool_call_part:\n                block.append_sub_tool_call_part(tool_call_part)\n            case ToolResult() as tool_result:\n                block.finish_sub_tool_call(tool_result)\n                self.refresh_soon()\n            case _:\n                # ignore other events for now\n                # TODO: may need to handle multi-level nested subagents\n                pass\n","structuredPatch":[{"oldStart":16,"oldLines":6,"newStart":16,"newLines":7,"lines":[" from rich.padding import Padding"," from rich.panel import Panel"," from rich.spinner import Spinner","+from rich.style import Style"," from rich.text import Text"," "," from kimi_cli.tools import extract_key_argument"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"8ac1044d-3afc-4ea4-8448-a91c6422668b"}
{"parentUuid":"c51613a2-9983-4dc7-bbf3-39b8c8fa1902","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_01M7CyLBRKofxLPrWcnYKMYW","type":"message","role":"assistant","content":[{"type":"text","text":"**Step 2: Add `_extract_full_url` static method and `self._full_url` to `_ToolCallBlock.__init__`**"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":226,"cache_read_input_tokens":33480,"cache_creation":{"ephemeral_5m_input_tokens":226,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"type":"assistant","uuid":"2c4cf085-f65b-43a3-b9fb-c85b1e7f0bff","timestamp":"2026-02-25T08:05:20.310Z"}
{"parentUuid":"2c4cf085-f65b-43a3-b9fb-c85b1e7f0bff","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_01M7CyLBRKofxLPrWcnYKMYW","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VLY7CiTuX8HpULKqiRgrqh","name":"Edit","input":{"replace_all":false,"file_path":"/Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/ui/shell/visualize.py","old_string":"    def __init__(self, tool_call: ToolCall):\n        self._tool_name = tool_call.function.name\n        self._lexer = streamingjson.Lexer()\n        if tool_call.function.arguments is not None:\n            self._lexer.append_string(tool_call.function.arguments)\n\n        self._argument = extract_key_argument(self._lexer, self._tool_name)\n        self._result: ToolReturnValue | None = None","new_string":"    @staticmethod\n    def _extract_full_url(\n        json_content: str | streamingjson.Lexer, tool_name: str\n    ) -> str | None:\n        if tool_name != \"FetchURL\":\n            return None\n        json_str = (\n            json_content.complete_json()\n            if isinstance(json_content, streamingjson.Lexer)\n            else json_content\n        )\n        try:\n            args = json.loads(json_str)\n        except (json.JSONDecodeError, ValueError):\n            return None\n        if isinstance(args, dict) and args.get(\"url\"):\n            return str(args[\"url\"])\n        return None\n\n    def __init__(self, tool_call: ToolCall):\n        self._tool_name = tool_call.function.name\n        self._lexer = streamingjson.Lexer()\n        if tool_call.function.arguments is not None:\n            self._lexer.append_string(tool_call.function.arguments)\n\n        self._argument = extract_key_argument(self._lexer, self._tool_name)\n        self._full_url = self._extract_full_url(self._lexer, self._tool_name)\n        self._result: ToolReturnValue | None = None"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":226,"cache_read_input_tokens":33480,"output_tokens":605,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":226},"inference_geo":"","iterations":[],"speed":"standard"}},"type":"assistant","uuid":"daf232f5-34d2-4308-964a-79794e46e94d","timestamp":"2026-02-25T08:05:25.680Z"}
{"parentUuid":"daf232f5-34d2-4308-964a-79794e46e94d","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01VLY7CiTuX8HpULKqiRgrqh","toolUseID":"toolu_01VLY7CiTuX8HpULKqiRgrqh","timestamp":"2026-02-25T08:05:25.724Z","uuid":"8f1053d8-e2e8-45fe-9051-75da6b9762da"}
{"parentUuid":"daf232f5-34d2-4308-964a-79794e46e94d","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VLY7CiTuX8HpULKqiRgrqh","type":"tool_result","content":"The file /Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/ui/shell/visualize.py has been updated successfully."}]},"uuid":"1afbb722-3235-436f-95f2-e626ead11240","timestamp":"2026-02-25T08:05:25.723Z","toolUseResult":{"filePath":"/Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/ui/shell/visualize.py","oldString":"    def __init__(self, tool_call: ToolCall):\n        self._tool_name = tool_call.function.name\n        self._lexer = streamingjson.Lexer()\n        if tool_call.function.arguments is not None:\n            self._lexer.append_string(tool_call.function.arguments)\n\n        self._argument = extract_key_argument(self._lexer, self._tool_name)\n        self._result: ToolReturnValue | None = None","newString":"    @staticmethod\n    def _extract_full_url(\n        json_content: str | streamingjson.Lexer, tool_name: str\n    ) -> str | None:\n        if tool_name != \"FetchURL\":\n            return None\n        json_str = (\n            json_content.complete_json()\n            if isinstance(json_content, streamingjson.Lexer)\n            else json_content\n        )\n        try:\n            args = json.loads(json_str)\n        except (json.JSONDecodeError, ValueError):\n            return None\n        if isinstance(args, dict) and args.get(\"url\"):\n            return str(args[\"url\"])\n        return None\n\n    def __init__(self, tool_call: ToolCall):\n        self._tool_name = tool_call.function.name\n        self._lexer = streamingjson.Lexer()\n        if tool_call.function.arguments is not None:\n            self._lexer.append_string(tool_call.function.arguments)\n\n        self._argument = extract_key_argument(self._lexer, self._tool_name)\n        self._full_url = self._extract_full_url(self._lexer, self._tool_name)\n        self._result: ToolReturnValue | None = None","originalFile":"from __future__ import annotations\n\nimport asyncio\nimport json\nfrom collections import deque\nfrom collections.abc import Awaitable, Callable\nfrom contextlib import asynccontextmanager, suppress\nfrom typing import NamedTuple\n\nimport streamingjson  # type: ignore[reportMissingTypeStubs]\nfrom kosong.message import Message\nfrom kosong.tooling import ToolError, ToolOk\nfrom rich.console import Group, RenderableType\nfrom rich.live import Live\nfrom rich.markup import escape\nfrom rich.padding import Padding\nfrom rich.panel import Panel\nfrom rich.spinner import Spinner\nfrom rich.style import Style\nfrom rich.text import Text\n\nfrom kimi_cli.tools import extract_key_argument\nfrom kimi_cli.ui.shell.console import console\nfrom kimi_cli.ui.shell.keyboard import KeyboardListener, KeyEvent\nfrom kimi_cli.utils.aioqueue import QueueShutDown\nfrom kimi_cli.utils.diff import format_unified_diff\nfrom kimi_cli.utils.logging import logger\nfrom kimi_cli.utils.message import message_stringify\nfrom kimi_cli.utils.rich.columns import BulletColumns\nfrom kimi_cli.utils.rich.markdown import Markdown\nfrom kimi_cli.utils.rich.syntax import KimiSyntax\nfrom kimi_cli.wire import WireUISide\nfrom kimi_cli.wire.types import (\n    ApprovalRequest,\n    ApprovalResponse,\n    BriefDisplayBlock,\n    CompactionBegin,\n    CompactionEnd,\n    ContentPart,\n    DiffDisplayBlock,\n    ShellDisplayBlock,\n    StatusUpdate,\n    StepBegin,\n    StepInterrupted,\n    SubagentEvent,\n    TextPart,\n    ThinkPart,\n    TodoDisplayBlock,\n    ToolCall,\n    ToolCallPart,\n    ToolCallRequest,\n    ToolResult,\n    ToolReturnValue,\n    TurnBegin,\n    TurnEnd,\n    WireMessage,\n)\n\nMAX_SUBAGENT_TOOL_CALLS_TO_SHOW = 4\n\n# Truncation limits for approval request display\nMAX_PREVIEW_LINES = 4\n\n\nasync def visualize(\n    wire: WireUISide,\n    *,\n    initial_status: StatusUpdate,\n    cancel_event: asyncio.Event | None = None,\n):\n    \"\"\"\n    A loop to consume agent events and visualize the agent behavior.\n\n    Args:\n        wire: Communication channel with the agent\n        initial_status: Initial status snapshot\n        cancel_event: Event that can be set (e.g., by ESC key) to cancel the run\n    \"\"\"\n    view = _LiveView(initial_status, cancel_event)\n    await view.visualize_loop(wire)\n\n\nclass _ContentBlock:\n    def __init__(self, is_think: bool):\n        self.is_think = is_think\n        self._spinner = Spinner(\"dots\", \"Thinking...\" if is_think else \"Composing...\")\n        self.raw_text = \"\"\n\n    def compose(self) -> RenderableType:\n        return self._spinner\n\n    def compose_final(self) -> RenderableType:\n        return BulletColumns(\n            Markdown(\n                self.raw_text,\n                style=\"grey50 italic\" if self.is_think else \"\",\n            ),\n            bullet_style=\"grey50\" if self.is_think else None,\n        )\n\n    def append(self, content: str) -> None:\n        self.raw_text += content\n\n\nclass _ToolCallBlock:\n    class FinishedSubCall(NamedTuple):\n        call: ToolCall\n        result: ToolReturnValue\n\n    def __init__(self, tool_call: ToolCall):\n        self._tool_name = tool_call.function.name\n        self._lexer = streamingjson.Lexer()\n        if tool_call.function.arguments is not None:\n            self._lexer.append_string(tool_call.function.arguments)\n\n        self._argument = extract_key_argument(self._lexer, self._tool_name)\n        self._result: ToolReturnValue | None = None\n\n        self._ongoing_subagent_tool_calls: dict[str, ToolCall] = {}\n        self._last_subagent_tool_call: ToolCall | None = None\n        self._n_finished_subagent_tool_calls = 0\n        self._finished_subagent_tool_calls = deque[_ToolCallBlock.FinishedSubCall](\n            maxlen=MAX_SUBAGENT_TOOL_CALLS_TO_SHOW\n        )\n\n        self._spinning_dots = Spinner(\"dots\", text=\"\")\n        self._renderable: RenderableType = self._compose()\n\n    def compose(self) -> RenderableType:\n        return self._renderable\n\n    @property\n    def finished(self) -> bool:\n        return self._result is not None\n\n    def append_args_part(self, args_part: str):\n        if self.finished:\n            return\n        self._lexer.append_string(args_part)\n        # TODO: maybe don't extract detail if it's already stable\n        argument = extract_key_argument(self._lexer, self._tool_name)\n        if argument and argument != self._argument:\n            self._argument = argument\n            self._renderable = BulletColumns(\n                Text.from_markup(self._get_headline_markup()),\n                bullet=self._spinning_dots,\n            )\n\n    def finish(self, result: ToolReturnValue):\n        self._result = result\n        self._renderable = self._compose()\n\n    def append_sub_tool_call(self, tool_call: ToolCall):\n        self._ongoing_subagent_tool_calls[tool_call.id] = tool_call\n        self._last_subagent_tool_call = tool_call\n\n    def append_sub_tool_call_part(self, tool_call_part: ToolCallPart):\n        if self._last_subagent_tool_call is None:\n            return\n        if not tool_call_part.arguments_part:\n            return\n        if self._last_subagent_tool_call.function.arguments is None:\n            self._last_subagent_tool_call.function.arguments = tool_call_part.arguments_part\n        else:\n            self._last_subagent_tool_call.function.arguments += tool_call_part.arguments_part\n\n    def finish_sub_tool_call(self, tool_result: ToolResult):\n        self._last_subagent_tool_call = None\n        sub_tool_call = self._ongoing_subagent_tool_calls.pop(tool_result.tool_call_id, None)\n        if sub_tool_call is None:\n            return\n\n        self._finished_subagent_tool_calls.append(\n            _ToolCallBlock.FinishedSubCall(\n                call=sub_tool_call,\n                result=tool_result.return_value,\n            )\n        )\n        self._n_finished_subagent_tool_calls += 1\n        self._renderable = self._compose()\n\n    def _compose(self) -> RenderableType:\n        lines: list[RenderableType] = [\n            Text.from_markup(self._get_headline_markup()),\n        ]\n\n        if self._n_finished_subagent_tool_calls > MAX_SUBAGENT_TOOL_CALLS_TO_SHOW:\n            n_hidden = self._n_finished_subagent_tool_calls - MAX_SUBAGENT_TOOL_CALLS_TO_SHOW\n            lines.append(\n                BulletColumns(\n                    Text(\n                        f\"{n_hidden} more tool call{'s' if n_hidden > 1 else ''} ...\",\n                        style=\"grey50 italic\",\n                    ),\n                    bullet_style=\"grey50\",\n                )\n            )\n        for sub_call, sub_result in self._finished_subagent_tool_calls:\n            argument = extract_key_argument(\n                sub_call.function.arguments or \"\", sub_call.function.name\n            )\n            lines.append(\n                BulletColumns(\n                    Text.from_markup(\n                        f\"Used [blue]{sub_call.function.name}[/blue]\"\n                        + (f\" [grey50]({argument})[/grey50]\" if argument else \"\")\n                    ),\n                    bullet_style=\"green\" if not sub_result.is_error else \"red\",\n                )\n            )\n\n        if self._result is not None:\n            for block in self._result.display:\n                if isinstance(block, BriefDisplayBlock):\n                    style = \"grey50\" if not self._result.is_error else \"red\"\n                    if block.text:\n                        lines.append(Markdown(block.text, style=style))\n                elif isinstance(block, TodoDisplayBlock):\n                    markdown = self._render_todo_markdown(block)\n                    if markdown:\n                        lines.append(Markdown(markdown, style=\"grey50\"))\n\n        if self.finished:\n            assert self._result is not None\n            return BulletColumns(\n                Group(*lines),\n                bullet_style=\"green\" if not self._result.is_error else \"red\",\n            )\n        else:\n            return BulletColumns(\n                Group(*lines),\n                bullet=self._spinning_dots,\n            )\n\n    def _get_headline_markup(self) -> str:\n        return f\"{'Used' if self.finished else 'Using'} [blue]{self._tool_name}[/blue]\" + (\n            f\" [grey50]({escape(self._argument)})[/grey50]\" if self._argument else \"\"\n        )\n\n    def _render_todo_markdown(self, block: TodoDisplayBlock) -> str:\n        lines: list[str] = []\n        for todo in block.items:\n            normalized = todo.status.replace(\"_\", \" \").lower()\n            match normalized:\n                case \"pending\":\n                    lines.append(f\"- {todo.title}\")\n                case \"in progress\":\n                    lines.append(f\"- {todo.title} ←\")\n                case \"done\":\n                    lines.append(f\"- ~~{todo.title}~~\")\n                case _:\n                    lines.append(f\"- {todo.title}\")\n        return \"\\n\".join(lines)\n\n\nclass _ApprovalContentBlock(NamedTuple):\n    \"\"\"A pre-rendered content block for approval request with line count.\"\"\"\n\n    text: str\n    lines: int\n    style: str = \"\"\n    lexer: str = \"\"\n\n\nclass _ApprovalRequestPanel:\n    def __init__(self, request: ApprovalRequest):\n        self.request = request\n        self.options: list[tuple[str, ApprovalResponse.Kind]] = [\n            (\"Approve once\", \"approve\"),\n            (\"Approve for this session\", \"approve_for_session\"),\n            (\"Reject, tell Kimi what to do instead\", \"reject\"),\n        ]\n        self.selected_index = 0\n\n        # Pre-render all content blocks with line counts\n        self._content_blocks: list[_ApprovalContentBlock] = []\n        last_diff_path: str | None = None\n\n        # Handle description (only if no display blocks)\n        if request.description and not request.display:\n            text = request.description.rstrip(\"\\n\")\n            self._content_blocks.append(\n                _ApprovalContentBlock(text=text, lines=text.count(\"\\n\") + 1)\n            )\n\n        # Handle display blocks\n        for block in request.display:\n            if isinstance(block, DiffDisplayBlock):\n                # File path or ellipsis\n                if block.path != last_diff_path:\n                    self._content_blocks.append(\n                        _ApprovalContentBlock(text=block.path, lines=1, style=\"bold\")\n                    )\n                    last_diff_path = block.path\n                else:\n                    self._content_blocks.append(\n                        _ApprovalContentBlock(text=\"⋮\", lines=1, style=\"dim\")\n                    )\n                # Diff content\n                diff_text = format_unified_diff(\n                    block.old_text,\n                    block.new_text,\n                    block.path,\n                    include_file_header=False,\n                ).rstrip(\"\\n\")\n                self._content_blocks.append(\n                    _ApprovalContentBlock(\n                        text=diff_text, lines=diff_text.count(\"\\n\") + 1, lexer=\"diff\"\n                    )\n                )\n            elif isinstance(block, ShellDisplayBlock):\n                text = block.command.rstrip(\"\\n\")\n                self._content_blocks.append(\n                    _ApprovalContentBlock(\n                        text=text, lines=text.count(\"\\n\") + 1, lexer=block.language\n                    )\n                )\n                last_diff_path = None\n            elif isinstance(block, BriefDisplayBlock) and block.text:\n                text = block.text.rstrip(\"\\n\")\n                self._content_blocks.append(\n                    _ApprovalContentBlock(text=text, lines=text.count(\"\\n\") + 1, style=\"grey50\")\n                )\n                last_diff_path = None\n\n        self._total_lines = sum(b.lines for b in self._content_blocks)\n        self.has_expandable_content = self._total_lines > MAX_PREVIEW_LINES\n\n    def render(self) -> RenderableType:\n        \"\"\"Render the approval menu as a panel.\"\"\"\n        content_lines: list[RenderableType] = [\n            Text.from_markup(\n                \"[yellow]⚠ \"\n                f\"{escape(self.request.sender)} is requesting approval to \"\n                f\"{escape(self.request.action)}:[/yellow]\"\n            )\n        ]\n        content_lines.append(Text(\"\"))\n\n        # Render content with line budget\n        remaining = MAX_PREVIEW_LINES\n        for block in self._content_blocks:\n            if remaining <= 0:\n                break\n            content_lines.append(self._render_block(block, remaining))\n            remaining -= min(block.lines, remaining)\n\n        if self.has_expandable_content:\n            content_lines.append(Text(\"... (truncated, ctrl-e to expand)\", style=\"dim italic\"))\n\n        lines: list[RenderableType] = []\n        if content_lines:\n            lines.append(Padding(Group(*content_lines), (0, 0, 0, 2)))\n\n        # Add menu options\n        if lines:\n            lines.append(Text(\"\"))\n        for i, (option_text, _) in enumerate(self.options):\n            if i == self.selected_index:\n                lines.append(Text(f\"→ {option_text}\", style=\"cyan\"))\n            else:\n                lines.append(Text(f\"  {option_text}\", style=\"grey50\"))\n\n        return Padding(Group(*lines), 1)\n\n    def _render_block(\n        self, block: _ApprovalContentBlock, max_lines: int | None = None\n    ) -> RenderableType:\n        \"\"\"Render a content block, optionally truncated.\"\"\"\n        text = block.text\n        if max_lines is not None and block.lines > max_lines:\n            # Truncate to max_lines\n            text = \"\\n\".join(text.split(\"\\n\")[:max_lines])\n\n        if block.lexer:\n            return KimiSyntax(text, block.lexer)\n        return Text(text, style=block.style)\n\n    def render_full(self) -> list[RenderableType]:\n        \"\"\"Render full content for pager (no truncation).\"\"\"\n        return [self._render_block(block) for block in self._content_blocks]\n\n    def move_up(self):\n        \"\"\"Move selection up.\"\"\"\n        self.selected_index = (self.selected_index - 1) % len(self.options)\n\n    def move_down(self):\n        \"\"\"Move selection down.\"\"\"\n        self.selected_index = (self.selected_index + 1) % len(self.options)\n\n    def get_selected_response(self) -> ApprovalResponse.Kind:\n        \"\"\"Get the approval response based on selected option.\"\"\"\n        return self.options[self.selected_index][1]\n\n\ndef _show_approval_in_pager(panel: _ApprovalRequestPanel) -> None:\n    \"\"\"Show the full approval request content in a pager.\"\"\"\n    with console.screen(), console.pager(styles=True):\n        # Header: matches the style in _ApprovalRequestPanel.render()\n        console.print(\n            Text.from_markup(\n                \"[yellow]⚠ \"\n                f\"{escape(panel.request.sender)} is requesting approval to \"\n                f\"{escape(panel.request.action)}:[/yellow]\"\n            )\n        )\n        console.print()\n\n        # Render full content (no truncation)\n        for renderable in panel.render_full():\n            console.print(renderable)\n\n\nclass _StatusBlock:\n    def __init__(self, initial: StatusUpdate) -> None:\n        self.text = Text(\"\", justify=\"right\")\n        self.update(initial)\n\n    def render(self) -> RenderableType:\n        return self.text\n\n    def update(self, status: StatusUpdate) -> None:\n        if status.context_usage is not None:\n            self.text.plain = f\"context: {status.context_usage:.1%}\"\n\n\n@asynccontextmanager\nasync def _keyboard_listener(\n    handler: Callable[[KeyboardListener, KeyEvent], Awaitable[None]],\n):\n    listener = KeyboardListener()\n    await listener.start()\n\n    async def _keyboard():\n        while True:\n            event = await listener.get()\n            await handler(listener, event)\n\n    task = asyncio.create_task(_keyboard())\n    try:\n        yield\n    finally:\n        task.cancel()\n        with suppress(asyncio.CancelledError):\n            await task\n        await listener.stop()\n\n\nclass _LiveView:\n    def __init__(self, initial_status: StatusUpdate, cancel_event: asyncio.Event | None = None):\n        self._cancel_event = cancel_event\n\n        self._mooning_spinner: Spinner | None = None\n        self._compacting_spinner: Spinner | None = None\n\n        self._current_content_block: _ContentBlock | None = None\n        self._tool_call_blocks: dict[str, _ToolCallBlock] = {}\n        self._last_tool_call_block: _ToolCallBlock | None = None\n        self._approval_request_queue = deque[ApprovalRequest]()\n        \"\"\"\n        It is possible that multiple subagents request approvals at the same time,\n        in which case we will have to queue them up and show them one by one.\n        \"\"\"\n        self._current_approval_request_panel: _ApprovalRequestPanel | None = None\n        self._reject_all_following = False\n        self._status_block = _StatusBlock(initial_status)\n\n        self._need_recompose = False\n\n    def _reset_live_shape(self, live: Live) -> None:\n        # Rich doesn't expose a public API to clear Live's cached render height.\n        # After leaving the pager, stale height causes cursor restores to jump,\n        # so we reset the private _shape to re-anchor the next refresh.\n        live._live_render._shape = None  # type: ignore[reportPrivateUsage]\n\n    async def visualize_loop(self, wire: WireUISide):\n        with Live(\n            self.compose(),\n            console=console,\n            refresh_per_second=10,\n            transient=True,\n            vertical_overflow=\"visible\",\n        ) as live:\n\n            async def keyboard_handler(listener: KeyboardListener, event: KeyEvent) -> None:\n                # Handle Ctrl+E specially - pause Live while the pager is active\n                if event == KeyEvent.CTRL_E:\n                    if (\n                        self._current_approval_request_panel\n                        and self._current_approval_request_panel.has_expandable_content\n                    ):\n                        await listener.pause()\n                        live.stop()\n                        try:\n                            _show_approval_in_pager(self._current_approval_request_panel)\n                        finally:\n                            # Reset live render shape so the next refresh re-anchors cleanly.\n                            self._reset_live_shape(live)\n                            live.start()\n                            live.update(self.compose(), refresh=True)\n                            await listener.resume()\n                    return\n\n                self.dispatch_keyboard_event(event)\n                if self._need_recompose:\n                    live.update(self.compose(), refresh=True)\n                    self._need_recompose = False\n\n            async with _keyboard_listener(keyboard_handler):\n                while True:\n                    try:\n                        msg = await wire.receive()\n                    except QueueShutDown:\n                        self.cleanup(is_interrupt=False)\n                        live.update(self.compose(), refresh=True)\n                        break\n\n                    if isinstance(msg, StepInterrupted):\n                        self.cleanup(is_interrupt=True)\n                        live.update(self.compose(), refresh=True)\n                        break\n\n                    self.dispatch_wire_message(msg)\n                    if self._need_recompose:\n                        live.update(self.compose(), refresh=True)\n                        self._need_recompose = False\n\n    def refresh_soon(self) -> None:\n        self._need_recompose = True\n\n    def compose(self) -> RenderableType:\n        \"\"\"Compose the live view display content.\"\"\"\n        blocks: list[RenderableType] = []\n        if self._mooning_spinner is not None:\n            blocks.append(self._mooning_spinner)\n        elif self._compacting_spinner is not None:\n            blocks.append(self._compacting_spinner)\n        else:\n            if self._current_content_block is not None:\n                blocks.append(self._current_content_block.compose())\n            for tool_call in self._tool_call_blocks.values():\n                blocks.append(tool_call.compose())\n        if self._current_approval_request_panel:\n            blocks.append(self._current_approval_request_panel.render())\n        blocks.append(self._status_block.render())\n        return Group(*blocks)\n\n    def dispatch_wire_message(self, msg: WireMessage) -> None:\n        \"\"\"Dispatch the Wire message to UI components.\"\"\"\n        assert not isinstance(msg, StepInterrupted)  # handled in visualize_loop\n\n        if isinstance(msg, StepBegin):\n            self.cleanup(is_interrupt=False)\n            self._mooning_spinner = Spinner(\"moon\", \"\")\n            self.refresh_soon()\n            return\n\n        if self._mooning_spinner is not None:\n            # any message other than StepBegin should end the mooning state\n            self._mooning_spinner = None\n            self.refresh_soon()\n\n        match msg:\n            case TurnBegin():\n                self.flush_content()\n                console.print(\n                    Panel(\n                        Text(message_stringify(Message(role=\"user\", content=msg.user_input))),\n                        padding=(0, 1),\n                    )\n                )\n            case TurnEnd():\n                pass\n            case CompactionBegin():\n                self._compacting_spinner = Spinner(\"balloon\", \"Compacting...\")\n                self.refresh_soon()\n            case CompactionEnd():\n                self._compacting_spinner = None\n                self.refresh_soon()\n            case StatusUpdate():\n                self._status_block.update(msg)\n            case ContentPart():\n                self.append_content(msg)\n            case ToolCall():\n                self.append_tool_call(msg)\n            case ToolCallPart():\n                self.append_tool_call_part(msg)\n            case ToolResult():\n                self.append_tool_result(msg)\n            case ApprovalResponse():\n                # we don't need to handle this because the request is resolved on UI\n                pass\n            case SubagentEvent():\n                self.handle_subagent_event(msg)\n            case ApprovalRequest():\n                self.request_approval(msg)\n            case ToolCallRequest():\n                logger.warning(\"Unexpected ToolCallRequest in shell UI: {msg}\", msg=msg)\n\n    def dispatch_keyboard_event(self, event: KeyEvent) -> None:\n        # handle ESC key to cancel the run\n        if event == KeyEvent.ESCAPE and self._cancel_event is not None:\n            self._cancel_event.set()\n            return\n\n        if not self._current_approval_request_panel:\n            # just ignore any keyboard event when there's no approval request\n            return\n\n        match event:\n            case KeyEvent.UP:\n                self._current_approval_request_panel.move_up()\n                self.refresh_soon()\n            case KeyEvent.DOWN:\n                self._current_approval_request_panel.move_down()\n                self.refresh_soon()\n            case KeyEvent.ENTER:\n                resp = self._current_approval_request_panel.get_selected_response()\n                self._current_approval_request_panel.request.resolve(resp)\n                if resp == \"approve_for_session\":\n                    to_remove_from_queue: list[ApprovalRequest] = []\n                    for request in self._approval_request_queue:\n                        # approve all queued requests with the same action\n                        if request.action == self._current_approval_request_panel.request.action:\n                            request.resolve(\"approve_for_session\")\n                            to_remove_from_queue.append(request)\n                    for request in to_remove_from_queue:\n                        self._approval_request_queue.remove(request)\n                elif resp == \"reject\":\n                    # one rejection should stop the step immediately\n                    while self._approval_request_queue:\n                        self._approval_request_queue.popleft().resolve(\"reject\")\n                    self._reject_all_following = True\n                self.show_next_approval_request()\n            case _:\n                # just ignore any other keyboard event\n                return\n\n    def cleanup(self, is_interrupt: bool) -> None:\n        \"\"\"Cleanup the live view on step end or interruption.\"\"\"\n        self.flush_content()\n\n        for block in self._tool_call_blocks.values():\n            if not block.finished:\n                # this should not happen, but just in case\n                block.finish(\n                    ToolError(message=\"\", brief=\"Interrupted\")\n                    if is_interrupt\n                    else ToolOk(output=\"\")\n                )\n        self._last_tool_call_block = None\n        self.flush_finished_tool_calls()\n\n        while self._approval_request_queue:\n            # should not happen, but just in case\n            self._approval_request_queue.popleft().resolve(\"reject\")\n        self._current_approval_request_panel = None\n        self._reject_all_following = False\n\n    def flush_content(self) -> None:\n        \"\"\"Flush the current content block.\"\"\"\n        if self._current_content_block is not None:\n            console.print(self._current_content_block.compose_final())\n            self._current_content_block = None\n            self.refresh_soon()\n\n    def flush_finished_tool_calls(self) -> None:\n        \"\"\"Flush all leading finished tool call blocks.\"\"\"\n        tool_call_ids = list(self._tool_call_blocks.keys())\n        for tool_call_id in tool_call_ids:\n            block = self._tool_call_blocks[tool_call_id]\n            if not block.finished:\n                break\n\n            self._tool_call_blocks.pop(tool_call_id)\n            console.print(block.compose())\n            if self._last_tool_call_block == block:\n                self._last_tool_call_block = None\n            self.refresh_soon()\n\n    def append_content(self, part: ContentPart) -> None:\n        match part:\n            case ThinkPart(think=text) | TextPart(text=text):\n                if not text:\n                    return\n                is_think = isinstance(part, ThinkPart)\n                if self._current_content_block is None:\n                    self._current_content_block = _ContentBlock(is_think)\n                    self.refresh_soon()\n                elif self._current_content_block.is_think != is_think:\n                    self.flush_content()\n                    self._current_content_block = _ContentBlock(is_think)\n                    self.refresh_soon()\n                self._current_content_block.append(text)\n            case _:\n                # TODO: support more content part types\n                pass\n\n    def append_tool_call(self, tool_call: ToolCall) -> None:\n        self.flush_content()\n        self._tool_call_blocks[tool_call.id] = _ToolCallBlock(tool_call)\n        self._last_tool_call_block = self._tool_call_blocks[tool_call.id]\n        self.refresh_soon()\n\n    def append_tool_call_part(self, part: ToolCallPart) -> None:\n        if not part.arguments_part:\n            return\n        if self._last_tool_call_block is None:\n            return\n        self._last_tool_call_block.append_args_part(part.arguments_part)\n        self.refresh_soon()\n\n    def append_tool_result(self, result: ToolResult) -> None:\n        if block := self._tool_call_blocks.get(result.tool_call_id):\n            block.finish(result.return_value)\n            self.flush_finished_tool_calls()\n            self.refresh_soon()\n\n    def request_approval(self, request: ApprovalRequest) -> None:\n        # If we're rejecting all following requests, reject immediately\n        if self._reject_all_following:\n            request.resolve(\"reject\")\n            return\n\n        self._approval_request_queue.append(request)\n\n        if self._current_approval_request_panel is None:\n            console.bell()\n            self.show_next_approval_request()\n\n    def show_next_approval_request(self) -> None:\n        \"\"\"\n        Show the next approval request from the queue.\n        If there are no pending requests, clear the current approval panel.\n        \"\"\"\n        if not self._approval_request_queue:\n            if self._current_approval_request_panel is not None:\n                self._current_approval_request_panel = None\n                self.refresh_soon()\n            return\n\n        while self._approval_request_queue:\n            request = self._approval_request_queue.popleft()\n            if request.resolved:\n                # skip resolved requests\n                continue\n            self._current_approval_request_panel = _ApprovalRequestPanel(request)\n            self.refresh_soon()\n            break\n\n    def handle_subagent_event(self, event: SubagentEvent) -> None:\n        block = self._tool_call_blocks.get(event.task_tool_call_id)\n        if block is None:\n            return\n\n        match event.event:\n            case ToolCall() as tool_call:\n                block.append_sub_tool_call(tool_call)\n            case ToolCallPart() as tool_call_part:\n                block.append_sub_tool_call_part(tool_call_part)\n            case ToolResult() as tool_result:\n                block.finish_sub_tool_call(tool_result)\n                self.refresh_soon()\n            case _:\n                # ignore other events for now\n                # TODO: may need to handle multi-level nested subagents\n                pass\n","structuredPatch":[{"oldStart":107,"oldLines":6,"newStart":107,"newLines":25,"lines":["         call: ToolCall","         result: ToolReturnValue"," ","+    @staticmethod","+    def _extract_full_url(","+        json_content: str | streamingjson.Lexer, tool_name: str","+    ) -> str | None:","+        if tool_name != \"FetchURL\":","+            return None","+        json_str = (","+            json_content.complete_json()","+            if isinstance(json_content, streamingjson.Lexer)","+            else json_content","+        )","+        try:","+            args = json.loads(json_str)","+        except (json.JSONDecodeError, ValueError):","+            return None","+        if isinstance(args, dict) and args.get(\"url\"):","+            return str(args[\"url\"])","+        return None","+","     def __init__(self, tool_call: ToolCall):","         self._tool_name = tool_call.function.name","         self._lexer = streamingjson.Lexer()"]},{"oldStart":114,"oldLines":6,"newStart":133,"newLines":7,"lines":["             self._lexer.append_string(tool_call.function.arguments)"," ","         self._argument = extract_key_argument(self._lexer, self._tool_name)","+        self._full_url = self._extract_full_url(self._lexer, self._tool_name)","         self._result: ToolReturnValue | None = None"," ","         self._ongoing_subagent_tool_calls: dict[str, ToolCall] = {}"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"daf232f5-34d2-4308-964a-79794e46e94d"}
{"parentUuid":"1afbb722-3235-436f-95f2-e626ead11240","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_01LMedLPAt8gAjBgdmUhUmX9","type":"message","role":"assistant","content":[{"type":"text","text":"**Step 3: Update `append_args_part` to sync `_full_url`**"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":656,"cache_read_input_tokens":33706,"cache_creation":{"ephemeral_5m_input_tokens":656,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"type":"assistant","uuid":"d19da7ff-e472-4573-a69f-0b9ffa19a8df","timestamp":"2026-02-25T08:05:28.150Z"}
{"parentUuid":"d19da7ff-e472-4573-a69f-0b9ffa19a8df","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_01LMedLPAt8gAjBgdmUhUmX9","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01H9mx8Sw5Z7qfsnCFFCcTTu","name":"Edit","input":{"replace_all":false,"file_path":"/Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/ui/shell/visualize.py","old_string":"    def append_args_part(self, args_part: str):\n        if self.finished:\n            return\n        self._lexer.append_string(args_part)\n        # TODO: maybe don't extract detail if it's already stable\n        argument = extract_key_argument(self._lexer, self._tool_name)\n        if argument and argument != self._argument:\n            self._argument = argument\n            self._renderable = BulletColumns(\n                Text.from_markup(self._get_headline_markup()),\n                bullet=self._spinning_dots,\n            )","new_string":"    def append_args_part(self, args_part: str):\n        if self.finished:\n            return\n        self._lexer.append_string(args_part)\n        # TODO: maybe don't extract detail if it's already stable\n        argument = extract_key_argument(self._lexer, self._tool_name)\n        if argument and argument != self._argument:\n            self._argument = argument\n            self._full_url = self._extract_full_url(self._lexer, self._tool_name)\n            self._renderable = BulletColumns(\n                self._build_headline_text(),\n                bullet=self._spinning_dots,\n            )"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":656,"cache_read_input_tokens":33706,"output_tokens":456,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":656},"inference_geo":"","iterations":[],"speed":"standard"}},"type":"assistant","uuid":"52019f94-ea87-40a8-8149-a964475df6c7","timestamp":"2026-02-25T08:05:32.376Z"}
{"parentUuid":"52019f94-ea87-40a8-8149-a964475df6c7","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01H9mx8Sw5Z7qfsnCFFCcTTu","toolUseID":"toolu_01H9mx8Sw5Z7qfsnCFFCcTTu","timestamp":"2026-02-25T08:05:32.407Z","uuid":"9c95dd23-cf44-48ce-996f-3c4075a1c4a8"}
{"parentUuid":"52019f94-ea87-40a8-8149-a964475df6c7","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01H9mx8Sw5Z7qfsnCFFCcTTu","type":"tool_result","content":"The file /Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/ui/shell/visualize.py has been updated successfully."}]},"uuid":"a421b1bd-47ee-4110-ba93-6b80bcd1931f","timestamp":"2026-02-25T08:05:32.406Z","toolUseResult":{"filePath":"/Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/ui/shell/visualize.py","oldString":"    def append_args_part(self, args_part: str):\n        if self.finished:\n            return\n        self._lexer.append_string(args_part)\n        # TODO: maybe don't extract detail if it's already stable\n        argument = extract_key_argument(self._lexer, self._tool_name)\n        if argument and argument != self._argument:\n            self._argument = argument\n            self._renderable = BulletColumns(\n                Text.from_markup(self._get_headline_markup()),\n                bullet=self._spinning_dots,\n            )","newString":"    def append_args_part(self, args_part: str):\n        if self.finished:\n            return\n        self._lexer.append_string(args_part)\n        # TODO: maybe don't extract detail if it's already stable\n        argument = extract_key_argument(self._lexer, self._tool_name)\n        if argument and argument != self._argument:\n            self._argument = argument\n            self._full_url = self._extract_full_url(self._lexer, self._tool_name)\n            self._renderable = BulletColumns(\n                self._build_headline_text(),\n                bullet=self._spinning_dots,\n            )","originalFile":"from __future__ import annotations\n\nimport asyncio\nimport json\nfrom collections import deque\nfrom collections.abc import Awaitable, Callable\nfrom contextlib import asynccontextmanager, suppress\nfrom typing import NamedTuple\n\nimport streamingjson  # type: ignore[reportMissingTypeStubs]\nfrom kosong.message import Message\nfrom kosong.tooling import ToolError, ToolOk\nfrom rich.console import Group, RenderableType\nfrom rich.live import Live\nfrom rich.markup import escape\nfrom rich.padding import Padding\nfrom rich.panel import Panel\nfrom rich.spinner import Spinner\nfrom rich.style import Style\nfrom rich.text import Text\n\nfrom kimi_cli.tools import extract_key_argument\nfrom kimi_cli.ui.shell.console import console\nfrom kimi_cli.ui.shell.keyboard import KeyboardListener, KeyEvent\nfrom kimi_cli.utils.aioqueue import QueueShutDown\nfrom kimi_cli.utils.diff import format_unified_diff\nfrom kimi_cli.utils.logging import logger\nfrom kimi_cli.utils.message import message_stringify\nfrom kimi_cli.utils.rich.columns import BulletColumns\nfrom kimi_cli.utils.rich.markdown import Markdown\nfrom kimi_cli.utils.rich.syntax import KimiSyntax\nfrom kimi_cli.wire import WireUISide\nfrom kimi_cli.wire.types import (\n    ApprovalRequest,\n    ApprovalResponse,\n    BriefDisplayBlock,\n    CompactionBegin,\n    CompactionEnd,\n    ContentPart,\n    DiffDisplayBlock,\n    ShellDisplayBlock,\n    StatusUpdate,\n    StepBegin,\n    StepInterrupted,\n    SubagentEvent,\n    TextPart,\n    ThinkPart,\n    TodoDisplayBlock,\n    ToolCall,\n    ToolCallPart,\n    ToolCallRequest,\n    ToolResult,\n    ToolReturnValue,\n    TurnBegin,\n    TurnEnd,\n    WireMessage,\n)\n\nMAX_SUBAGENT_TOOL_CALLS_TO_SHOW = 4\n\n# Truncation limits for approval request display\nMAX_PREVIEW_LINES = 4\n\n\nasync def visualize(\n    wire: WireUISide,\n    *,\n    initial_status: StatusUpdate,\n    cancel_event: asyncio.Event | None = None,\n):\n    \"\"\"\n    A loop to consume agent events and visualize the agent behavior.\n\n    Args:\n        wire: Communication channel with the agent\n        initial_status: Initial status snapshot\n        cancel_event: Event that can be set (e.g., by ESC key) to cancel the run\n    \"\"\"\n    view = _LiveView(initial_status, cancel_event)\n    await view.visualize_loop(wire)\n\n\nclass _ContentBlock:\n    def __init__(self, is_think: bool):\n        self.is_think = is_think\n        self._spinner = Spinner(\"dots\", \"Thinking...\" if is_think else \"Composing...\")\n        self.raw_text = \"\"\n\n    def compose(self) -> RenderableType:\n        return self._spinner\n\n    def compose_final(self) -> RenderableType:\n        return BulletColumns(\n            Markdown(\n                self.raw_text,\n                style=\"grey50 italic\" if self.is_think else \"\",\n            ),\n            bullet_style=\"grey50\" if self.is_think else None,\n        )\n\n    def append(self, content: str) -> None:\n        self.raw_text += content\n\n\nclass _ToolCallBlock:\n    class FinishedSubCall(NamedTuple):\n        call: ToolCall\n        result: ToolReturnValue\n\n    @staticmethod\n    def _extract_full_url(\n        json_content: str | streamingjson.Lexer, tool_name: str\n    ) -> str | None:\n        if tool_name != \"FetchURL\":\n            return None\n        json_str = (\n            json_content.complete_json()\n            if isinstance(json_content, streamingjson.Lexer)\n            else json_content\n        )\n        try:\n            args = json.loads(json_str)\n        except (json.JSONDecodeError, ValueError):\n            return None\n        if isinstance(args, dict) and args.get(\"url\"):\n            return str(args[\"url\"])\n        return None\n\n    def __init__(self, tool_call: ToolCall):\n        self._tool_name = tool_call.function.name\n        self._lexer = streamingjson.Lexer()\n        if tool_call.function.arguments is not None:\n            self._lexer.append_string(tool_call.function.arguments)\n\n        self._argument = extract_key_argument(self._lexer, self._tool_name)\n        self._full_url = self._extract_full_url(self._lexer, self._tool_name)\n        self._result: ToolReturnValue | None = None\n\n        self._ongoing_subagent_tool_calls: dict[str, ToolCall] = {}\n        self._last_subagent_tool_call: ToolCall | None = None\n        self._n_finished_subagent_tool_calls = 0\n        self._finished_subagent_tool_calls = deque[_ToolCallBlock.FinishedSubCall](\n            maxlen=MAX_SUBAGENT_TOOL_CALLS_TO_SHOW\n        )\n\n        self._spinning_dots = Spinner(\"dots\", text=\"\")\n        self._renderable: RenderableType = self._compose()\n\n    def compose(self) -> RenderableType:\n        return self._renderable\n\n    @property\n    def finished(self) -> bool:\n        return self._result is not None\n\n    def append_args_part(self, args_part: str):\n        if self.finished:\n            return\n        self._lexer.append_string(args_part)\n        # TODO: maybe don't extract detail if it's already stable\n        argument = extract_key_argument(self._lexer, self._tool_name)\n        if argument and argument != self._argument:\n            self._argument = argument\n            self._renderable = BulletColumns(\n                Text.from_markup(self._get_headline_markup()),\n                bullet=self._spinning_dots,\n            )\n\n    def finish(self, result: ToolReturnValue):\n        self._result = result\n        self._renderable = self._compose()\n\n    def append_sub_tool_call(self, tool_call: ToolCall):\n        self._ongoing_subagent_tool_calls[tool_call.id] = tool_call\n        self._last_subagent_tool_call = tool_call\n\n    def append_sub_tool_call_part(self, tool_call_part: ToolCallPart):\n        if self._last_subagent_tool_call is None:\n            return\n        if not tool_call_part.arguments_part:\n            return\n        if self._last_subagent_tool_call.function.arguments is None:\n            self._last_subagent_tool_call.function.arguments = tool_call_part.arguments_part\n        else:\n            self._last_subagent_tool_call.function.arguments += tool_call_part.arguments_part\n\n    def finish_sub_tool_call(self, tool_result: ToolResult):\n        self._last_subagent_tool_call = None\n        sub_tool_call = self._ongoing_subagent_tool_calls.pop(tool_result.tool_call_id, None)\n        if sub_tool_call is None:\n            return\n\n        self._finished_subagent_tool_calls.append(\n            _ToolCallBlock.FinishedSubCall(\n                call=sub_tool_call,\n                result=tool_result.return_value,\n            )\n        )\n        self._n_finished_subagent_tool_calls += 1\n        self._renderable = self._compose()\n\n    def _compose(self) -> RenderableType:\n        lines: list[RenderableType] = [\n            Text.from_markup(self._get_headline_markup()),\n        ]\n\n        if self._n_finished_subagent_tool_calls > MAX_SUBAGENT_TOOL_CALLS_TO_SHOW:\n            n_hidden = self._n_finished_subagent_tool_calls - MAX_SUBAGENT_TOOL_CALLS_TO_SHOW\n            lines.append(\n                BulletColumns(\n                    Text(\n                        f\"{n_hidden} more tool call{'s' if n_hidden > 1 else ''} ...\",\n                        style=\"grey50 italic\",\n                    ),\n                    bullet_style=\"grey50\",\n                )\n            )\n        for sub_call, sub_result in self._finished_subagent_tool_calls:\n            argument = extract_key_argument(\n                sub_call.function.arguments or \"\", sub_call.function.name\n            )\n            lines.append(\n                BulletColumns(\n                    Text.from_markup(\n                        f\"Used [blue]{sub_call.function.name}[/blue]\"\n                        + (f\" [grey50]({argument})[/grey50]\" if argument else \"\")\n                    ),\n                    bullet_style=\"green\" if not sub_result.is_error else \"red\",\n                )\n            )\n\n        if self._result is not None:\n            for block in self._result.display:\n                if isinstance(block, BriefDisplayBlock):\n                    style = \"grey50\" if not self._result.is_error else \"red\"\n                    if block.text:\n                        lines.append(Markdown(block.text, style=style))\n                elif isinstance(block, TodoDisplayBlock):\n                    markdown = self._render_todo_markdown(block)\n                    if markdown:\n                        lines.append(Markdown(markdown, style=\"grey50\"))\n\n        if self.finished:\n            assert self._result is not None\n            return BulletColumns(\n                Group(*lines),\n                bullet_style=\"green\" if not self._result.is_error else \"red\",\n            )\n        else:\n            return BulletColumns(\n                Group(*lines),\n                bullet=self._spinning_dots,\n            )\n\n    def _get_headline_markup(self) -> str:\n        return f\"{'Used' if self.finished else 'Using'} [blue]{self._tool_name}[/blue]\" + (\n            f\" [grey50]({escape(self._argument)})[/grey50]\" if self._argument else \"\"\n        )\n\n    def _render_todo_markdown(self, block: TodoDisplayBlock) -> str:\n        lines: list[str] = []\n        for todo in block.items:\n            normalized = todo.status.replace(\"_\", \" \").lower()\n            match normalized:\n                case \"pending\":\n                    lines.append(f\"- {todo.title}\")\n                case \"in progress\":\n                    lines.append(f\"- {todo.title} ←\")\n                case \"done\":\n                    lines.append(f\"- ~~{todo.title}~~\")\n                case _:\n                    lines.append(f\"- {todo.title}\")\n        return \"\\n\".join(lines)\n\n\nclass _ApprovalContentBlock(NamedTuple):\n    \"\"\"A pre-rendered content block for approval request with line count.\"\"\"\n\n    text: str\n    lines: int\n    style: str = \"\"\n    lexer: str = \"\"\n\n\nclass _ApprovalRequestPanel:\n    def __init__(self, request: ApprovalRequest):\n        self.request = request\n        self.options: list[tuple[str, ApprovalResponse.Kind]] = [\n            (\"Approve once\", \"approve\"),\n            (\"Approve for this session\", \"approve_for_session\"),\n            (\"Reject, tell Kimi what to do instead\", \"reject\"),\n        ]\n        self.selected_index = 0\n\n        # Pre-render all content blocks with line counts\n        self._content_blocks: list[_ApprovalContentBlock] = []\n        last_diff_path: str | None = None\n\n        # Handle description (only if no display blocks)\n        if request.description and not request.display:\n            text = request.description.rstrip(\"\\n\")\n            self._content_blocks.append(\n                _ApprovalContentBlock(text=text, lines=text.count(\"\\n\") + 1)\n            )\n\n        # Handle display blocks\n        for block in request.display:\n            if isinstance(block, DiffDisplayBlock):\n                # File path or ellipsis\n                if block.path != last_diff_path:\n                    self._content_blocks.append(\n                        _ApprovalContentBlock(text=block.path, lines=1, style=\"bold\")\n                    )\n                    last_diff_path = block.path\n                else:\n                    self._content_blocks.append(\n                        _ApprovalContentBlock(text=\"⋮\", lines=1, style=\"dim\")\n                    )\n                # Diff content\n                diff_text = format_unified_diff(\n                    block.old_text,\n                    block.new_text,\n                    block.path,\n                    include_file_header=False,\n                ).rstrip(\"\\n\")\n                self._content_blocks.append(\n                    _ApprovalContentBlock(\n                        text=diff_text, lines=diff_text.count(\"\\n\") + 1, lexer=\"diff\"\n                    )\n                )\n            elif isinstance(block, ShellDisplayBlock):\n                text = block.command.rstrip(\"\\n\")\n                self._content_blocks.append(\n                    _ApprovalContentBlock(\n                        text=text, lines=text.count(\"\\n\") + 1, lexer=block.language\n                    )\n                )\n                last_diff_path = None\n            elif isinstance(block, BriefDisplayBlock) and block.text:\n                text = block.text.rstrip(\"\\n\")\n                self._content_blocks.append(\n                    _ApprovalContentBlock(text=text, lines=text.count(\"\\n\") + 1, style=\"grey50\")\n                )\n                last_diff_path = None\n\n        self._total_lines = sum(b.lines for b in self._content_blocks)\n        self.has_expandable_content = self._total_lines > MAX_PREVIEW_LINES\n\n    def render(self) -> RenderableType:\n        \"\"\"Render the approval menu as a panel.\"\"\"\n        content_lines: list[RenderableType] = [\n            Text.from_markup(\n                \"[yellow]⚠ \"\n                f\"{escape(self.request.sender)} is requesting approval to \"\n                f\"{escape(self.request.action)}:[/yellow]\"\n            )\n        ]\n        content_lines.append(Text(\"\"))\n\n        # Render content with line budget\n        remaining = MAX_PREVIEW_LINES\n        for block in self._content_blocks:\n            if remaining <= 0:\n                break\n            content_lines.append(self._render_block(block, remaining))\n            remaining -= min(block.lines, remaining)\n\n        if self.has_expandable_content:\n            content_lines.append(Text(\"... (truncated, ctrl-e to expand)\", style=\"dim italic\"))\n\n        lines: list[RenderableType] = []\n        if content_lines:\n            lines.append(Padding(Group(*content_lines), (0, 0, 0, 2)))\n\n        # Add menu options\n        if lines:\n            lines.append(Text(\"\"))\n        for i, (option_text, _) in enumerate(self.options):\n            if i == self.selected_index:\n                lines.append(Text(f\"→ {option_text}\", style=\"cyan\"))\n            else:\n                lines.append(Text(f\"  {option_text}\", style=\"grey50\"))\n\n        return Padding(Group(*lines), 1)\n\n    def _render_block(\n        self, block: _ApprovalContentBlock, max_lines: int | None = None\n    ) -> RenderableType:\n        \"\"\"Render a content block, optionally truncated.\"\"\"\n        text = block.text\n        if max_lines is not None and block.lines > max_lines:\n            # Truncate to max_lines\n            text = \"\\n\".join(text.split(\"\\n\")[:max_lines])\n\n        if block.lexer:\n            return KimiSyntax(text, block.lexer)\n        return Text(text, style=block.style)\n\n    def render_full(self) -> list[RenderableType]:\n        \"\"\"Render full content for pager (no truncation).\"\"\"\n        return [self._render_block(block) for block in self._content_blocks]\n\n    def move_up(self):\n        \"\"\"Move selection up.\"\"\"\n        self.selected_index = (self.selected_index - 1) % len(self.options)\n\n    def move_down(self):\n        \"\"\"Move selection down.\"\"\"\n        self.selected_index = (self.selected_index + 1) % len(self.options)\n\n    def get_selected_response(self) -> ApprovalResponse.Kind:\n        \"\"\"Get the approval response based on selected option.\"\"\"\n        return self.options[self.selected_index][1]\n\n\ndef _show_approval_in_pager(panel: _ApprovalRequestPanel) -> None:\n    \"\"\"Show the full approval request content in a pager.\"\"\"\n    with console.screen(), console.pager(styles=True):\n        # Header: matches the style in _ApprovalRequestPanel.render()\n        console.print(\n            Text.from_markup(\n                \"[yellow]⚠ \"\n                f\"{escape(panel.request.sender)} is requesting approval to \"\n                f\"{escape(panel.request.action)}:[/yellow]\"\n            )\n        )\n        console.print()\n\n        # Render full content (no truncation)\n        for renderable in panel.render_full():\n            console.print(renderable)\n\n\nclass _StatusBlock:\n    def __init__(self, initial: StatusUpdate) -> None:\n        self.text = Text(\"\", justify=\"right\")\n        self.update(initial)\n\n    def render(self) -> RenderableType:\n        return self.text\n\n    def update(self, status: StatusUpdate) -> None:\n        if status.context_usage is not None:\n            self.text.plain = f\"context: {status.context_usage:.1%}\"\n\n\n@asynccontextmanager\nasync def _keyboard_listener(\n    handler: Callable[[KeyboardListener, KeyEvent], Awaitable[None]],\n):\n    listener = KeyboardListener()\n    await listener.start()\n\n    async def _keyboard():\n        while True:\n            event = await listener.get()\n            await handler(listener, event)\n\n    task = asyncio.create_task(_keyboard())\n    try:\n        yield\n    finally:\n        task.cancel()\n        with suppress(asyncio.CancelledError):\n            await task\n        await listener.stop()\n\n\nclass _LiveView:\n    def __init__(self, initial_status: StatusUpdate, cancel_event: asyncio.Event | None = None):\n        self._cancel_event = cancel_event\n\n        self._mooning_spinner: Spinner | None = None\n        self._compacting_spinner: Spinner | None = None\n\n        self._current_content_block: _ContentBlock | None = None\n        self._tool_call_blocks: dict[str, _ToolCallBlock] = {}\n        self._last_tool_call_block: _ToolCallBlock | None = None\n        self._approval_request_queue = deque[ApprovalRequest]()\n        \"\"\"\n        It is possible that multiple subagents request approvals at the same time,\n        in which case we will have to queue them up and show them one by one.\n        \"\"\"\n        self._current_approval_request_panel: _ApprovalRequestPanel | None = None\n        self._reject_all_following = False\n        self._status_block = _StatusBlock(initial_status)\n\n        self._need_recompose = False\n\n    def _reset_live_shape(self, live: Live) -> None:\n        # Rich doesn't expose a public API to clear Live's cached render height.\n        # After leaving the pager, stale height causes cursor restores to jump,\n        # so we reset the private _shape to re-anchor the next refresh.\n        live._live_render._shape = None  # type: ignore[reportPrivateUsage]\n\n    async def visualize_loop(self, wire: WireUISide):\n        with Live(\n            self.compose(),\n            console=console,\n            refresh_per_second=10,\n            transient=True,\n            vertical_overflow=\"visible\",\n        ) as live:\n\n            async def keyboard_handler(listener: KeyboardListener, event: KeyEvent) -> None:\n                # Handle Ctrl+E specially - pause Live while the pager is active\n                if event == KeyEvent.CTRL_E:\n                    if (\n                        self._current_approval_request_panel\n                        and self._current_approval_request_panel.has_expandable_content\n                    ):\n                        await listener.pause()\n                        live.stop()\n                        try:\n                            _show_approval_in_pager(self._current_approval_request_panel)\n                        finally:\n                            # Reset live render shape so the next refresh re-anchors cleanly.\n                            self._reset_live_shape(live)\n                            live.start()\n                            live.update(self.compose(), refresh=True)\n                            await listener.resume()\n                    return\n\n                self.dispatch_keyboard_event(event)\n                if self._need_recompose:\n                    live.update(self.compose(), refresh=True)\n                    self._need_recompose = False\n\n            async with _keyboard_listener(keyboard_handler):\n                while True:\n                    try:\n                        msg = await wire.receive()\n                    except QueueShutDown:\n                        self.cleanup(is_interrupt=False)\n                        live.update(self.compose(), refresh=True)\n                        break\n\n                    if isinstance(msg, StepInterrupted):\n                        self.cleanup(is_interrupt=True)\n                        live.update(self.compose(), refresh=True)\n                        break\n\n                    self.dispatch_wire_message(msg)\n                    if self._need_recompose:\n                        live.update(self.compose(), refresh=True)\n                        self._need_recompose = False\n\n    def refresh_soon(self) -> None:\n        self._need_recompose = True\n\n    def compose(self) -> RenderableType:\n        \"\"\"Compose the live view display content.\"\"\"\n        blocks: list[RenderableType] = []\n        if self._mooning_spinner is not None:\n            blocks.append(self._mooning_spinner)\n        elif self._compacting_spinner is not None:\n            blocks.append(self._compacting_spinner)\n        else:\n            if self._current_content_block is not None:\n                blocks.append(self._current_content_block.compose())\n            for tool_call in self._tool_call_blocks.values():\n                blocks.append(tool_call.compose())\n        if self._current_approval_request_panel:\n            blocks.append(self._current_approval_request_panel.render())\n        blocks.append(self._status_block.render())\n        return Group(*blocks)\n\n    def dispatch_wire_message(self, msg: WireMessage) -> None:\n        \"\"\"Dispatch the Wire message to UI components.\"\"\"\n        assert not isinstance(msg, StepInterrupted)  # handled in visualize_loop\n\n        if isinstance(msg, StepBegin):\n            self.cleanup(is_interrupt=False)\n            self._mooning_spinner = Spinner(\"moon\", \"\")\n            self.refresh_soon()\n            return\n\n        if self._mooning_spinner is not None:\n            # any message other than StepBegin should end the mooning state\n            self._mooning_spinner = None\n            self.refresh_soon()\n\n        match msg:\n            case TurnBegin():\n                self.flush_content()\n                console.print(\n                    Panel(\n                        Text(message_stringify(Message(role=\"user\", content=msg.user_input))),\n                        padding=(0, 1),\n                    )\n                )\n            case TurnEnd():\n                pass\n            case CompactionBegin():\n                self._compacting_spinner = Spinner(\"balloon\", \"Compacting...\")\n                self.refresh_soon()\n            case CompactionEnd():\n                self._compacting_spinner = None\n                self.refresh_soon()\n            case StatusUpdate():\n                self._status_block.update(msg)\n            case ContentPart():\n                self.append_content(msg)\n            case ToolCall():\n                self.append_tool_call(msg)\n            case ToolCallPart():\n                self.append_tool_call_part(msg)\n            case ToolResult():\n                self.append_tool_result(msg)\n            case ApprovalResponse():\n                # we don't need to handle this because the request is resolved on UI\n                pass\n            case SubagentEvent():\n                self.handle_subagent_event(msg)\n            case ApprovalRequest():\n                self.request_approval(msg)\n            case ToolCallRequest():\n                logger.warning(\"Unexpected ToolCallRequest in shell UI: {msg}\", msg=msg)\n\n    def dispatch_keyboard_event(self, event: KeyEvent) -> None:\n        # handle ESC key to cancel the run\n        if event == KeyEvent.ESCAPE and self._cancel_event is not None:\n            self._cancel_event.set()\n            return\n\n        if not self._current_approval_request_panel:\n            # just ignore any keyboard event when there's no approval request\n            return\n\n        match event:\n            case KeyEvent.UP:\n                self._current_approval_request_panel.move_up()\n                self.refresh_soon()\n            case KeyEvent.DOWN:\n                self._current_approval_request_panel.move_down()\n                self.refresh_soon()\n            case KeyEvent.ENTER:\n                resp = self._current_approval_request_panel.get_selected_response()\n                self._current_approval_request_panel.request.resolve(resp)\n                if resp == \"approve_for_session\":\n                    to_remove_from_queue: list[ApprovalRequest] = []\n                    for request in self._approval_request_queue:\n                        # approve all queued requests with the same action\n                        if request.action == self._current_approval_request_panel.request.action:\n                            request.resolve(\"approve_for_session\")\n                            to_remove_from_queue.append(request)\n                    for request in to_remove_from_queue:\n                        self._approval_request_queue.remove(request)\n                elif resp == \"reject\":\n                    # one rejection should stop the step immediately\n                    while self._approval_request_queue:\n                        self._approval_request_queue.popleft().resolve(\"reject\")\n                    self._reject_all_following = True\n                self.show_next_approval_request()\n            case _:\n                # just ignore any other keyboard event\n                return\n\n    def cleanup(self, is_interrupt: bool) -> None:\n        \"\"\"Cleanup the live view on step end or interruption.\"\"\"\n        self.flush_content()\n\n        for block in self._tool_call_blocks.values():\n            if not block.finished:\n                # this should not happen, but just in case\n                block.finish(\n                    ToolError(message=\"\", brief=\"Interrupted\")\n                    if is_interrupt\n                    else ToolOk(output=\"\")\n                )\n        self._last_tool_call_block = None\n        self.flush_finished_tool_calls()\n\n        while self._approval_request_queue:\n            # should not happen, but just in case\n            self._approval_request_queue.popleft().resolve(\"reject\")\n        self._current_approval_request_panel = None\n        self._reject_all_following = False\n\n    def flush_content(self) -> None:\n        \"\"\"Flush the current content block.\"\"\"\n        if self._current_content_block is not None:\n            console.print(self._current_content_block.compose_final())\n            self._current_content_block = None\n            self.refresh_soon()\n\n    def flush_finished_tool_calls(self) -> None:\n        \"\"\"Flush all leading finished tool call blocks.\"\"\"\n        tool_call_ids = list(self._tool_call_blocks.keys())\n        for tool_call_id in tool_call_ids:\n            block = self._tool_call_blocks[tool_call_id]\n            if not block.finished:\n                break\n\n            self._tool_call_blocks.pop(tool_call_id)\n            console.print(block.compose())\n            if self._last_tool_call_block == block:\n                self._last_tool_call_block = None\n            self.refresh_soon()\n\n    def append_content(self, part: ContentPart) -> None:\n        match part:\n            case ThinkPart(think=text) | TextPart(text=text):\n                if not text:\n                    return\n                is_think = isinstance(part, ThinkPart)\n                if self._current_content_block is None:\n                    self._current_content_block = _ContentBlock(is_think)\n                    self.refresh_soon()\n                elif self._current_content_block.is_think != is_think:\n                    self.flush_content()\n                    self._current_content_block = _ContentBlock(is_think)\n                    self.refresh_soon()\n                self._current_content_block.append(text)\n            case _:\n                # TODO: support more content part types\n                pass\n\n    def append_tool_call(self, tool_call: ToolCall) -> None:\n        self.flush_content()\n        self._tool_call_blocks[tool_call.id] = _ToolCallBlock(tool_call)\n        self._last_tool_call_block = self._tool_call_blocks[tool_call.id]\n        self.refresh_soon()\n\n    def append_tool_call_part(self, part: ToolCallPart) -> None:\n        if not part.arguments_part:\n            return\n        if self._last_tool_call_block is None:\n            return\n        self._last_tool_call_block.append_args_part(part.arguments_part)\n        self.refresh_soon()\n\n    def append_tool_result(self, result: ToolResult) -> None:\n        if block := self._tool_call_blocks.get(result.tool_call_id):\n            block.finish(result.return_value)\n            self.flush_finished_tool_calls()\n            self.refresh_soon()\n\n    def request_approval(self, request: ApprovalRequest) -> None:\n        # If we're rejecting all following requests, reject immediately\n        if self._reject_all_following:\n            request.resolve(\"reject\")\n            return\n\n        self._approval_request_queue.append(request)\n\n        if self._current_approval_request_panel is None:\n            console.bell()\n            self.show_next_approval_request()\n\n    def show_next_approval_request(self) -> None:\n        \"\"\"\n        Show the next approval request from the queue.\n        If there are no pending requests, clear the current approval panel.\n        \"\"\"\n        if not self._approval_request_queue:\n            if self._current_approval_request_panel is not None:\n                self._current_approval_request_panel = None\n                self.refresh_soon()\n            return\n\n        while self._approval_request_queue:\n            request = self._approval_request_queue.popleft()\n            if request.resolved:\n                # skip resolved requests\n                continue\n            self._current_approval_request_panel = _ApprovalRequestPanel(request)\n            self.refresh_soon()\n            break\n\n    def handle_subagent_event(self, event: SubagentEvent) -> None:\n        block = self._tool_call_blocks.get(event.task_tool_call_id)\n        if block is None:\n            return\n\n        match event.event:\n            case ToolCall() as tool_call:\n                block.append_sub_tool_call(tool_call)\n            case ToolCallPart() as tool_call_part:\n                block.append_sub_tool_call_part(tool_call_part)\n            case ToolResult() as tool_result:\n                block.finish_sub_tool_call(tool_result)\n                self.refresh_soon()\n            case _:\n                # ignore other events for now\n                # TODO: may need to handle multi-level nested subagents\n                pass\n","structuredPatch":[{"oldStart":161,"oldLines":8,"newStart":161,"newLines":9,"lines":["         argument = extract_key_argument(self._lexer, self._tool_name)","         if argument and argument != self._argument:","             self._argument = argument","+            self._full_url = self._extract_full_url(self._lexer, self._tool_name)","             self._renderable = BulletColumns(","-                Text.from_markup(self._get_headline_markup()),","+                self._build_headline_text(),","                 bullet=self._spinning_dots,","             )"," "]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"52019f94-ea87-40a8-8149-a964475df6c7"}
{"parentUuid":"a421b1bd-47ee-4110-ba93-6b80bcd1931f","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_01DoAQ8FrZVd4vhcSioaukAy","type":"message","role":"assistant","content":[{"type":"text","text":"**Step 4: Replace `_get_headline_markup` with `_build_headline_text`**"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":507,"cache_read_input_tokens":34362,"cache_creation":{"ephemeral_5m_input_tokens":507,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"type":"assistant","uuid":"228bb227-c148-4bb5-9397-2bff828a018d","timestamp":"2026-02-25T08:05:35.193Z"}
{"parentUuid":"228bb227-c148-4bb5-9397-2bff828a018d","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_01DoAQ8FrZVd4vhcSioaukAy","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01ERJHtujvK5pfnza39qhMix","name":"Edit","input":{"replace_all":false,"file_path":"/Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/ui/shell/visualize.py","old_string":"    def _get_headline_markup(self) -> str:\n        return f\"{'Used' if self.finished else 'Using'} [blue]{self._tool_name}[/blue]\" + (\n            f\" [grey50]({escape(self._argument)})[/grey50]\" if self._argument else \"\"\n        )","new_string":"    def _build_headline_text(self) -> Text:\n        text = Text()\n        text.append(\"Used \" if self.finished else \"Using \")\n        text.append(self._tool_name, style=\"blue\")\n        if self._argument:\n            text.append(\" (\", style=\"grey50\")\n            arg_style = (\n                Style(color=\"grey50\", link=self._full_url)\n                if self._full_url\n                else \"grey50\"\n            )\n            text.append(self._argument, style=arg_style)\n            text.append(\")\", style=\"grey50\")\n        return text"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":507,"cache_read_input_tokens":34362,"cache_creation":{"ephemeral_5m_input_tokens":507,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"type":"assistant","uuid":"9cc419a6-1cd3-4a9f-9f43-f741e800d4e4","timestamp":"2026-02-25T08:05:38.980Z"}
{"parentUuid":"9cc419a6-1cd3-4a9f-9f43-f741e800d4e4","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01ERJHtujvK5pfnza39qhMix","toolUseID":"toolu_01ERJHtujvK5pfnza39qhMix","timestamp":"2026-02-25T08:05:39.012Z","uuid":"0eaa0fac-161c-413f-87a9-6bd67ab991b3"}
{"parentUuid":"9cc419a6-1cd3-4a9f-9f43-f741e800d4e4","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01ERJHtujvK5pfnza39qhMix","type":"tool_result","content":"The file /Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/ui/shell/visualize.py has been updated successfully."}]},"uuid":"6a0137f7-06ea-4a98-91c4-4750643a1696","timestamp":"2026-02-25T08:05:39.011Z","toolUseResult":{"filePath":"/Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/ui/shell/visualize.py","oldString":"    def _get_headline_markup(self) -> str:\n        return f\"{'Used' if self.finished else 'Using'} [blue]{self._tool_name}[/blue]\" + (\n            f\" [grey50]({escape(self._argument)})[/grey50]\" if self._argument else \"\"\n        )","newString":"    def _build_headline_text(self) -> Text:\n        text = Text()\n        text.append(\"Used \" if self.finished else \"Using \")\n        text.append(self._tool_name, style=\"blue\")\n        if self._argument:\n            text.append(\" (\", style=\"grey50\")\n            arg_style = (\n                Style(color=\"grey50\", link=self._full_url)\n                if self._full_url\n                else \"grey50\"\n            )\n            text.append(self._argument, style=arg_style)\n            text.append(\")\", style=\"grey50\")\n        return text","originalFile":"from __future__ import annotations\n\nimport asyncio\nimport json\nfrom collections import deque\nfrom collections.abc import Awaitable, Callable\nfrom contextlib import asynccontextmanager, suppress\nfrom typing import NamedTuple\n\nimport streamingjson  # type: ignore[reportMissingTypeStubs]\nfrom kosong.message import Message\nfrom kosong.tooling import ToolError, ToolOk\nfrom rich.console import Group, RenderableType\nfrom rich.live import Live\nfrom rich.markup import escape\nfrom rich.padding import Padding\nfrom rich.panel import Panel\nfrom rich.spinner import Spinner\nfrom rich.style import Style\nfrom rich.text import Text\n\nfrom kimi_cli.tools import extract_key_argument\nfrom kimi_cli.ui.shell.console import console\nfrom kimi_cli.ui.shell.keyboard import KeyboardListener, KeyEvent\nfrom kimi_cli.utils.aioqueue import QueueShutDown\nfrom kimi_cli.utils.diff import format_unified_diff\nfrom kimi_cli.utils.logging import logger\nfrom kimi_cli.utils.message import message_stringify\nfrom kimi_cli.utils.rich.columns import BulletColumns\nfrom kimi_cli.utils.rich.markdown import Markdown\nfrom kimi_cli.utils.rich.syntax import KimiSyntax\nfrom kimi_cli.wire import WireUISide\nfrom kimi_cli.wire.types import (\n    ApprovalRequest,\n    ApprovalResponse,\n    BriefDisplayBlock,\n    CompactionBegin,\n    CompactionEnd,\n    ContentPart,\n    DiffDisplayBlock,\n    ShellDisplayBlock,\n    StatusUpdate,\n    StepBegin,\n    StepInterrupted,\n    SubagentEvent,\n    TextPart,\n    ThinkPart,\n    TodoDisplayBlock,\n    ToolCall,\n    ToolCallPart,\n    ToolCallRequest,\n    ToolResult,\n    ToolReturnValue,\n    TurnBegin,\n    TurnEnd,\n    WireMessage,\n)\n\nMAX_SUBAGENT_TOOL_CALLS_TO_SHOW = 4\n\n# Truncation limits for approval request display\nMAX_PREVIEW_LINES = 4\n\n\nasync def visualize(\n    wire: WireUISide,\n    *,\n    initial_status: StatusUpdate,\n    cancel_event: asyncio.Event | None = None,\n):\n    \"\"\"\n    A loop to consume agent events and visualize the agent behavior.\n\n    Args:\n        wire: Communication channel with the agent\n        initial_status: Initial status snapshot\n        cancel_event: Event that can be set (e.g., by ESC key) to cancel the run\n    \"\"\"\n    view = _LiveView(initial_status, cancel_event)\n    await view.visualize_loop(wire)\n\n\nclass _ContentBlock:\n    def __init__(self, is_think: bool):\n        self.is_think = is_think\n        self._spinner = Spinner(\"dots\", \"Thinking...\" if is_think else \"Composing...\")\n        self.raw_text = \"\"\n\n    def compose(self) -> RenderableType:\n        return self._spinner\n\n    def compose_final(self) -> RenderableType:\n        return BulletColumns(\n            Markdown(\n                self.raw_text,\n                style=\"grey50 italic\" if self.is_think else \"\",\n            ),\n            bullet_style=\"grey50\" if self.is_think else None,\n        )\n\n    def append(self, content: str) -> None:\n        self.raw_text += content\n\n\nclass _ToolCallBlock:\n    class FinishedSubCall(NamedTuple):\n        call: ToolCall\n        result: ToolReturnValue\n\n    @staticmethod\n    def _extract_full_url(\n        json_content: str | streamingjson.Lexer, tool_name: str\n    ) -> str | None:\n        if tool_name != \"FetchURL\":\n            return None\n        json_str = (\n            json_content.complete_json()\n            if isinstance(json_content, streamingjson.Lexer)\n            else json_content\n        )\n        try:\n            args = json.loads(json_str)\n        except (json.JSONDecodeError, ValueError):\n            return None\n        if isinstance(args, dict) and args.get(\"url\"):\n            return str(args[\"url\"])\n        return None\n\n    def __init__(self, tool_call: ToolCall):\n        self._tool_name = tool_call.function.name\n        self._lexer = streamingjson.Lexer()\n        if tool_call.function.arguments is not None:\n            self._lexer.append_string(tool_call.function.arguments)\n\n        self._argument = extract_key_argument(self._lexer, self._tool_name)\n        self._full_url = self._extract_full_url(self._lexer, self._tool_name)\n        self._result: ToolReturnValue | None = None\n\n        self._ongoing_subagent_tool_calls: dict[str, ToolCall] = {}\n        self._last_subagent_tool_call: ToolCall | None = None\n        self._n_finished_subagent_tool_calls = 0\n        self._finished_subagent_tool_calls = deque[_ToolCallBlock.FinishedSubCall](\n            maxlen=MAX_SUBAGENT_TOOL_CALLS_TO_SHOW\n        )\n\n        self._spinning_dots = Spinner(\"dots\", text=\"\")\n        self._renderable: RenderableType = self._compose()\n\n    def compose(self) -> RenderableType:\n        return self._renderable\n\n    @property\n    def finished(self) -> bool:\n        return self._result is not None\n\n    def append_args_part(self, args_part: str):\n        if self.finished:\n            return\n        self._lexer.append_string(args_part)\n        # TODO: maybe don't extract detail if it's already stable\n        argument = extract_key_argument(self._lexer, self._tool_name)\n        if argument and argument != self._argument:\n            self._argument = argument\n            self._full_url = self._extract_full_url(self._lexer, self._tool_name)\n            self._renderable = BulletColumns(\n                self._build_headline_text(),\n                bullet=self._spinning_dots,\n            )\n\n    def finish(self, result: ToolReturnValue):\n        self._result = result\n        self._renderable = self._compose()\n\n    def append_sub_tool_call(self, tool_call: ToolCall):\n        self._ongoing_subagent_tool_calls[tool_call.id] = tool_call\n        self._last_subagent_tool_call = tool_call\n\n    def append_sub_tool_call_part(self, tool_call_part: ToolCallPart):\n        if self._last_subagent_tool_call is None:\n            return\n        if not tool_call_part.arguments_part:\n            return\n        if self._last_subagent_tool_call.function.arguments is None:\n            self._last_subagent_tool_call.function.arguments = tool_call_part.arguments_part\n        else:\n            self._last_subagent_tool_call.function.arguments += tool_call_part.arguments_part\n\n    def finish_sub_tool_call(self, tool_result: ToolResult):\n        self._last_subagent_tool_call = None\n        sub_tool_call = self._ongoing_subagent_tool_calls.pop(tool_result.tool_call_id, None)\n        if sub_tool_call is None:\n            return\n\n        self._finished_subagent_tool_calls.append(\n            _ToolCallBlock.FinishedSubCall(\n                call=sub_tool_call,\n                result=tool_result.return_value,\n            )\n        )\n        self._n_finished_subagent_tool_calls += 1\n        self._renderable = self._compose()\n\n    def _compose(self) -> RenderableType:\n        lines: list[RenderableType] = [\n            Text.from_markup(self._get_headline_markup()),\n        ]\n\n        if self._n_finished_subagent_tool_calls > MAX_SUBAGENT_TOOL_CALLS_TO_SHOW:\n            n_hidden = self._n_finished_subagent_tool_calls - MAX_SUBAGENT_TOOL_CALLS_TO_SHOW\n            lines.append(\n                BulletColumns(\n                    Text(\n                        f\"{n_hidden} more tool call{'s' if n_hidden > 1 else ''} ...\",\n                        style=\"grey50 italic\",\n                    ),\n                    bullet_style=\"grey50\",\n                )\n            )\n        for sub_call, sub_result in self._finished_subagent_tool_calls:\n            argument = extract_key_argument(\n                sub_call.function.arguments or \"\", sub_call.function.name\n            )\n            lines.append(\n                BulletColumns(\n                    Text.from_markup(\n                        f\"Used [blue]{sub_call.function.name}[/blue]\"\n                        + (f\" [grey50]({argument})[/grey50]\" if argument else \"\")\n                    ),\n                    bullet_style=\"green\" if not sub_result.is_error else \"red\",\n                )\n            )\n\n        if self._result is not None:\n            for block in self._result.display:\n                if isinstance(block, BriefDisplayBlock):\n                    style = \"grey50\" if not self._result.is_error else \"red\"\n                    if block.text:\n                        lines.append(Markdown(block.text, style=style))\n                elif isinstance(block, TodoDisplayBlock):\n                    markdown = self._render_todo_markdown(block)\n                    if markdown:\n                        lines.append(Markdown(markdown, style=\"grey50\"))\n\n        if self.finished:\n            assert self._result is not None\n            return BulletColumns(\n                Group(*lines),\n                bullet_style=\"green\" if not self._result.is_error else \"red\",\n            )\n        else:\n            return BulletColumns(\n                Group(*lines),\n                bullet=self._spinning_dots,\n            )\n\n    def _get_headline_markup(self) -> str:\n        return f\"{'Used' if self.finished else 'Using'} [blue]{self._tool_name}[/blue]\" + (\n            f\" [grey50]({escape(self._argument)})[/grey50]\" if self._argument else \"\"\n        )\n\n    def _render_todo_markdown(self, block: TodoDisplayBlock) -> str:\n        lines: list[str] = []\n        for todo in block.items:\n            normalized = todo.status.replace(\"_\", \" \").lower()\n            match normalized:\n                case \"pending\":\n                    lines.append(f\"- {todo.title}\")\n                case \"in progress\":\n                    lines.append(f\"- {todo.title} ←\")\n                case \"done\":\n                    lines.append(f\"- ~~{todo.title}~~\")\n                case _:\n                    lines.append(f\"- {todo.title}\")\n        return \"\\n\".join(lines)\n\n\nclass _ApprovalContentBlock(NamedTuple):\n    \"\"\"A pre-rendered content block for approval request with line count.\"\"\"\n\n    text: str\n    lines: int\n    style: str = \"\"\n    lexer: str = \"\"\n\n\nclass _ApprovalRequestPanel:\n    def __init__(self, request: ApprovalRequest):\n        self.request = request\n        self.options: list[tuple[str, ApprovalResponse.Kind]] = [\n            (\"Approve once\", \"approve\"),\n            (\"Approve for this session\", \"approve_for_session\"),\n            (\"Reject, tell Kimi what to do instead\", \"reject\"),\n        ]\n        self.selected_index = 0\n\n        # Pre-render all content blocks with line counts\n        self._content_blocks: list[_ApprovalContentBlock] = []\n        last_diff_path: str | None = None\n\n        # Handle description (only if no display blocks)\n        if request.description and not request.display:\n            text = request.description.rstrip(\"\\n\")\n            self._content_blocks.append(\n                _ApprovalContentBlock(text=text, lines=text.count(\"\\n\") + 1)\n            )\n\n        # Handle display blocks\n        for block in request.display:\n            if isinstance(block, DiffDisplayBlock):\n                # File path or ellipsis\n                if block.path != last_diff_path:\n                    self._content_blocks.append(\n                        _ApprovalContentBlock(text=block.path, lines=1, style=\"bold\")\n                    )\n                    last_diff_path = block.path\n                else:\n                    self._content_blocks.append(\n                        _ApprovalContentBlock(text=\"⋮\", lines=1, style=\"dim\")\n                    )\n                # Diff content\n                diff_text = format_unified_diff(\n                    block.old_text,\n                    block.new_text,\n                    block.path,\n                    include_file_header=False,\n                ).rstrip(\"\\n\")\n                self._content_blocks.append(\n                    _ApprovalContentBlock(\n                        text=diff_text, lines=diff_text.count(\"\\n\") + 1, lexer=\"diff\"\n                    )\n                )\n            elif isinstance(block, ShellDisplayBlock):\n                text = block.command.rstrip(\"\\n\")\n                self._content_blocks.append(\n                    _ApprovalContentBlock(\n                        text=text, lines=text.count(\"\\n\") + 1, lexer=block.language\n                    )\n                )\n                last_diff_path = None\n            elif isinstance(block, BriefDisplayBlock) and block.text:\n                text = block.text.rstrip(\"\\n\")\n                self._content_blocks.append(\n                    _ApprovalContentBlock(text=text, lines=text.count(\"\\n\") + 1, style=\"grey50\")\n                )\n                last_diff_path = None\n\n        self._total_lines = sum(b.lines for b in self._content_blocks)\n        self.has_expandable_content = self._total_lines > MAX_PREVIEW_LINES\n\n    def render(self) -> RenderableType:\n        \"\"\"Render the approval menu as a panel.\"\"\"\n        content_lines: list[RenderableType] = [\n            Text.from_markup(\n                \"[yellow]⚠ \"\n                f\"{escape(self.request.sender)} is requesting approval to \"\n                f\"{escape(self.request.action)}:[/yellow]\"\n            )\n        ]\n        content_lines.append(Text(\"\"))\n\n        # Render content with line budget\n        remaining = MAX_PREVIEW_LINES\n        for block in self._content_blocks:\n            if remaining <= 0:\n                break\n            content_lines.append(self._render_block(block, remaining))\n            remaining -= min(block.lines, remaining)\n\n        if self.has_expandable_content:\n            content_lines.append(Text(\"... (truncated, ctrl-e to expand)\", style=\"dim italic\"))\n\n        lines: list[RenderableType] = []\n        if content_lines:\n            lines.append(Padding(Group(*content_lines), (0, 0, 0, 2)))\n\n        # Add menu options\n        if lines:\n            lines.append(Text(\"\"))\n        for i, (option_text, _) in enumerate(self.options):\n            if i == self.selected_index:\n                lines.append(Text(f\"→ {option_text}\", style=\"cyan\"))\n            else:\n                lines.append(Text(f\"  {option_text}\", style=\"grey50\"))\n\n        return Padding(Group(*lines), 1)\n\n    def _render_block(\n        self, block: _ApprovalContentBlock, max_lines: int | None = None\n    ) -> RenderableType:\n        \"\"\"Render a content block, optionally truncated.\"\"\"\n        text = block.text\n        if max_lines is not None and block.lines > max_lines:\n            # Truncate to max_lines\n            text = \"\\n\".join(text.split(\"\\n\")[:max_lines])\n\n        if block.lexer:\n            return KimiSyntax(text, block.lexer)\n        return Text(text, style=block.style)\n\n    def render_full(self) -> list[RenderableType]:\n        \"\"\"Render full content for pager (no truncation).\"\"\"\n        return [self._render_block(block) for block in self._content_blocks]\n\n    def move_up(self):\n        \"\"\"Move selection up.\"\"\"\n        self.selected_index = (self.selected_index - 1) % len(self.options)\n\n    def move_down(self):\n        \"\"\"Move selection down.\"\"\"\n        self.selected_index = (self.selected_index + 1) % len(self.options)\n\n    def get_selected_response(self) -> ApprovalResponse.Kind:\n        \"\"\"Get the approval response based on selected option.\"\"\"\n        return self.options[self.selected_index][1]\n\n\ndef _show_approval_in_pager(panel: _ApprovalRequestPanel) -> None:\n    \"\"\"Show the full approval request content in a pager.\"\"\"\n    with console.screen(), console.pager(styles=True):\n        # Header: matches the style in _ApprovalRequestPanel.render()\n        console.print(\n            Text.from_markup(\n                \"[yellow]⚠ \"\n                f\"{escape(panel.request.sender)} is requesting approval to \"\n                f\"{escape(panel.request.action)}:[/yellow]\"\n            )\n        )\n        console.print()\n\n        # Render full content (no truncation)\n        for renderable in panel.render_full():\n            console.print(renderable)\n\n\nclass _StatusBlock:\n    def __init__(self, initial: StatusUpdate) -> None:\n        self.text = Text(\"\", justify=\"right\")\n        self.update(initial)\n\n    def render(self) -> RenderableType:\n        return self.text\n\n    def update(self, status: StatusUpdate) -> None:\n        if status.context_usage is not None:\n            self.text.plain = f\"context: {status.context_usage:.1%}\"\n\n\n@asynccontextmanager\nasync def _keyboard_listener(\n    handler: Callable[[KeyboardListener, KeyEvent], Awaitable[None]],\n):\n    listener = KeyboardListener()\n    await listener.start()\n\n    async def _keyboard():\n        while True:\n            event = await listener.get()\n            await handler(listener, event)\n\n    task = asyncio.create_task(_keyboard())\n    try:\n        yield\n    finally:\n        task.cancel()\n        with suppress(asyncio.CancelledError):\n            await task\n        await listener.stop()\n\n\nclass _LiveView:\n    def __init__(self, initial_status: StatusUpdate, cancel_event: asyncio.Event | None = None):\n        self._cancel_event = cancel_event\n\n        self._mooning_spinner: Spinner | None = None\n        self._compacting_spinner: Spinner | None = None\n\n        self._current_content_block: _ContentBlock | None = None\n        self._tool_call_blocks: dict[str, _ToolCallBlock] = {}\n        self._last_tool_call_block: _ToolCallBlock | None = None\n        self._approval_request_queue = deque[ApprovalRequest]()\n        \"\"\"\n        It is possible that multiple subagents request approvals at the same time,\n        in which case we will have to queue them up and show them one by one.\n        \"\"\"\n        self._current_approval_request_panel: _ApprovalRequestPanel | None = None\n        self._reject_all_following = False\n        self._status_block = _StatusBlock(initial_status)\n\n        self._need_recompose = False\n\n    def _reset_live_shape(self, live: Live) -> None:\n        # Rich doesn't expose a public API to clear Live's cached render height.\n        # After leaving the pager, stale height causes cursor restores to jump,\n        # so we reset the private _shape to re-anchor the next refresh.\n        live._live_render._shape = None  # type: ignore[reportPrivateUsage]\n\n    async def visualize_loop(self, wire: WireUISide):\n        with Live(\n            self.compose(),\n            console=console,\n            refresh_per_second=10,\n            transient=True,\n            vertical_overflow=\"visible\",\n        ) as live:\n\n            async def keyboard_handler(listener: KeyboardListener, event: KeyEvent) -> None:\n                # Handle Ctrl+E specially - pause Live while the pager is active\n                if event == KeyEvent.CTRL_E:\n                    if (\n                        self._current_approval_request_panel\n                        and self._current_approval_request_panel.has_expandable_content\n                    ):\n                        await listener.pause()\n                        live.stop()\n                        try:\n                            _show_approval_in_pager(self._current_approval_request_panel)\n                        finally:\n                            # Reset live render shape so the next refresh re-anchors cleanly.\n                            self._reset_live_shape(live)\n                            live.start()\n                            live.update(self.compose(), refresh=True)\n                            await listener.resume()\n                    return\n\n                self.dispatch_keyboard_event(event)\n                if self._need_recompose:\n                    live.update(self.compose(), refresh=True)\n                    self._need_recompose = False\n\n            async with _keyboard_listener(keyboard_handler):\n                while True:\n                    try:\n                        msg = await wire.receive()\n                    except QueueShutDown:\n                        self.cleanup(is_interrupt=False)\n                        live.update(self.compose(), refresh=True)\n                        break\n\n                    if isinstance(msg, StepInterrupted):\n                        self.cleanup(is_interrupt=True)\n                        live.update(self.compose(), refresh=True)\n                        break\n\n                    self.dispatch_wire_message(msg)\n                    if self._need_recompose:\n                        live.update(self.compose(), refresh=True)\n                        self._need_recompose = False\n\n    def refresh_soon(self) -> None:\n        self._need_recompose = True\n\n    def compose(self) -> RenderableType:\n        \"\"\"Compose the live view display content.\"\"\"\n        blocks: list[RenderableType] = []\n        if self._mooning_spinner is not None:\n            blocks.append(self._mooning_spinner)\n        elif self._compacting_spinner is not None:\n            blocks.append(self._compacting_spinner)\n        else:\n            if self._current_content_block is not None:\n                blocks.append(self._current_content_block.compose())\n            for tool_call in self._tool_call_blocks.values():\n                blocks.append(tool_call.compose())\n        if self._current_approval_request_panel:\n            blocks.append(self._current_approval_request_panel.render())\n        blocks.append(self._status_block.render())\n        return Group(*blocks)\n\n    def dispatch_wire_message(self, msg: WireMessage) -> None:\n        \"\"\"Dispatch the Wire message to UI components.\"\"\"\n        assert not isinstance(msg, StepInterrupted)  # handled in visualize_loop\n\n        if isinstance(msg, StepBegin):\n            self.cleanup(is_interrupt=False)\n            self._mooning_spinner = Spinner(\"moon\", \"\")\n            self.refresh_soon()\n            return\n\n        if self._mooning_spinner is not None:\n            # any message other than StepBegin should end the mooning state\n            self._mooning_spinner = None\n            self.refresh_soon()\n\n        match msg:\n            case TurnBegin():\n                self.flush_content()\n                console.print(\n                    Panel(\n                        Text(message_stringify(Message(role=\"user\", content=msg.user_input))),\n                        padding=(0, 1),\n                    )\n                )\n            case TurnEnd():\n                pass\n            case CompactionBegin():\n                self._compacting_spinner = Spinner(\"balloon\", \"Compacting...\")\n                self.refresh_soon()\n            case CompactionEnd():\n                self._compacting_spinner = None\n                self.refresh_soon()\n            case StatusUpdate():\n                self._status_block.update(msg)\n            case ContentPart():\n                self.append_content(msg)\n            case ToolCall():\n                self.append_tool_call(msg)\n            case ToolCallPart():\n                self.append_tool_call_part(msg)\n            case ToolResult():\n                self.append_tool_result(msg)\n            case ApprovalResponse():\n                # we don't need to handle this because the request is resolved on UI\n                pass\n            case SubagentEvent():\n                self.handle_subagent_event(msg)\n            case ApprovalRequest():\n                self.request_approval(msg)\n            case ToolCallRequest():\n                logger.warning(\"Unexpected ToolCallRequest in shell UI: {msg}\", msg=msg)\n\n    def dispatch_keyboard_event(self, event: KeyEvent) -> None:\n        # handle ESC key to cancel the run\n        if event == KeyEvent.ESCAPE and self._cancel_event is not None:\n            self._cancel_event.set()\n            return\n\n        if not self._current_approval_request_panel:\n            # just ignore any keyboard event when there's no approval request\n            return\n\n        match event:\n            case KeyEvent.UP:\n                self._current_approval_request_panel.move_up()\n                self.refresh_soon()\n            case KeyEvent.DOWN:\n                self._current_approval_request_panel.move_down()\n                self.refresh_soon()\n            case KeyEvent.ENTER:\n                resp = self._current_approval_request_panel.get_selected_response()\n                self._current_approval_request_panel.request.resolve(resp)\n                if resp == \"approve_for_session\":\n                    to_remove_from_queue: list[ApprovalRequest] = []\n                    for request in self._approval_request_queue:\n                        # approve all queued requests with the same action\n                        if request.action == self._current_approval_request_panel.request.action:\n                            request.resolve(\"approve_for_session\")\n                            to_remove_from_queue.append(request)\n                    for request in to_remove_from_queue:\n                        self._approval_request_queue.remove(request)\n                elif resp == \"reject\":\n                    # one rejection should stop the step immediately\n                    while self._approval_request_queue:\n                        self._approval_request_queue.popleft().resolve(\"reject\")\n                    self._reject_all_following = True\n                self.show_next_approval_request()\n            case _:\n                # just ignore any other keyboard event\n                return\n\n    def cleanup(self, is_interrupt: bool) -> None:\n        \"\"\"Cleanup the live view on step end or interruption.\"\"\"\n        self.flush_content()\n\n        for block in self._tool_call_blocks.values():\n            if not block.finished:\n                # this should not happen, but just in case\n                block.finish(\n                    ToolError(message=\"\", brief=\"Interrupted\")\n                    if is_interrupt\n                    else ToolOk(output=\"\")\n                )\n        self._last_tool_call_block = None\n        self.flush_finished_tool_calls()\n\n        while self._approval_request_queue:\n            # should not happen, but just in case\n            self._approval_request_queue.popleft().resolve(\"reject\")\n        self._current_approval_request_panel = None\n        self._reject_all_following = False\n\n    def flush_content(self) -> None:\n        \"\"\"Flush the current content block.\"\"\"\n        if self._current_content_block is not None:\n            console.print(self._current_content_block.compose_final())\n            self._current_content_block = None\n            self.refresh_soon()\n\n    def flush_finished_tool_calls(self) -> None:\n        \"\"\"Flush all leading finished tool call blocks.\"\"\"\n        tool_call_ids = list(self._tool_call_blocks.keys())\n        for tool_call_id in tool_call_ids:\n            block = self._tool_call_blocks[tool_call_id]\n            if not block.finished:\n                break\n\n            self._tool_call_blocks.pop(tool_call_id)\n            console.print(block.compose())\n            if self._last_tool_call_block == block:\n                self._last_tool_call_block = None\n            self.refresh_soon()\n\n    def append_content(self, part: ContentPart) -> None:\n        match part:\n            case ThinkPart(think=text) | TextPart(text=text):\n                if not text:\n                    return\n                is_think = isinstance(part, ThinkPart)\n                if self._current_content_block is None:\n                    self._current_content_block = _ContentBlock(is_think)\n                    self.refresh_soon()\n                elif self._current_content_block.is_think != is_think:\n                    self.flush_content()\n                    self._current_content_block = _ContentBlock(is_think)\n                    self.refresh_soon()\n                self._current_content_block.append(text)\n            case _:\n                # TODO: support more content part types\n                pass\n\n    def append_tool_call(self, tool_call: ToolCall) -> None:\n        self.flush_content()\n        self._tool_call_blocks[tool_call.id] = _ToolCallBlock(tool_call)\n        self._last_tool_call_block = self._tool_call_blocks[tool_call.id]\n        self.refresh_soon()\n\n    def append_tool_call_part(self, part: ToolCallPart) -> None:\n        if not part.arguments_part:\n            return\n        if self._last_tool_call_block is None:\n            return\n        self._last_tool_call_block.append_args_part(part.arguments_part)\n        self.refresh_soon()\n\n    def append_tool_result(self, result: ToolResult) -> None:\n        if block := self._tool_call_blocks.get(result.tool_call_id):\n            block.finish(result.return_value)\n            self.flush_finished_tool_calls()\n            self.refresh_soon()\n\n    def request_approval(self, request: ApprovalRequest) -> None:\n        # If we're rejecting all following requests, reject immediately\n        if self._reject_all_following:\n            request.resolve(\"reject\")\n            return\n\n        self._approval_request_queue.append(request)\n\n        if self._current_approval_request_panel is None:\n            console.bell()\n            self.show_next_approval_request()\n\n    def show_next_approval_request(self) -> None:\n        \"\"\"\n        Show the next approval request from the queue.\n        If there are no pending requests, clear the current approval panel.\n        \"\"\"\n        if not self._approval_request_queue:\n            if self._current_approval_request_panel is not None:\n                self._current_approval_request_panel = None\n                self.refresh_soon()\n            return\n\n        while self._approval_request_queue:\n            request = self._approval_request_queue.popleft()\n            if request.resolved:\n                # skip resolved requests\n                continue\n            self._current_approval_request_panel = _ApprovalRequestPanel(request)\n            self.refresh_soon()\n            break\n\n    def handle_subagent_event(self, event: SubagentEvent) -> None:\n        block = self._tool_call_blocks.get(event.task_tool_call_id)\n        if block is None:\n            return\n\n        match event.event:\n            case ToolCall() as tool_call:\n                block.append_sub_tool_call(tool_call)\n            case ToolCallPart() as tool_call_part:\n                block.append_sub_tool_call_part(tool_call_part)\n            case ToolResult() as tool_result:\n                block.finish_sub_tool_call(tool_result)\n                self.refresh_soon()\n            case _:\n                # ignore other events for now\n                # TODO: may need to handle multi-level nested subagents\n                pass\n","structuredPatch":[{"oldStart":253,"oldLines":10,"newStart":253,"newLines":20,"lines":["                 bullet=self._spinning_dots,","             )"," ","-    def _get_headline_markup(self) -> str:","-        return f\"{'Used' if self.finished else 'Using'} [blue]{self._tool_name}[/blue]\" + (","-            f\" [grey50]({escape(self._argument)})[/grey50]\" if self._argument else \"\"","-        )","+    def _build_headline_text(self) -> Text:","+        text = Text()","+        text.append(\"Used \" if self.finished else \"Using \")","+        text.append(self._tool_name, style=\"blue\")","+        if self._argument:","+            text.append(\" (\", style=\"grey50\")","+            arg_style = (","+                Style(color=\"grey50\", link=self._full_url)","+                if self._full_url","+                else \"grey50\"","+            )","+            text.append(self._argument, style=arg_style)","+            text.append(\")\", style=\"grey50\")","+        return text"," ","     def _render_todo_markdown(self, block: TodoDisplayBlock) -> str:","         lines: list[str] = []"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"9cc419a6-1cd3-4a9f-9f43-f741e800d4e4"}
{"parentUuid":"6a0137f7-06ea-4a98-91c4-4750643a1696","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_01TojfwmagJGkXVYs66YvCEo","type":"message","role":"assistant","content":[{"type":"text","text":"**Step 5: Update `_compose` to use `_build_headline_text` and add full URL hint line**"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":440,"cache_read_input_tokens":34869,"cache_creation":{"ephemeral_5m_input_tokens":440,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"type":"assistant","uuid":"ca6a97f2-9068-4bbd-87bd-50e12e423861","timestamp":"2026-02-25T08:05:42.448Z"}
{"parentUuid":"ca6a97f2-9068-4bbd-87bd-50e12e423861","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_01TojfwmagJGkXVYs66YvCEo","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012VDkvQxMB4eooZB229zerz","name":"Edit","input":{"replace_all":false,"file_path":"/Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/ui/shell/visualize.py","old_string":"    def _compose(self) -> RenderableType:\n        lines: list[RenderableType] = [\n            Text.from_markup(self._get_headline_markup()),\n        ]\n\n        if self._n_finished_subagent_tool_calls > MAX_SUBAGENT_TOOL_CALLS_TO_SHOW:","new_string":"    def _compose(self) -> RenderableType:\n        lines: list[RenderableType] = [\n            self._build_headline_text(),\n        ]\n\n        # Show full URL hint when URL was truncated\n        if self._full_url and self._full_url != self._argument:\n            url_hint = Text()\n            url_hint.append(\"  ↳ \", style=\"grey50\")\n            url_hint.append(self._full_url, style=Style(color=\"grey50\", link=self._full_url))\n            lines.append(url_hint)\n\n        if self._n_finished_subagent_tool_calls > MAX_SUBAGENT_TOOL_CALLS_TO_SHOW:"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":440,"cache_read_input_tokens":34869,"output_tokens":419,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":440},"inference_geo":"","iterations":[],"speed":"standard"}},"type":"assistant","uuid":"ccd8165a-bee2-4965-9ebd-c43df10c6eb6","timestamp":"2026-02-25T08:05:46.279Z"}
{"parentUuid":"ccd8165a-bee2-4965-9ebd-c43df10c6eb6","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_012VDkvQxMB4eooZB229zerz","toolUseID":"toolu_012VDkvQxMB4eooZB229zerz","timestamp":"2026-02-25T08:05:46.320Z","uuid":"97fc4d33-f738-4e7a-a7ca-e1d2059716e9"}
{"parentUuid":"ccd8165a-bee2-4965-9ebd-c43df10c6eb6","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012VDkvQxMB4eooZB229zerz","type":"tool_result","content":"The file /Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/ui/shell/visualize.py has been updated successfully."}]},"uuid":"e39e70e6-26d5-4e78-b157-943828b79102","timestamp":"2026-02-25T08:05:46.319Z","toolUseResult":{"filePath":"/Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/ui/shell/visualize.py","oldString":"    def _compose(self) -> RenderableType:\n        lines: list[RenderableType] = [\n            Text.from_markup(self._get_headline_markup()),\n        ]\n\n        if self._n_finished_subagent_tool_calls > MAX_SUBAGENT_TOOL_CALLS_TO_SHOW:","newString":"    def _compose(self) -> RenderableType:\n        lines: list[RenderableType] = [\n            self._build_headline_text(),\n        ]\n\n        # Show full URL hint when URL was truncated\n        if self._full_url and self._full_url != self._argument:\n            url_hint = Text()\n            url_hint.append(\"  ↳ \", style=\"grey50\")\n            url_hint.append(self._full_url, style=Style(color=\"grey50\", link=self._full_url))\n            lines.append(url_hint)\n\n        if self._n_finished_subagent_tool_calls > MAX_SUBAGENT_TOOL_CALLS_TO_SHOW:","originalFile":"from __future__ import annotations\n\nimport asyncio\nimport json\nfrom collections import deque\nfrom collections.abc import Awaitable, Callable\nfrom contextlib import asynccontextmanager, suppress\nfrom typing import NamedTuple\n\nimport streamingjson  # type: ignore[reportMissingTypeStubs]\nfrom kosong.message import Message\nfrom kosong.tooling import ToolError, ToolOk\nfrom rich.console import Group, RenderableType\nfrom rich.live import Live\nfrom rich.markup import escape\nfrom rich.padding import Padding\nfrom rich.panel import Panel\nfrom rich.spinner import Spinner\nfrom rich.style import Style\nfrom rich.text import Text\n\nfrom kimi_cli.tools import extract_key_argument\nfrom kimi_cli.ui.shell.console import console\nfrom kimi_cli.ui.shell.keyboard import KeyboardListener, KeyEvent\nfrom kimi_cli.utils.aioqueue import QueueShutDown\nfrom kimi_cli.utils.diff import format_unified_diff\nfrom kimi_cli.utils.logging import logger\nfrom kimi_cli.utils.message import message_stringify\nfrom kimi_cli.utils.rich.columns import BulletColumns\nfrom kimi_cli.utils.rich.markdown import Markdown\nfrom kimi_cli.utils.rich.syntax import KimiSyntax\nfrom kimi_cli.wire import WireUISide\nfrom kimi_cli.wire.types import (\n    ApprovalRequest,\n    ApprovalResponse,\n    BriefDisplayBlock,\n    CompactionBegin,\n    CompactionEnd,\n    ContentPart,\n    DiffDisplayBlock,\n    ShellDisplayBlock,\n    StatusUpdate,\n    StepBegin,\n    StepInterrupted,\n    SubagentEvent,\n    TextPart,\n    ThinkPart,\n    TodoDisplayBlock,\n    ToolCall,\n    ToolCallPart,\n    ToolCallRequest,\n    ToolResult,\n    ToolReturnValue,\n    TurnBegin,\n    TurnEnd,\n    WireMessage,\n)\n\nMAX_SUBAGENT_TOOL_CALLS_TO_SHOW = 4\n\n# Truncation limits for approval request display\nMAX_PREVIEW_LINES = 4\n\n\nasync def visualize(\n    wire: WireUISide,\n    *,\n    initial_status: StatusUpdate,\n    cancel_event: asyncio.Event | None = None,\n):\n    \"\"\"\n    A loop to consume agent events and visualize the agent behavior.\n\n    Args:\n        wire: Communication channel with the agent\n        initial_status: Initial status snapshot\n        cancel_event: Event that can be set (e.g., by ESC key) to cancel the run\n    \"\"\"\n    view = _LiveView(initial_status, cancel_event)\n    await view.visualize_loop(wire)\n\n\nclass _ContentBlock:\n    def __init__(self, is_think: bool):\n        self.is_think = is_think\n        self._spinner = Spinner(\"dots\", \"Thinking...\" if is_think else \"Composing...\")\n        self.raw_text = \"\"\n\n    def compose(self) -> RenderableType:\n        return self._spinner\n\n    def compose_final(self) -> RenderableType:\n        return BulletColumns(\n            Markdown(\n                self.raw_text,\n                style=\"grey50 italic\" if self.is_think else \"\",\n            ),\n            bullet_style=\"grey50\" if self.is_think else None,\n        )\n\n    def append(self, content: str) -> None:\n        self.raw_text += content\n\n\nclass _ToolCallBlock:\n    class FinishedSubCall(NamedTuple):\n        call: ToolCall\n        result: ToolReturnValue\n\n    @staticmethod\n    def _extract_full_url(\n        json_content: str | streamingjson.Lexer, tool_name: str\n    ) -> str | None:\n        if tool_name != \"FetchURL\":\n            return None\n        json_str = (\n            json_content.complete_json()\n            if isinstance(json_content, streamingjson.Lexer)\n            else json_content\n        )\n        try:\n            args = json.loads(json_str)\n        except (json.JSONDecodeError, ValueError):\n            return None\n        if isinstance(args, dict) and args.get(\"url\"):\n            return str(args[\"url\"])\n        return None\n\n    def __init__(self, tool_call: ToolCall):\n        self._tool_name = tool_call.function.name\n        self._lexer = streamingjson.Lexer()\n        if tool_call.function.arguments is not None:\n            self._lexer.append_string(tool_call.function.arguments)\n\n        self._argument = extract_key_argument(self._lexer, self._tool_name)\n        self._full_url = self._extract_full_url(self._lexer, self._tool_name)\n        self._result: ToolReturnValue | None = None\n\n        self._ongoing_subagent_tool_calls: dict[str, ToolCall] = {}\n        self._last_subagent_tool_call: ToolCall | None = None\n        self._n_finished_subagent_tool_calls = 0\n        self._finished_subagent_tool_calls = deque[_ToolCallBlock.FinishedSubCall](\n            maxlen=MAX_SUBAGENT_TOOL_CALLS_TO_SHOW\n        )\n\n        self._spinning_dots = Spinner(\"dots\", text=\"\")\n        self._renderable: RenderableType = self._compose()\n\n    def compose(self) -> RenderableType:\n        return self._renderable\n\n    @property\n    def finished(self) -> bool:\n        return self._result is not None\n\n    def append_args_part(self, args_part: str):\n        if self.finished:\n            return\n        self._lexer.append_string(args_part)\n        # TODO: maybe don't extract detail if it's already stable\n        argument = extract_key_argument(self._lexer, self._tool_name)\n        if argument and argument != self._argument:\n            self._argument = argument\n            self._full_url = self._extract_full_url(self._lexer, self._tool_name)\n            self._renderable = BulletColumns(\n                self._build_headline_text(),\n                bullet=self._spinning_dots,\n            )\n\n    def finish(self, result: ToolReturnValue):\n        self._result = result\n        self._renderable = self._compose()\n\n    def append_sub_tool_call(self, tool_call: ToolCall):\n        self._ongoing_subagent_tool_calls[tool_call.id] = tool_call\n        self._last_subagent_tool_call = tool_call\n\n    def append_sub_tool_call_part(self, tool_call_part: ToolCallPart):\n        if self._last_subagent_tool_call is None:\n            return\n        if not tool_call_part.arguments_part:\n            return\n        if self._last_subagent_tool_call.function.arguments is None:\n            self._last_subagent_tool_call.function.arguments = tool_call_part.arguments_part\n        else:\n            self._last_subagent_tool_call.function.arguments += tool_call_part.arguments_part\n\n    def finish_sub_tool_call(self, tool_result: ToolResult):\n        self._last_subagent_tool_call = None\n        sub_tool_call = self._ongoing_subagent_tool_calls.pop(tool_result.tool_call_id, None)\n        if sub_tool_call is None:\n            return\n\n        self._finished_subagent_tool_calls.append(\n            _ToolCallBlock.FinishedSubCall(\n                call=sub_tool_call,\n                result=tool_result.return_value,\n            )\n        )\n        self._n_finished_subagent_tool_calls += 1\n        self._renderable = self._compose()\n\n    def _compose(self) -> RenderableType:\n        lines: list[RenderableType] = [\n            Text.from_markup(self._get_headline_markup()),\n        ]\n\n        if self._n_finished_subagent_tool_calls > MAX_SUBAGENT_TOOL_CALLS_TO_SHOW:\n            n_hidden = self._n_finished_subagent_tool_calls - MAX_SUBAGENT_TOOL_CALLS_TO_SHOW\n            lines.append(\n                BulletColumns(\n                    Text(\n                        f\"{n_hidden} more tool call{'s' if n_hidden > 1 else ''} ...\",\n                        style=\"grey50 italic\",\n                    ),\n                    bullet_style=\"grey50\",\n                )\n            )\n        for sub_call, sub_result in self._finished_subagent_tool_calls:\n            argument = extract_key_argument(\n                sub_call.function.arguments or \"\", sub_call.function.name\n            )\n            lines.append(\n                BulletColumns(\n                    Text.from_markup(\n                        f\"Used [blue]{sub_call.function.name}[/blue]\"\n                        + (f\" [grey50]({argument})[/grey50]\" if argument else \"\")\n                    ),\n                    bullet_style=\"green\" if not sub_result.is_error else \"red\",\n                )\n            )\n\n        if self._result is not None:\n            for block in self._result.display:\n                if isinstance(block, BriefDisplayBlock):\n                    style = \"grey50\" if not self._result.is_error else \"red\"\n                    if block.text:\n                        lines.append(Markdown(block.text, style=style))\n                elif isinstance(block, TodoDisplayBlock):\n                    markdown = self._render_todo_markdown(block)\n                    if markdown:\n                        lines.append(Markdown(markdown, style=\"grey50\"))\n\n        if self.finished:\n            assert self._result is not None\n            return BulletColumns(\n                Group(*lines),\n                bullet_style=\"green\" if not self._result.is_error else \"red\",\n            )\n        else:\n            return BulletColumns(\n                Group(*lines),\n                bullet=self._spinning_dots,\n            )\n\n    def _build_headline_text(self) -> Text:\n        text = Text()\n        text.append(\"Used \" if self.finished else \"Using \")\n        text.append(self._tool_name, style=\"blue\")\n        if self._argument:\n            text.append(\" (\", style=\"grey50\")\n            arg_style = (\n                Style(color=\"grey50\", link=self._full_url)\n                if self._full_url\n                else \"grey50\"\n            )\n            text.append(self._argument, style=arg_style)\n            text.append(\")\", style=\"grey50\")\n        return text\n\n    def _render_todo_markdown(self, block: TodoDisplayBlock) -> str:\n        lines: list[str] = []\n        for todo in block.items:\n            normalized = todo.status.replace(\"_\", \" \").lower()\n            match normalized:\n                case \"pending\":\n                    lines.append(f\"- {todo.title}\")\n                case \"in progress\":\n                    lines.append(f\"- {todo.title} ←\")\n                case \"done\":\n                    lines.append(f\"- ~~{todo.title}~~\")\n                case _:\n                    lines.append(f\"- {todo.title}\")\n        return \"\\n\".join(lines)\n\n\nclass _ApprovalContentBlock(NamedTuple):\n    \"\"\"A pre-rendered content block for approval request with line count.\"\"\"\n\n    text: str\n    lines: int\n    style: str = \"\"\n    lexer: str = \"\"\n\n\nclass _ApprovalRequestPanel:\n    def __init__(self, request: ApprovalRequest):\n        self.request = request\n        self.options: list[tuple[str, ApprovalResponse.Kind]] = [\n            (\"Approve once\", \"approve\"),\n            (\"Approve for this session\", \"approve_for_session\"),\n            (\"Reject, tell Kimi what to do instead\", \"reject\"),\n        ]\n        self.selected_index = 0\n\n        # Pre-render all content blocks with line counts\n        self._content_blocks: list[_ApprovalContentBlock] = []\n        last_diff_path: str | None = None\n\n        # Handle description (only if no display blocks)\n        if request.description and not request.display:\n            text = request.description.rstrip(\"\\n\")\n            self._content_blocks.append(\n                _ApprovalContentBlock(text=text, lines=text.count(\"\\n\") + 1)\n            )\n\n        # Handle display blocks\n        for block in request.display:\n            if isinstance(block, DiffDisplayBlock):\n                # File path or ellipsis\n                if block.path != last_diff_path:\n                    self._content_blocks.append(\n                        _ApprovalContentBlock(text=block.path, lines=1, style=\"bold\")\n                    )\n                    last_diff_path = block.path\n                else:\n                    self._content_blocks.append(\n                        _ApprovalContentBlock(text=\"⋮\", lines=1, style=\"dim\")\n                    )\n                # Diff content\n                diff_text = format_unified_diff(\n                    block.old_text,\n                    block.new_text,\n                    block.path,\n                    include_file_header=False,\n                ).rstrip(\"\\n\")\n                self._content_blocks.append(\n                    _ApprovalContentBlock(\n                        text=diff_text, lines=diff_text.count(\"\\n\") + 1, lexer=\"diff\"\n                    )\n                )\n            elif isinstance(block, ShellDisplayBlock):\n                text = block.command.rstrip(\"\\n\")\n                self._content_blocks.append(\n                    _ApprovalContentBlock(\n                        text=text, lines=text.count(\"\\n\") + 1, lexer=block.language\n                    )\n                )\n                last_diff_path = None\n            elif isinstance(block, BriefDisplayBlock) and block.text:\n                text = block.text.rstrip(\"\\n\")\n                self._content_blocks.append(\n                    _ApprovalContentBlock(text=text, lines=text.count(\"\\n\") + 1, style=\"grey50\")\n                )\n                last_diff_path = None\n\n        self._total_lines = sum(b.lines for b in self._content_blocks)\n        self.has_expandable_content = self._total_lines > MAX_PREVIEW_LINES\n\n    def render(self) -> RenderableType:\n        \"\"\"Render the approval menu as a panel.\"\"\"\n        content_lines: list[RenderableType] = [\n            Text.from_markup(\n                \"[yellow]⚠ \"\n                f\"{escape(self.request.sender)} is requesting approval to \"\n                f\"{escape(self.request.action)}:[/yellow]\"\n            )\n        ]\n        content_lines.append(Text(\"\"))\n\n        # Render content with line budget\n        remaining = MAX_PREVIEW_LINES\n        for block in self._content_blocks:\n            if remaining <= 0:\n                break\n            content_lines.append(self._render_block(block, remaining))\n            remaining -= min(block.lines, remaining)\n\n        if self.has_expandable_content:\n            content_lines.append(Text(\"... (truncated, ctrl-e to expand)\", style=\"dim italic\"))\n\n        lines: list[RenderableType] = []\n        if content_lines:\n            lines.append(Padding(Group(*content_lines), (0, 0, 0, 2)))\n\n        # Add menu options\n        if lines:\n            lines.append(Text(\"\"))\n        for i, (option_text, _) in enumerate(self.options):\n            if i == self.selected_index:\n                lines.append(Text(f\"→ {option_text}\", style=\"cyan\"))\n            else:\n                lines.append(Text(f\"  {option_text}\", style=\"grey50\"))\n\n        return Padding(Group(*lines), 1)\n\n    def _render_block(\n        self, block: _ApprovalContentBlock, max_lines: int | None = None\n    ) -> RenderableType:\n        \"\"\"Render a content block, optionally truncated.\"\"\"\n        text = block.text\n        if max_lines is not None and block.lines > max_lines:\n            # Truncate to max_lines\n            text = \"\\n\".join(text.split(\"\\n\")[:max_lines])\n\n        if block.lexer:\n            return KimiSyntax(text, block.lexer)\n        return Text(text, style=block.style)\n\n    def render_full(self) -> list[RenderableType]:\n        \"\"\"Render full content for pager (no truncation).\"\"\"\n        return [self._render_block(block) for block in self._content_blocks]\n\n    def move_up(self):\n        \"\"\"Move selection up.\"\"\"\n        self.selected_index = (self.selected_index - 1) % len(self.options)\n\n    def move_down(self):\n        \"\"\"Move selection down.\"\"\"\n        self.selected_index = (self.selected_index + 1) % len(self.options)\n\n    def get_selected_response(self) -> ApprovalResponse.Kind:\n        \"\"\"Get the approval response based on selected option.\"\"\"\n        return self.options[self.selected_index][1]\n\n\ndef _show_approval_in_pager(panel: _ApprovalRequestPanel) -> None:\n    \"\"\"Show the full approval request content in a pager.\"\"\"\n    with console.screen(), console.pager(styles=True):\n        # Header: matches the style in _ApprovalRequestPanel.render()\n        console.print(\n            Text.from_markup(\n                \"[yellow]⚠ \"\n                f\"{escape(panel.request.sender)} is requesting approval to \"\n                f\"{escape(panel.request.action)}:[/yellow]\"\n            )\n        )\n        console.print()\n\n        # Render full content (no truncation)\n        for renderable in panel.render_full():\n            console.print(renderable)\n\n\nclass _StatusBlock:\n    def __init__(self, initial: StatusUpdate) -> None:\n        self.text = Text(\"\", justify=\"right\")\n        self.update(initial)\n\n    def render(self) -> RenderableType:\n        return self.text\n\n    def update(self, status: StatusUpdate) -> None:\n        if status.context_usage is not None:\n            self.text.plain = f\"context: {status.context_usage:.1%}\"\n\n\n@asynccontextmanager\nasync def _keyboard_listener(\n    handler: Callable[[KeyboardListener, KeyEvent], Awaitable[None]],\n):\n    listener = KeyboardListener()\n    await listener.start()\n\n    async def _keyboard():\n        while True:\n            event = await listener.get()\n            await handler(listener, event)\n\n    task = asyncio.create_task(_keyboard())\n    try:\n        yield\n    finally:\n        task.cancel()\n        with suppress(asyncio.CancelledError):\n            await task\n        await listener.stop()\n\n\nclass _LiveView:\n    def __init__(self, initial_status: StatusUpdate, cancel_event: asyncio.Event | None = None):\n        self._cancel_event = cancel_event\n\n        self._mooning_spinner: Spinner | None = None\n        self._compacting_spinner: Spinner | None = None\n\n        self._current_content_block: _ContentBlock | None = None\n        self._tool_call_blocks: dict[str, _ToolCallBlock] = {}\n        self._last_tool_call_block: _ToolCallBlock | None = None\n        self._approval_request_queue = deque[ApprovalRequest]()\n        \"\"\"\n        It is possible that multiple subagents request approvals at the same time,\n        in which case we will have to queue them up and show them one by one.\n        \"\"\"\n        self._current_approval_request_panel: _ApprovalRequestPanel | None = None\n        self._reject_all_following = False\n        self._status_block = _StatusBlock(initial_status)\n\n        self._need_recompose = False\n\n    def _reset_live_shape(self, live: Live) -> None:\n        # Rich doesn't expose a public API to clear Live's cached render height.\n        # After leaving the pager, stale height causes cursor restores to jump,\n        # so we reset the private _shape to re-anchor the next refresh.\n        live._live_render._shape = None  # type: ignore[reportPrivateUsage]\n\n    async def visualize_loop(self, wire: WireUISide):\n        with Live(\n            self.compose(),\n            console=console,\n            refresh_per_second=10,\n            transient=True,\n            vertical_overflow=\"visible\",\n        ) as live:\n\n            async def keyboard_handler(listener: KeyboardListener, event: KeyEvent) -> None:\n                # Handle Ctrl+E specially - pause Live while the pager is active\n                if event == KeyEvent.CTRL_E:\n                    if (\n                        self._current_approval_request_panel\n                        and self._current_approval_request_panel.has_expandable_content\n                    ):\n                        await listener.pause()\n                        live.stop()\n                        try:\n                            _show_approval_in_pager(self._current_approval_request_panel)\n                        finally:\n                            # Reset live render shape so the next refresh re-anchors cleanly.\n                            self._reset_live_shape(live)\n                            live.start()\n                            live.update(self.compose(), refresh=True)\n                            await listener.resume()\n                    return\n\n                self.dispatch_keyboard_event(event)\n                if self._need_recompose:\n                    live.update(self.compose(), refresh=True)\n                    self._need_recompose = False\n\n            async with _keyboard_listener(keyboard_handler):\n                while True:\n                    try:\n                        msg = await wire.receive()\n                    except QueueShutDown:\n                        self.cleanup(is_interrupt=False)\n                        live.update(self.compose(), refresh=True)\n                        break\n\n                    if isinstance(msg, StepInterrupted):\n                        self.cleanup(is_interrupt=True)\n                        live.update(self.compose(), refresh=True)\n                        break\n\n                    self.dispatch_wire_message(msg)\n                    if self._need_recompose:\n                        live.update(self.compose(), refresh=True)\n                        self._need_recompose = False\n\n    def refresh_soon(self) -> None:\n        self._need_recompose = True\n\n    def compose(self) -> RenderableType:\n        \"\"\"Compose the live view display content.\"\"\"\n        blocks: list[RenderableType] = []\n        if self._mooning_spinner is not None:\n            blocks.append(self._mooning_spinner)\n        elif self._compacting_spinner is not None:\n            blocks.append(self._compacting_spinner)\n        else:\n            if self._current_content_block is not None:\n                blocks.append(self._current_content_block.compose())\n            for tool_call in self._tool_call_blocks.values():\n                blocks.append(tool_call.compose())\n        if self._current_approval_request_panel:\n            blocks.append(self._current_approval_request_panel.render())\n        blocks.append(self._status_block.render())\n        return Group(*blocks)\n\n    def dispatch_wire_message(self, msg: WireMessage) -> None:\n        \"\"\"Dispatch the Wire message to UI components.\"\"\"\n        assert not isinstance(msg, StepInterrupted)  # handled in visualize_loop\n\n        if isinstance(msg, StepBegin):\n            self.cleanup(is_interrupt=False)\n            self._mooning_spinner = Spinner(\"moon\", \"\")\n            self.refresh_soon()\n            return\n\n        if self._mooning_spinner is not None:\n            # any message other than StepBegin should end the mooning state\n            self._mooning_spinner = None\n            self.refresh_soon()\n\n        match msg:\n            case TurnBegin():\n                self.flush_content()\n                console.print(\n                    Panel(\n                        Text(message_stringify(Message(role=\"user\", content=msg.user_input))),\n                        padding=(0, 1),\n                    )\n                )\n            case TurnEnd():\n                pass\n            case CompactionBegin():\n                self._compacting_spinner = Spinner(\"balloon\", \"Compacting...\")\n                self.refresh_soon()\n            case CompactionEnd():\n                self._compacting_spinner = None\n                self.refresh_soon()\n            case StatusUpdate():\n                self._status_block.update(msg)\n            case ContentPart():\n                self.append_content(msg)\n            case ToolCall():\n                self.append_tool_call(msg)\n            case ToolCallPart():\n                self.append_tool_call_part(msg)\n            case ToolResult():\n                self.append_tool_result(msg)\n            case ApprovalResponse():\n                # we don't need to handle this because the request is resolved on UI\n                pass\n            case SubagentEvent():\n                self.handle_subagent_event(msg)\n            case ApprovalRequest():\n                self.request_approval(msg)\n            case ToolCallRequest():\n                logger.warning(\"Unexpected ToolCallRequest in shell UI: {msg}\", msg=msg)\n\n    def dispatch_keyboard_event(self, event: KeyEvent) -> None:\n        # handle ESC key to cancel the run\n        if event == KeyEvent.ESCAPE and self._cancel_event is not None:\n            self._cancel_event.set()\n            return\n\n        if not self._current_approval_request_panel:\n            # just ignore any keyboard event when there's no approval request\n            return\n\n        match event:\n            case KeyEvent.UP:\n                self._current_approval_request_panel.move_up()\n                self.refresh_soon()\n            case KeyEvent.DOWN:\n                self._current_approval_request_panel.move_down()\n                self.refresh_soon()\n            case KeyEvent.ENTER:\n                resp = self._current_approval_request_panel.get_selected_response()\n                self._current_approval_request_panel.request.resolve(resp)\n                if resp == \"approve_for_session\":\n                    to_remove_from_queue: list[ApprovalRequest] = []\n                    for request in self._approval_request_queue:\n                        # approve all queued requests with the same action\n                        if request.action == self._current_approval_request_panel.request.action:\n                            request.resolve(\"approve_for_session\")\n                            to_remove_from_queue.append(request)\n                    for request in to_remove_from_queue:\n                        self._approval_request_queue.remove(request)\n                elif resp == \"reject\":\n                    # one rejection should stop the step immediately\n                    while self._approval_request_queue:\n                        self._approval_request_queue.popleft().resolve(\"reject\")\n                    self._reject_all_following = True\n                self.show_next_approval_request()\n            case _:\n                # just ignore any other keyboard event\n                return\n\n    def cleanup(self, is_interrupt: bool) -> None:\n        \"\"\"Cleanup the live view on step end or interruption.\"\"\"\n        self.flush_content()\n\n        for block in self._tool_call_blocks.values():\n            if not block.finished:\n                # this should not happen, but just in case\n                block.finish(\n                    ToolError(message=\"\", brief=\"Interrupted\")\n                    if is_interrupt\n                    else ToolOk(output=\"\")\n                )\n        self._last_tool_call_block = None\n        self.flush_finished_tool_calls()\n\n        while self._approval_request_queue:\n            # should not happen, but just in case\n            self._approval_request_queue.popleft().resolve(\"reject\")\n        self._current_approval_request_panel = None\n        self._reject_all_following = False\n\n    def flush_content(self) -> None:\n        \"\"\"Flush the current content block.\"\"\"\n        if self._current_content_block is not None:\n            console.print(self._current_content_block.compose_final())\n            self._current_content_block = None\n            self.refresh_soon()\n\n    def flush_finished_tool_calls(self) -> None:\n        \"\"\"Flush all leading finished tool call blocks.\"\"\"\n        tool_call_ids = list(self._tool_call_blocks.keys())\n        for tool_call_id in tool_call_ids:\n            block = self._tool_call_blocks[tool_call_id]\n            if not block.finished:\n                break\n\n            self._tool_call_blocks.pop(tool_call_id)\n            console.print(block.compose())\n            if self._last_tool_call_block == block:\n                self._last_tool_call_block = None\n            self.refresh_soon()\n\n    def append_content(self, part: ContentPart) -> None:\n        match part:\n            case ThinkPart(think=text) | TextPart(text=text):\n                if not text:\n                    return\n                is_think = isinstance(part, ThinkPart)\n                if self._current_content_block is None:\n                    self._current_content_block = _ContentBlock(is_think)\n                    self.refresh_soon()\n                elif self._current_content_block.is_think != is_think:\n                    self.flush_content()\n                    self._current_content_block = _ContentBlock(is_think)\n                    self.refresh_soon()\n                self._current_content_block.append(text)\n            case _:\n                # TODO: support more content part types\n                pass\n\n    def append_tool_call(self, tool_call: ToolCall) -> None:\n        self.flush_content()\n        self._tool_call_blocks[tool_call.id] = _ToolCallBlock(tool_call)\n        self._last_tool_call_block = self._tool_call_blocks[tool_call.id]\n        self.refresh_soon()\n\n    def append_tool_call_part(self, part: ToolCallPart) -> None:\n        if not part.arguments_part:\n            return\n        if self._last_tool_call_block is None:\n            return\n        self._last_tool_call_block.append_args_part(part.arguments_part)\n        self.refresh_soon()\n\n    def append_tool_result(self, result: ToolResult) -> None:\n        if block := self._tool_call_blocks.get(result.tool_call_id):\n            block.finish(result.return_value)\n            self.flush_finished_tool_calls()\n            self.refresh_soon()\n\n    def request_approval(self, request: ApprovalRequest) -> None:\n        # If we're rejecting all following requests, reject immediately\n        if self._reject_all_following:\n            request.resolve(\"reject\")\n            return\n\n        self._approval_request_queue.append(request)\n\n        if self._current_approval_request_panel is None:\n            console.bell()\n            self.show_next_approval_request()\n\n    def show_next_approval_request(self) -> None:\n        \"\"\"\n        Show the next approval request from the queue.\n        If there are no pending requests, clear the current approval panel.\n        \"\"\"\n        if not self._approval_request_queue:\n            if self._current_approval_request_panel is not None:\n                self._current_approval_request_panel = None\n                self.refresh_soon()\n            return\n\n        while self._approval_request_queue:\n            request = self._approval_request_queue.popleft()\n            if request.resolved:\n                # skip resolved requests\n                continue\n            self._current_approval_request_panel = _ApprovalRequestPanel(request)\n            self.refresh_soon()\n            break\n\n    def handle_subagent_event(self, event: SubagentEvent) -> None:\n        block = self._tool_call_blocks.get(event.task_tool_call_id)\n        if block is None:\n            return\n\n        match event.event:\n            case ToolCall() as tool_call:\n                block.append_sub_tool_call(tool_call)\n            case ToolCallPart() as tool_call_part:\n                block.append_sub_tool_call_part(tool_call_part)\n            case ToolResult() as tool_result:\n                block.finish_sub_tool_call(tool_result)\n                self.refresh_soon()\n            case _:\n                # ignore other events for now\n                # TODO: may need to handle multi-level nested subagents\n                pass\n","structuredPatch":[{"oldStart":202,"oldLines":9,"newStart":202,"newLines":16,"lines":[" ","     def _compose(self) -> RenderableType:","         lines: list[RenderableType] = [","-            Text.from_markup(self._get_headline_markup()),","+            self._build_headline_text(),","         ]"," ","+        # Show full URL hint when URL was truncated","+        if self._full_url and self._full_url != self._argument:","+            url_hint = Text()","+            url_hint.append(\"  ↳ \", style=\"grey50\")","+            url_hint.append(self._full_url, style=Style(color=\"grey50\", link=self._full_url))","+            lines.append(url_hint)","+","         if self._n_finished_subagent_tool_calls > MAX_SUBAGENT_TOOL_CALLS_TO_SHOW:","             n_hidden = self._n_finished_subagent_tool_calls - MAX_SUBAGENT_TOOL_CALLS_TO_SHOW","             lines.append("]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"ccd8165a-bee2-4965-9ebd-c43df10c6eb6"}
{"parentUuid":"e39e70e6-26d5-4e78-b157-943828b79102","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_017td5qPZryEAkckFmZiiL3t","type":"message","role":"assistant","content":[{"type":"text","text":"**Step 6: Update subagent tool call display to also handle FetchURL URLs**"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":612,"cache_read_input_tokens":35309,"cache_creation":{"ephemeral_5m_input_tokens":612,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"type":"assistant","uuid":"d820b330-50a8-4b67-9f60-1d4cfb7b12bd","timestamp":"2026-02-25T08:05:49.303Z"}
{"parentUuid":"d820b330-50a8-4b67-9f60-1d4cfb7b12bd","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_017td5qPZryEAkckFmZiiL3t","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015zb2DcUdGgUhsEhY7dBPKn","name":"Edit","input":{"replace_all":false,"file_path":"/Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/ui/shell/visualize.py","old_string":"        for sub_call, sub_result in self._finished_subagent_tool_calls:\n            argument = extract_key_argument(\n                sub_call.function.arguments or \"\", sub_call.function.name\n            )\n            lines.append(\n                BulletColumns(\n                    Text.from_markup(\n                        f\"Used [blue]{sub_call.function.name}[/blue]\"\n                        + (f\" [grey50]({argument})[/grey50]\" if argument else \"\")\n                    ),\n                    bullet_style=\"green\" if not sub_result.is_error else \"red\",\n                )\n            )","new_string":"        for sub_call, sub_result in self._finished_subagent_tool_calls:\n            sub_args = sub_call.function.arguments or \"\"\n            argument = extract_key_argument(sub_args, sub_call.function.name)\n            sub_full_url = self._extract_full_url(sub_args, sub_call.function.name)\n\n            sub_headline = Text()\n            sub_headline.append(\"Used \")\n            sub_headline.append(sub_call.function.name, style=\"blue\")\n            if argument:\n                sub_headline.append(\" (\", style=\"grey50\")\n                sub_arg_style = (\n                    Style(color=\"grey50\", link=sub_full_url)\n                    if sub_full_url\n                    else \"grey50\"\n                )\n                sub_headline.append(argument, style=sub_arg_style)\n                sub_headline.append(\")\", style=\"grey50\")\n\n            sub_lines: list[RenderableType] = [sub_headline]\n            if sub_full_url and sub_full_url != argument:\n                sub_url_hint = Text()\n                sub_url_hint.append(\"  ↳ \", style=\"grey50\")\n                sub_url_hint.append(\n                    sub_full_url,\n                    style=Style(color=\"grey50\", link=sub_full_url),\n                )\n                sub_lines.append(sub_url_hint)\n\n            lines.append(\n                BulletColumns(\n                    Group(*sub_lines) if len(sub_lines) > 1 else sub_headline,\n                    bullet_style=\"green\" if not sub_result.is_error else \"red\",\n                )\n            )"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":612,"cache_read_input_tokens":35309,"output_tokens":728,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":612},"inference_geo":"","iterations":[],"speed":"standard"}},"type":"assistant","uuid":"1ee9ce44-bdc3-4bd7-b5dd-891993de517c","timestamp":"2026-02-25T08:05:56.202Z"}
{"parentUuid":"1ee9ce44-bdc3-4bd7-b5dd-891993de517c","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_015zb2DcUdGgUhsEhY7dBPKn","toolUseID":"toolu_015zb2DcUdGgUhsEhY7dBPKn","timestamp":"2026-02-25T08:05:56.240Z","uuid":"fcaddd47-908f-4992-938d-753b1e2ecb3b"}
{"parentUuid":"1ee9ce44-bdc3-4bd7-b5dd-891993de517c","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015zb2DcUdGgUhsEhY7dBPKn","type":"tool_result","content":"The file /Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/ui/shell/visualize.py has been updated successfully."}]},"uuid":"99aae5ba-7d3d-400d-8ce9-e9ec1661110f","timestamp":"2026-02-25T08:05:56.240Z","toolUseResult":{"filePath":"/Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/ui/shell/visualize.py","oldString":"        for sub_call, sub_result in self._finished_subagent_tool_calls:\n            argument = extract_key_argument(\n                sub_call.function.arguments or \"\", sub_call.function.name\n            )\n            lines.append(\n                BulletColumns(\n                    Text.from_markup(\n                        f\"Used [blue]{sub_call.function.name}[/blue]\"\n                        + (f\" [grey50]({argument})[/grey50]\" if argument else \"\")\n                    ),\n                    bullet_style=\"green\" if not sub_result.is_error else \"red\",\n                )\n            )","newString":"        for sub_call, sub_result in self._finished_subagent_tool_calls:\n            sub_args = sub_call.function.arguments or \"\"\n            argument = extract_key_argument(sub_args, sub_call.function.name)\n            sub_full_url = self._extract_full_url(sub_args, sub_call.function.name)\n\n            sub_headline = Text()\n            sub_headline.append(\"Used \")\n            sub_headline.append(sub_call.function.name, style=\"blue\")\n            if argument:\n                sub_headline.append(\" (\", style=\"grey50\")\n                sub_arg_style = (\n                    Style(color=\"grey50\", link=sub_full_url)\n                    if sub_full_url\n                    else \"grey50\"\n                )\n                sub_headline.append(argument, style=sub_arg_style)\n                sub_headline.append(\")\", style=\"grey50\")\n\n            sub_lines: list[RenderableType] = [sub_headline]\n            if sub_full_url and sub_full_url != argument:\n                sub_url_hint = Text()\n                sub_url_hint.append(\"  ↳ \", style=\"grey50\")\n                sub_url_hint.append(\n                    sub_full_url,\n                    style=Style(color=\"grey50\", link=sub_full_url),\n                )\n                sub_lines.append(sub_url_hint)\n\n            lines.append(\n                BulletColumns(\n                    Group(*sub_lines) if len(sub_lines) > 1 else sub_headline,\n                    bullet_style=\"green\" if not sub_result.is_error else \"red\",\n                )\n            )","originalFile":"from __future__ import annotations\n\nimport asyncio\nimport json\nfrom collections import deque\nfrom collections.abc import Awaitable, Callable\nfrom contextlib import asynccontextmanager, suppress\nfrom typing import NamedTuple\n\nimport streamingjson  # type: ignore[reportMissingTypeStubs]\nfrom kosong.message import Message\nfrom kosong.tooling import ToolError, ToolOk\nfrom rich.console import Group, RenderableType\nfrom rich.live import Live\nfrom rich.markup import escape\nfrom rich.padding import Padding\nfrom rich.panel import Panel\nfrom rich.spinner import Spinner\nfrom rich.style import Style\nfrom rich.text import Text\n\nfrom kimi_cli.tools import extract_key_argument\nfrom kimi_cli.ui.shell.console import console\nfrom kimi_cli.ui.shell.keyboard import KeyboardListener, KeyEvent\nfrom kimi_cli.utils.aioqueue import QueueShutDown\nfrom kimi_cli.utils.diff import format_unified_diff\nfrom kimi_cli.utils.logging import logger\nfrom kimi_cli.utils.message import message_stringify\nfrom kimi_cli.utils.rich.columns import BulletColumns\nfrom kimi_cli.utils.rich.markdown import Markdown\nfrom kimi_cli.utils.rich.syntax import KimiSyntax\nfrom kimi_cli.wire import WireUISide\nfrom kimi_cli.wire.types import (\n    ApprovalRequest,\n    ApprovalResponse,\n    BriefDisplayBlock,\n    CompactionBegin,\n    CompactionEnd,\n    ContentPart,\n    DiffDisplayBlock,\n    ShellDisplayBlock,\n    StatusUpdate,\n    StepBegin,\n    StepInterrupted,\n    SubagentEvent,\n    TextPart,\n    ThinkPart,\n    TodoDisplayBlock,\n    ToolCall,\n    ToolCallPart,\n    ToolCallRequest,\n    ToolResult,\n    ToolReturnValue,\n    TurnBegin,\n    TurnEnd,\n    WireMessage,\n)\n\nMAX_SUBAGENT_TOOL_CALLS_TO_SHOW = 4\n\n# Truncation limits for approval request display\nMAX_PREVIEW_LINES = 4\n\n\nasync def visualize(\n    wire: WireUISide,\n    *,\n    initial_status: StatusUpdate,\n    cancel_event: asyncio.Event | None = None,\n):\n    \"\"\"\n    A loop to consume agent events and visualize the agent behavior.\n\n    Args:\n        wire: Communication channel with the agent\n        initial_status: Initial status snapshot\n        cancel_event: Event that can be set (e.g., by ESC key) to cancel the run\n    \"\"\"\n    view = _LiveView(initial_status, cancel_event)\n    await view.visualize_loop(wire)\n\n\nclass _ContentBlock:\n    def __init__(self, is_think: bool):\n        self.is_think = is_think\n        self._spinner = Spinner(\"dots\", \"Thinking...\" if is_think else \"Composing...\")\n        self.raw_text = \"\"\n\n    def compose(self) -> RenderableType:\n        return self._spinner\n\n    def compose_final(self) -> RenderableType:\n        return BulletColumns(\n            Markdown(\n                self.raw_text,\n                style=\"grey50 italic\" if self.is_think else \"\",\n            ),\n            bullet_style=\"grey50\" if self.is_think else None,\n        )\n\n    def append(self, content: str) -> None:\n        self.raw_text += content\n\n\nclass _ToolCallBlock:\n    class FinishedSubCall(NamedTuple):\n        call: ToolCall\n        result: ToolReturnValue\n\n    @staticmethod\n    def _extract_full_url(\n        json_content: str | streamingjson.Lexer, tool_name: str\n    ) -> str | None:\n        if tool_name != \"FetchURL\":\n            return None\n        json_str = (\n            json_content.complete_json()\n            if isinstance(json_content, streamingjson.Lexer)\n            else json_content\n        )\n        try:\n            args = json.loads(json_str)\n        except (json.JSONDecodeError, ValueError):\n            return None\n        if isinstance(args, dict) and args.get(\"url\"):\n            return str(args[\"url\"])\n        return None\n\n    def __init__(self, tool_call: ToolCall):\n        self._tool_name = tool_call.function.name\n        self._lexer = streamingjson.Lexer()\n        if tool_call.function.arguments is not None:\n            self._lexer.append_string(tool_call.function.arguments)\n\n        self._argument = extract_key_argument(self._lexer, self._tool_name)\n        self._full_url = self._extract_full_url(self._lexer, self._tool_name)\n        self._result: ToolReturnValue | None = None\n\n        self._ongoing_subagent_tool_calls: dict[str, ToolCall] = {}\n        self._last_subagent_tool_call: ToolCall | None = None\n        self._n_finished_subagent_tool_calls = 0\n        self._finished_subagent_tool_calls = deque[_ToolCallBlock.FinishedSubCall](\n            maxlen=MAX_SUBAGENT_TOOL_CALLS_TO_SHOW\n        )\n\n        self._spinning_dots = Spinner(\"dots\", text=\"\")\n        self._renderable: RenderableType = self._compose()\n\n    def compose(self) -> RenderableType:\n        return self._renderable\n\n    @property\n    def finished(self) -> bool:\n        return self._result is not None\n\n    def append_args_part(self, args_part: str):\n        if self.finished:\n            return\n        self._lexer.append_string(args_part)\n        # TODO: maybe don't extract detail if it's already stable\n        argument = extract_key_argument(self._lexer, self._tool_name)\n        if argument and argument != self._argument:\n            self._argument = argument\n            self._full_url = self._extract_full_url(self._lexer, self._tool_name)\n            self._renderable = BulletColumns(\n                self._build_headline_text(),\n                bullet=self._spinning_dots,\n            )\n\n    def finish(self, result: ToolReturnValue):\n        self._result = result\n        self._renderable = self._compose()\n\n    def append_sub_tool_call(self, tool_call: ToolCall):\n        self._ongoing_subagent_tool_calls[tool_call.id] = tool_call\n        self._last_subagent_tool_call = tool_call\n\n    def append_sub_tool_call_part(self, tool_call_part: ToolCallPart):\n        if self._last_subagent_tool_call is None:\n            return\n        if not tool_call_part.arguments_part:\n            return\n        if self._last_subagent_tool_call.function.arguments is None:\n            self._last_subagent_tool_call.function.arguments = tool_call_part.arguments_part\n        else:\n            self._last_subagent_tool_call.function.arguments += tool_call_part.arguments_part\n\n    def finish_sub_tool_call(self, tool_result: ToolResult):\n        self._last_subagent_tool_call = None\n        sub_tool_call = self._ongoing_subagent_tool_calls.pop(tool_result.tool_call_id, None)\n        if sub_tool_call is None:\n            return\n\n        self._finished_subagent_tool_calls.append(\n            _ToolCallBlock.FinishedSubCall(\n                call=sub_tool_call,\n                result=tool_result.return_value,\n            )\n        )\n        self._n_finished_subagent_tool_calls += 1\n        self._renderable = self._compose()\n\n    def _compose(self) -> RenderableType:\n        lines: list[RenderableType] = [\n            self._build_headline_text(),\n        ]\n\n        # Show full URL hint when URL was truncated\n        if self._full_url and self._full_url != self._argument:\n            url_hint = Text()\n            url_hint.append(\"  ↳ \", style=\"grey50\")\n            url_hint.append(self._full_url, style=Style(color=\"grey50\", link=self._full_url))\n            lines.append(url_hint)\n\n        if self._n_finished_subagent_tool_calls > MAX_SUBAGENT_TOOL_CALLS_TO_SHOW:\n            n_hidden = self._n_finished_subagent_tool_calls - MAX_SUBAGENT_TOOL_CALLS_TO_SHOW\n            lines.append(\n                BulletColumns(\n                    Text(\n                        f\"{n_hidden} more tool call{'s' if n_hidden > 1 else ''} ...\",\n                        style=\"grey50 italic\",\n                    ),\n                    bullet_style=\"grey50\",\n                )\n            )\n        for sub_call, sub_result in self._finished_subagent_tool_calls:\n            argument = extract_key_argument(\n                sub_call.function.arguments or \"\", sub_call.function.name\n            )\n            lines.append(\n                BulletColumns(\n                    Text.from_markup(\n                        f\"Used [blue]{sub_call.function.name}[/blue]\"\n                        + (f\" [grey50]({argument})[/grey50]\" if argument else \"\")\n                    ),\n                    bullet_style=\"green\" if not sub_result.is_error else \"red\",\n                )\n            )\n\n        if self._result is not None:\n            for block in self._result.display:\n                if isinstance(block, BriefDisplayBlock):\n                    style = \"grey50\" if not self._result.is_error else \"red\"\n                    if block.text:\n                        lines.append(Markdown(block.text, style=style))\n                elif isinstance(block, TodoDisplayBlock):\n                    markdown = self._render_todo_markdown(block)\n                    if markdown:\n                        lines.append(Markdown(markdown, style=\"grey50\"))\n\n        if self.finished:\n            assert self._result is not None\n            return BulletColumns(\n                Group(*lines),\n                bullet_style=\"green\" if not self._result.is_error else \"red\",\n            )\n        else:\n            return BulletColumns(\n                Group(*lines),\n                bullet=self._spinning_dots,\n            )\n\n    def _build_headline_text(self) -> Text:\n        text = Text()\n        text.append(\"Used \" if self.finished else \"Using \")\n        text.append(self._tool_name, style=\"blue\")\n        if self._argument:\n            text.append(\" (\", style=\"grey50\")\n            arg_style = (\n                Style(color=\"grey50\", link=self._full_url)\n                if self._full_url\n                else \"grey50\"\n            )\n            text.append(self._argument, style=arg_style)\n            text.append(\")\", style=\"grey50\")\n        return text\n\n    def _render_todo_markdown(self, block: TodoDisplayBlock) -> str:\n        lines: list[str] = []\n        for todo in block.items:\n            normalized = todo.status.replace(\"_\", \" \").lower()\n            match normalized:\n                case \"pending\":\n                    lines.append(f\"- {todo.title}\")\n                case \"in progress\":\n                    lines.append(f\"- {todo.title} ←\")\n                case \"done\":\n                    lines.append(f\"- ~~{todo.title}~~\")\n                case _:\n                    lines.append(f\"- {todo.title}\")\n        return \"\\n\".join(lines)\n\n\nclass _ApprovalContentBlock(NamedTuple):\n    \"\"\"A pre-rendered content block for approval request with line count.\"\"\"\n\n    text: str\n    lines: int\n    style: str = \"\"\n    lexer: str = \"\"\n\n\nclass _ApprovalRequestPanel:\n    def __init__(self, request: ApprovalRequest):\n        self.request = request\n        self.options: list[tuple[str, ApprovalResponse.Kind]] = [\n            (\"Approve once\", \"approve\"),\n            (\"Approve for this session\", \"approve_for_session\"),\n            (\"Reject, tell Kimi what to do instead\", \"reject\"),\n        ]\n        self.selected_index = 0\n\n        # Pre-render all content blocks with line counts\n        self._content_blocks: list[_ApprovalContentBlock] = []\n        last_diff_path: str | None = None\n\n        # Handle description (only if no display blocks)\n        if request.description and not request.display:\n            text = request.description.rstrip(\"\\n\")\n            self._content_blocks.append(\n                _ApprovalContentBlock(text=text, lines=text.count(\"\\n\") + 1)\n            )\n\n        # Handle display blocks\n        for block in request.display:\n            if isinstance(block, DiffDisplayBlock):\n                # File path or ellipsis\n                if block.path != last_diff_path:\n                    self._content_blocks.append(\n                        _ApprovalContentBlock(text=block.path, lines=1, style=\"bold\")\n                    )\n                    last_diff_path = block.path\n                else:\n                    self._content_blocks.append(\n                        _ApprovalContentBlock(text=\"⋮\", lines=1, style=\"dim\")\n                    )\n                # Diff content\n                diff_text = format_unified_diff(\n                    block.old_text,\n                    block.new_text,\n                    block.path,\n                    include_file_header=False,\n                ).rstrip(\"\\n\")\n                self._content_blocks.append(\n                    _ApprovalContentBlock(\n                        text=diff_text, lines=diff_text.count(\"\\n\") + 1, lexer=\"diff\"\n                    )\n                )\n            elif isinstance(block, ShellDisplayBlock):\n                text = block.command.rstrip(\"\\n\")\n                self._content_blocks.append(\n                    _ApprovalContentBlock(\n                        text=text, lines=text.count(\"\\n\") + 1, lexer=block.language\n                    )\n                )\n                last_diff_path = None\n            elif isinstance(block, BriefDisplayBlock) and block.text:\n                text = block.text.rstrip(\"\\n\")\n                self._content_blocks.append(\n                    _ApprovalContentBlock(text=text, lines=text.count(\"\\n\") + 1, style=\"grey50\")\n                )\n                last_diff_path = None\n\n        self._total_lines = sum(b.lines for b in self._content_blocks)\n        self.has_expandable_content = self._total_lines > MAX_PREVIEW_LINES\n\n    def render(self) -> RenderableType:\n        \"\"\"Render the approval menu as a panel.\"\"\"\n        content_lines: list[RenderableType] = [\n            Text.from_markup(\n                \"[yellow]⚠ \"\n                f\"{escape(self.request.sender)} is requesting approval to \"\n                f\"{escape(self.request.action)}:[/yellow]\"\n            )\n        ]\n        content_lines.append(Text(\"\"))\n\n        # Render content with line budget\n        remaining = MAX_PREVIEW_LINES\n        for block in self._content_blocks:\n            if remaining <= 0:\n                break\n            content_lines.append(self._render_block(block, remaining))\n            remaining -= min(block.lines, remaining)\n\n        if self.has_expandable_content:\n            content_lines.append(Text(\"... (truncated, ctrl-e to expand)\", style=\"dim italic\"))\n\n        lines: list[RenderableType] = []\n        if content_lines:\n            lines.append(Padding(Group(*content_lines), (0, 0, 0, 2)))\n\n        # Add menu options\n        if lines:\n            lines.append(Text(\"\"))\n        for i, (option_text, _) in enumerate(self.options):\n            if i == self.selected_index:\n                lines.append(Text(f\"→ {option_text}\", style=\"cyan\"))\n            else:\n                lines.append(Text(f\"  {option_text}\", style=\"grey50\"))\n\n        return Padding(Group(*lines), 1)\n\n    def _render_block(\n        self, block: _ApprovalContentBlock, max_lines: int | None = None\n    ) -> RenderableType:\n        \"\"\"Render a content block, optionally truncated.\"\"\"\n        text = block.text\n        if max_lines is not None and block.lines > max_lines:\n            # Truncate to max_lines\n            text = \"\\n\".join(text.split(\"\\n\")[:max_lines])\n\n        if block.lexer:\n            return KimiSyntax(text, block.lexer)\n        return Text(text, style=block.style)\n\n    def render_full(self) -> list[RenderableType]:\n        \"\"\"Render full content for pager (no truncation).\"\"\"\n        return [self._render_block(block) for block in self._content_blocks]\n\n    def move_up(self):\n        \"\"\"Move selection up.\"\"\"\n        self.selected_index = (self.selected_index - 1) % len(self.options)\n\n    def move_down(self):\n        \"\"\"Move selection down.\"\"\"\n        self.selected_index = (self.selected_index + 1) % len(self.options)\n\n    def get_selected_response(self) -> ApprovalResponse.Kind:\n        \"\"\"Get the approval response based on selected option.\"\"\"\n        return self.options[self.selected_index][1]\n\n\ndef _show_approval_in_pager(panel: _ApprovalRequestPanel) -> None:\n    \"\"\"Show the full approval request content in a pager.\"\"\"\n    with console.screen(), console.pager(styles=True):\n        # Header: matches the style in _ApprovalRequestPanel.render()\n        console.print(\n            Text.from_markup(\n                \"[yellow]⚠ \"\n                f\"{escape(panel.request.sender)} is requesting approval to \"\n                f\"{escape(panel.request.action)}:[/yellow]\"\n            )\n        )\n        console.print()\n\n        # Render full content (no truncation)\n        for renderable in panel.render_full():\n            console.print(renderable)\n\n\nclass _StatusBlock:\n    def __init__(self, initial: StatusUpdate) -> None:\n        self.text = Text(\"\", justify=\"right\")\n        self.update(initial)\n\n    def render(self) -> RenderableType:\n        return self.text\n\n    def update(self, status: StatusUpdate) -> None:\n        if status.context_usage is not None:\n            self.text.plain = f\"context: {status.context_usage:.1%}\"\n\n\n@asynccontextmanager\nasync def _keyboard_listener(\n    handler: Callable[[KeyboardListener, KeyEvent], Awaitable[None]],\n):\n    listener = KeyboardListener()\n    await listener.start()\n\n    async def _keyboard():\n        while True:\n            event = await listener.get()\n            await handler(listener, event)\n\n    task = asyncio.create_task(_keyboard())\n    try:\n        yield\n    finally:\n        task.cancel()\n        with suppress(asyncio.CancelledError):\n            await task\n        await listener.stop()\n\n\nclass _LiveView:\n    def __init__(self, initial_status: StatusUpdate, cancel_event: asyncio.Event | None = None):\n        self._cancel_event = cancel_event\n\n        self._mooning_spinner: Spinner | None = None\n        self._compacting_spinner: Spinner | None = None\n\n        self._current_content_block: _ContentBlock | None = None\n        self._tool_call_blocks: dict[str, _ToolCallBlock] = {}\n        self._last_tool_call_block: _ToolCallBlock | None = None\n        self._approval_request_queue = deque[ApprovalRequest]()\n        \"\"\"\n        It is possible that multiple subagents request approvals at the same time,\n        in which case we will have to queue them up and show them one by one.\n        \"\"\"\n        self._current_approval_request_panel: _ApprovalRequestPanel | None = None\n        self._reject_all_following = False\n        self._status_block = _StatusBlock(initial_status)\n\n        self._need_recompose = False\n\n    def _reset_live_shape(self, live: Live) -> None:\n        # Rich doesn't expose a public API to clear Live's cached render height.\n        # After leaving the pager, stale height causes cursor restores to jump,\n        # so we reset the private _shape to re-anchor the next refresh.\n        live._live_render._shape = None  # type: ignore[reportPrivateUsage]\n\n    async def visualize_loop(self, wire: WireUISide):\n        with Live(\n            self.compose(),\n            console=console,\n            refresh_per_second=10,\n            transient=True,\n            vertical_overflow=\"visible\",\n        ) as live:\n\n            async def keyboard_handler(listener: KeyboardListener, event: KeyEvent) -> None:\n                # Handle Ctrl+E specially - pause Live while the pager is active\n                if event == KeyEvent.CTRL_E:\n                    if (\n                        self._current_approval_request_panel\n                        and self._current_approval_request_panel.has_expandable_content\n                    ):\n                        await listener.pause()\n                        live.stop()\n                        try:\n                            _show_approval_in_pager(self._current_approval_request_panel)\n                        finally:\n                            # Reset live render shape so the next refresh re-anchors cleanly.\n                            self._reset_live_shape(live)\n                            live.start()\n                            live.update(self.compose(), refresh=True)\n                            await listener.resume()\n                    return\n\n                self.dispatch_keyboard_event(event)\n                if self._need_recompose:\n                    live.update(self.compose(), refresh=True)\n                    self._need_recompose = False\n\n            async with _keyboard_listener(keyboard_handler):\n                while True:\n                    try:\n                        msg = await wire.receive()\n                    except QueueShutDown:\n                        self.cleanup(is_interrupt=False)\n                        live.update(self.compose(), refresh=True)\n                        break\n\n                    if isinstance(msg, StepInterrupted):\n                        self.cleanup(is_interrupt=True)\n                        live.update(self.compose(), refresh=True)\n                        break\n\n                    self.dispatch_wire_message(msg)\n                    if self._need_recompose:\n                        live.update(self.compose(), refresh=True)\n                        self._need_recompose = False\n\n    def refresh_soon(self) -> None:\n        self._need_recompose = True\n\n    def compose(self) -> RenderableType:\n        \"\"\"Compose the live view display content.\"\"\"\n        blocks: list[RenderableType] = []\n        if self._mooning_spinner is not None:\n            blocks.append(self._mooning_spinner)\n        elif self._compacting_spinner is not None:\n            blocks.append(self._compacting_spinner)\n        else:\n            if self._current_content_block is not None:\n                blocks.append(self._current_content_block.compose())\n            for tool_call in self._tool_call_blocks.values():\n                blocks.append(tool_call.compose())\n        if self._current_approval_request_panel:\n            blocks.append(self._current_approval_request_panel.render())\n        blocks.append(self._status_block.render())\n        return Group(*blocks)\n\n    def dispatch_wire_message(self, msg: WireMessage) -> None:\n        \"\"\"Dispatch the Wire message to UI components.\"\"\"\n        assert not isinstance(msg, StepInterrupted)  # handled in visualize_loop\n\n        if isinstance(msg, StepBegin):\n            self.cleanup(is_interrupt=False)\n            self._mooning_spinner = Spinner(\"moon\", \"\")\n            self.refresh_soon()\n            return\n\n        if self._mooning_spinner is not None:\n            # any message other than StepBegin should end the mooning state\n            self._mooning_spinner = None\n            self.refresh_soon()\n\n        match msg:\n            case TurnBegin():\n                self.flush_content()\n                console.print(\n                    Panel(\n                        Text(message_stringify(Message(role=\"user\", content=msg.user_input))),\n                        padding=(0, 1),\n                    )\n                )\n            case TurnEnd():\n                pass\n            case CompactionBegin():\n                self._compacting_spinner = Spinner(\"balloon\", \"Compacting...\")\n                self.refresh_soon()\n            case CompactionEnd():\n                self._compacting_spinner = None\n                self.refresh_soon()\n            case StatusUpdate():\n                self._status_block.update(msg)\n            case ContentPart():\n                self.append_content(msg)\n            case ToolCall():\n                self.append_tool_call(msg)\n            case ToolCallPart():\n                self.append_tool_call_part(msg)\n            case ToolResult():\n                self.append_tool_result(msg)\n            case ApprovalResponse():\n                # we don't need to handle this because the request is resolved on UI\n                pass\n            case SubagentEvent():\n                self.handle_subagent_event(msg)\n            case ApprovalRequest():\n                self.request_approval(msg)\n            case ToolCallRequest():\n                logger.warning(\"Unexpected ToolCallRequest in shell UI: {msg}\", msg=msg)\n\n    def dispatch_keyboard_event(self, event: KeyEvent) -> None:\n        # handle ESC key to cancel the run\n        if event == KeyEvent.ESCAPE and self._cancel_event is not None:\n            self._cancel_event.set()\n            return\n\n        if not self._current_approval_request_panel:\n            # just ignore any keyboard event when there's no approval request\n            return\n\n        match event:\n            case KeyEvent.UP:\n                self._current_approval_request_panel.move_up()\n                self.refresh_soon()\n            case KeyEvent.DOWN:\n                self._current_approval_request_panel.move_down()\n                self.refresh_soon()\n            case KeyEvent.ENTER:\n                resp = self._current_approval_request_panel.get_selected_response()\n                self._current_approval_request_panel.request.resolve(resp)\n                if resp == \"approve_for_session\":\n                    to_remove_from_queue: list[ApprovalRequest] = []\n                    for request in self._approval_request_queue:\n                        # approve all queued requests with the same action\n                        if request.action == self._current_approval_request_panel.request.action:\n                            request.resolve(\"approve_for_session\")\n                            to_remove_from_queue.append(request)\n                    for request in to_remove_from_queue:\n                        self._approval_request_queue.remove(request)\n                elif resp == \"reject\":\n                    # one rejection should stop the step immediately\n                    while self._approval_request_queue:\n                        self._approval_request_queue.popleft().resolve(\"reject\")\n                    self._reject_all_following = True\n                self.show_next_approval_request()\n            case _:\n                # just ignore any other keyboard event\n                return\n\n    def cleanup(self, is_interrupt: bool) -> None:\n        \"\"\"Cleanup the live view on step end or interruption.\"\"\"\n        self.flush_content()\n\n        for block in self._tool_call_blocks.values():\n            if not block.finished:\n                # this should not happen, but just in case\n                block.finish(\n                    ToolError(message=\"\", brief=\"Interrupted\")\n                    if is_interrupt\n                    else ToolOk(output=\"\")\n                )\n        self._last_tool_call_block = None\n        self.flush_finished_tool_calls()\n\n        while self._approval_request_queue:\n            # should not happen, but just in case\n            self._approval_request_queue.popleft().resolve(\"reject\")\n        self._current_approval_request_panel = None\n        self._reject_all_following = False\n\n    def flush_content(self) -> None:\n        \"\"\"Flush the current content block.\"\"\"\n        if self._current_content_block is not None:\n            console.print(self._current_content_block.compose_final())\n            self._current_content_block = None\n            self.refresh_soon()\n\n    def flush_finished_tool_calls(self) -> None:\n        \"\"\"Flush all leading finished tool call blocks.\"\"\"\n        tool_call_ids = list(self._tool_call_blocks.keys())\n        for tool_call_id in tool_call_ids:\n            block = self._tool_call_blocks[tool_call_id]\n            if not block.finished:\n                break\n\n            self._tool_call_blocks.pop(tool_call_id)\n            console.print(block.compose())\n            if self._last_tool_call_block == block:\n                self._last_tool_call_block = None\n            self.refresh_soon()\n\n    def append_content(self, part: ContentPart) -> None:\n        match part:\n            case ThinkPart(think=text) | TextPart(text=text):\n                if not text:\n                    return\n                is_think = isinstance(part, ThinkPart)\n                if self._current_content_block is None:\n                    self._current_content_block = _ContentBlock(is_think)\n                    self.refresh_soon()\n                elif self._current_content_block.is_think != is_think:\n                    self.flush_content()\n                    self._current_content_block = _ContentBlock(is_think)\n                    self.refresh_soon()\n                self._current_content_block.append(text)\n            case _:\n                # TODO: support more content part types\n                pass\n\n    def append_tool_call(self, tool_call: ToolCall) -> None:\n        self.flush_content()\n        self._tool_call_blocks[tool_call.id] = _ToolCallBlock(tool_call)\n        self._last_tool_call_block = self._tool_call_blocks[tool_call.id]\n        self.refresh_soon()\n\n    def append_tool_call_part(self, part: ToolCallPart) -> None:\n        if not part.arguments_part:\n            return\n        if self._last_tool_call_block is None:\n            return\n        self._last_tool_call_block.append_args_part(part.arguments_part)\n        self.refresh_soon()\n\n    def append_tool_result(self, result: ToolResult) -> None:\n        if block := self._tool_call_blocks.get(result.tool_call_id):\n            block.finish(result.return_value)\n            self.flush_finished_tool_calls()\n            self.refresh_soon()\n\n    def request_approval(self, request: ApprovalRequest) -> None:\n        # If we're rejecting all following requests, reject immediately\n        if self._reject_all_following:\n            request.resolve(\"reject\")\n            return\n\n        self._approval_request_queue.append(request)\n\n        if self._current_approval_request_panel is None:\n            console.bell()\n            self.show_next_approval_request()\n\n    def show_next_approval_request(self) -> None:\n        \"\"\"\n        Show the next approval request from the queue.\n        If there are no pending requests, clear the current approval panel.\n        \"\"\"\n        if not self._approval_request_queue:\n            if self._current_approval_request_panel is not None:\n                self._current_approval_request_panel = None\n                self.refresh_soon()\n            return\n\n        while self._approval_request_queue:\n            request = self._approval_request_queue.popleft()\n            if request.resolved:\n                # skip resolved requests\n                continue\n            self._current_approval_request_panel = _ApprovalRequestPanel(request)\n            self.refresh_soon()\n            break\n\n    def handle_subagent_event(self, event: SubagentEvent) -> None:\n        block = self._tool_call_blocks.get(event.task_tool_call_id)\n        if block is None:\n            return\n\n        match event.event:\n            case ToolCall() as tool_call:\n                block.append_sub_tool_call(tool_call)\n            case ToolCallPart() as tool_call_part:\n                block.append_sub_tool_call_part(tool_call_part)\n            case ToolResult() as tool_result:\n                block.finish_sub_tool_call(tool_result)\n                self.refresh_soon()\n            case _:\n                # ignore other events for now\n                # TODO: may need to handle multi-level nested subagents\n                pass\n","structuredPatch":[{"oldStart":224,"oldLines":15,"newStart":224,"newLines":36,"lines":["                 )","             )","         for sub_call, sub_result in self._finished_subagent_tool_calls:","-            argument = extract_key_argument(","-                sub_call.function.arguments or \"\", sub_call.function.name","-            )","+            sub_args = sub_call.function.arguments or \"\"","+            argument = extract_key_argument(sub_args, sub_call.function.name)","+            sub_full_url = self._extract_full_url(sub_args, sub_call.function.name)","+","+            sub_headline = Text()","+            sub_headline.append(\"Used \")","+            sub_headline.append(sub_call.function.name, style=\"blue\")","+            if argument:","+                sub_headline.append(\" (\", style=\"grey50\")","+                sub_arg_style = (","+                    Style(color=\"grey50\", link=sub_full_url)","+                    if sub_full_url","+                    else \"grey50\"","+                )","+                sub_headline.append(argument, style=sub_arg_style)","+                sub_headline.append(\")\", style=\"grey50\")","+","+            sub_lines: list[RenderableType] = [sub_headline]","+            if sub_full_url and sub_full_url != argument:","+                sub_url_hint = Text()","+                sub_url_hint.append(\"  ↳ \", style=\"grey50\")","+                sub_url_hint.append(","+                    sub_full_url,","+                    style=Style(color=\"grey50\", link=sub_full_url),","+                )","+                sub_lines.append(sub_url_hint)","+","             lines.append(","                 BulletColumns(","-                    Text.from_markup(","-                        f\"Used [blue]{sub_call.function.name}[/blue]\"","-                        + (f\" [grey50]({argument})[/grey50]\" if argument else \"\")","-                    ),","+                    Group(*sub_lines) if len(sub_lines) > 1 else sub_headline,","                     bullet_style=\"green\" if not sub_result.is_error else \"red\",","                 )","             )"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"1ee9ce44-bdc3-4bd7-b5dd-891993de517c"}
{"parentUuid":"99aae5ba-7d3d-400d-8ce9-e9ec1661110f","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_01DVMcSzUa2ong78Mf1MLs5K","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me verify the final file looks correct."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":779,"cache_read_input_tokens":35921,"cache_creation":{"ephemeral_5m_input_tokens":779,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"type":"assistant","uuid":"2e3db181-ea61-45ba-976f-ba2b6064c97c","timestamp":"2026-02-25T08:05:59.285Z"}
{"parentUuid":"2e3db181-ea61-45ba-976f-ba2b6064c97c","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_01DVMcSzUa2ong78Mf1MLs5K","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012NyU2zmXejftuQQvHqxv2S","name":"Read","input":{"file_path":"/Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/ui/shell/visualize.py","limit":280},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":779,"cache_read_input_tokens":35921,"cache_creation":{"ephemeral_5m_input_tokens":779,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"type":"assistant","uuid":"55bceef3-9816-4926-b6f3-a9f72675f720","timestamp":"2026-02-25T08:05:59.953Z"}
{"parentUuid":"55bceef3-9816-4926-b6f3-a9f72675f720","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_012NyU2zmXejftuQQvHqxv2S","toolUseID":"toolu_012NyU2zmXejftuQQvHqxv2S","timestamp":"2026-02-25T08:05:59.996Z","uuid":"2c8a9a9a-bed0-45f1-b09f-d29f66d34fab"}
{"parentUuid":"55bceef3-9816-4926-b6f3-a9f72675f720","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012NyU2zmXejftuQQvHqxv2S","type":"tool_result","content":"     1→from __future__ import annotations\n     2→\n     3→import asyncio\n     4→import json\n     5→from collections import deque\n     6→from collections.abc import Awaitable, Callable\n     7→from contextlib import asynccontextmanager, suppress\n     8→from typing import NamedTuple\n     9→\n    10→import streamingjson  # type: ignore[reportMissingTypeStubs]\n    11→from kosong.message import Message\n    12→from kosong.tooling import ToolError, ToolOk\n    13→from rich.console import Group, RenderableType\n    14→from rich.live import Live\n    15→from rich.markup import escape\n    16→from rich.padding import Padding\n    17→from rich.panel import Panel\n    18→from rich.spinner import Spinner\n    19→from rich.style import Style\n    20→from rich.text import Text\n    21→\n    22→from kimi_cli.tools import extract_key_argument\n    23→from kimi_cli.ui.shell.console import console\n    24→from kimi_cli.ui.shell.keyboard import KeyboardListener, KeyEvent\n    25→from kimi_cli.utils.aioqueue import QueueShutDown\n    26→from kimi_cli.utils.diff import format_unified_diff\n    27→from kimi_cli.utils.logging import logger\n    28→from kimi_cli.utils.message import message_stringify\n    29→from kimi_cli.utils.rich.columns import BulletColumns\n    30→from kimi_cli.utils.rich.markdown import Markdown\n    31→from kimi_cli.utils.rich.syntax import KimiSyntax\n    32→from kimi_cli.wire import WireUISide\n    33→from kimi_cli.wire.types import (\n    34→    ApprovalRequest,\n    35→    ApprovalResponse,\n    36→    BriefDisplayBlock,\n    37→    CompactionBegin,\n    38→    CompactionEnd,\n    39→    ContentPart,\n    40→    DiffDisplayBlock,\n    41→    ShellDisplayBlock,\n    42→    StatusUpdate,\n    43→    StepBegin,\n    44→    StepInterrupted,\n    45→    SubagentEvent,\n    46→    TextPart,\n    47→    ThinkPart,\n    48→    TodoDisplayBlock,\n    49→    ToolCall,\n    50→    ToolCallPart,\n    51→    ToolCallRequest,\n    52→    ToolResult,\n    53→    ToolReturnValue,\n    54→    TurnBegin,\n    55→    TurnEnd,\n    56→    WireMessage,\n    57→)\n    58→\n    59→MAX_SUBAGENT_TOOL_CALLS_TO_SHOW = 4\n    60→\n    61→# Truncation limits for approval request display\n    62→MAX_PREVIEW_LINES = 4\n    63→\n    64→\n    65→async def visualize(\n    66→    wire: WireUISide,\n    67→    *,\n    68→    initial_status: StatusUpdate,\n    69→    cancel_event: asyncio.Event | None = None,\n    70→):\n    71→    \"\"\"\n    72→    A loop to consume agent events and visualize the agent behavior.\n    73→\n    74→    Args:\n    75→        wire: Communication channel with the agent\n    76→        initial_status: Initial status snapshot\n    77→        cancel_event: Event that can be set (e.g., by ESC key) to cancel the run\n    78→    \"\"\"\n    79→    view = _LiveView(initial_status, cancel_event)\n    80→    await view.visualize_loop(wire)\n    81→\n    82→\n    83→class _ContentBlock:\n    84→    def __init__(self, is_think: bool):\n    85→        self.is_think = is_think\n    86→        self._spinner = Spinner(\"dots\", \"Thinking...\" if is_think else \"Composing...\")\n    87→        self.raw_text = \"\"\n    88→\n    89→    def compose(self) -> RenderableType:\n    90→        return self._spinner\n    91→\n    92→    def compose_final(self) -> RenderableType:\n    93→        return BulletColumns(\n    94→            Markdown(\n    95→                self.raw_text,\n    96→                style=\"grey50 italic\" if self.is_think else \"\",\n    97→            ),\n    98→            bullet_style=\"grey50\" if self.is_think else None,\n    99→        )\n   100→\n   101→    def append(self, content: str) -> None:\n   102→        self.raw_text += content\n   103→\n   104→\n   105→class _ToolCallBlock:\n   106→    class FinishedSubCall(NamedTuple):\n   107→        call: ToolCall\n   108→        result: ToolReturnValue\n   109→\n   110→    @staticmethod\n   111→    def _extract_full_url(\n   112→        json_content: str | streamingjson.Lexer, tool_name: str\n   113→    ) -> str | None:\n   114→        if tool_name != \"FetchURL\":\n   115→            return None\n   116→        json_str = (\n   117→            json_content.complete_json()\n   118→            if isinstance(json_content, streamingjson.Lexer)\n   119→            else json_content\n   120→        )\n   121→        try:\n   122→            args = json.loads(json_str)\n   123→        except (json.JSONDecodeError, ValueError):\n   124→            return None\n   125→        if isinstance(args, dict) and args.get(\"url\"):\n   126→            return str(args[\"url\"])\n   127→        return None\n   128→\n   129→    def __init__(self, tool_call: ToolCall):\n   130→        self._tool_name = tool_call.function.name\n   131→        self._lexer = streamingjson.Lexer()\n   132→        if tool_call.function.arguments is not None:\n   133→            self._lexer.append_string(tool_call.function.arguments)\n   134→\n   135→        self._argument = extract_key_argument(self._lexer, self._tool_name)\n   136→        self._full_url = self._extract_full_url(self._lexer, self._tool_name)\n   137→        self._result: ToolReturnValue | None = None\n   138→\n   139→        self._ongoing_subagent_tool_calls: dict[str, ToolCall] = {}\n   140→        self._last_subagent_tool_call: ToolCall | None = None\n   141→        self._n_finished_subagent_tool_calls = 0\n   142→        self._finished_subagent_tool_calls = deque[_ToolCallBlock.FinishedSubCall](\n   143→            maxlen=MAX_SUBAGENT_TOOL_CALLS_TO_SHOW\n   144→        )\n   145→\n   146→        self._spinning_dots = Spinner(\"dots\", text=\"\")\n   147→        self._renderable: RenderableType = self._compose()\n   148→\n   149→    def compose(self) -> RenderableType:\n   150→        return self._renderable\n   151→\n   152→    @property\n   153→    def finished(self) -> bool:\n   154→        return self._result is not None\n   155→\n   156→    def append_args_part(self, args_part: str):\n   157→        if self.finished:\n   158→            return\n   159→        self._lexer.append_string(args_part)\n   160→        # TODO: maybe don't extract detail if it's already stable\n   161→        argument = extract_key_argument(self._lexer, self._tool_name)\n   162→        if argument and argument != self._argument:\n   163→            self._argument = argument\n   164→            self._full_url = self._extract_full_url(self._lexer, self._tool_name)\n   165→            self._renderable = BulletColumns(\n   166→                self._build_headline_text(),\n   167→                bullet=self._spinning_dots,\n   168→            )\n   169→\n   170→    def finish(self, result: ToolReturnValue):\n   171→        self._result = result\n   172→        self._renderable = self._compose()\n   173→\n   174→    def append_sub_tool_call(self, tool_call: ToolCall):\n   175→        self._ongoing_subagent_tool_calls[tool_call.id] = tool_call\n   176→        self._last_subagent_tool_call = tool_call\n   177→\n   178→    def append_sub_tool_call_part(self, tool_call_part: ToolCallPart):\n   179→        if self._last_subagent_tool_call is None:\n   180→            return\n   181→        if not tool_call_part.arguments_part:\n   182→            return\n   183→        if self._last_subagent_tool_call.function.arguments is None:\n   184→            self._last_subagent_tool_call.function.arguments = tool_call_part.arguments_part\n   185→        else:\n   186→            self._last_subagent_tool_call.function.arguments += tool_call_part.arguments_part\n   187→\n   188→    def finish_sub_tool_call(self, tool_result: ToolResult):\n   189→        self._last_subagent_tool_call = None\n   190→        sub_tool_call = self._ongoing_subagent_tool_calls.pop(tool_result.tool_call_id, None)\n   191→        if sub_tool_call is None:\n   192→            return\n   193→\n   194→        self._finished_subagent_tool_calls.append(\n   195→            _ToolCallBlock.FinishedSubCall(\n   196→                call=sub_tool_call,\n   197→                result=tool_result.return_value,\n   198→            )\n   199→        )\n   200→        self._n_finished_subagent_tool_calls += 1\n   201→        self._renderable = self._compose()\n   202→\n   203→    def _compose(self) -> RenderableType:\n   204→        lines: list[RenderableType] = [\n   205→            self._build_headline_text(),\n   206→        ]\n   207→\n   208→        # Show full URL hint when URL was truncated\n   209→        if self._full_url and self._full_url != self._argument:\n   210→            url_hint = Text()\n   211→            url_hint.append(\"  ↳ \", style=\"grey50\")\n   212→            url_hint.append(self._full_url, style=Style(color=\"grey50\", link=self._full_url))\n   213→            lines.append(url_hint)\n   214→\n   215→        if self._n_finished_subagent_tool_calls > MAX_SUBAGENT_TOOL_CALLS_TO_SHOW:\n   216→            n_hidden = self._n_finished_subagent_tool_calls - MAX_SUBAGENT_TOOL_CALLS_TO_SHOW\n   217→            lines.append(\n   218→                BulletColumns(\n   219→                    Text(\n   220→                        f\"{n_hidden} more tool call{'s' if n_hidden > 1 else ''} ...\",\n   221→                        style=\"grey50 italic\",\n   222→                    ),\n   223→                    bullet_style=\"grey50\",\n   224→                )\n   225→            )\n   226→        for sub_call, sub_result in self._finished_subagent_tool_calls:\n   227→            sub_args = sub_call.function.arguments or \"\"\n   228→            argument = extract_key_argument(sub_args, sub_call.function.name)\n   229→            sub_full_url = self._extract_full_url(sub_args, sub_call.function.name)\n   230→\n   231→            sub_headline = Text()\n   232→            sub_headline.append(\"Used \")\n   233→            sub_headline.append(sub_call.function.name, style=\"blue\")\n   234→            if argument:\n   235→                sub_headline.append(\" (\", style=\"grey50\")\n   236→                sub_arg_style = (\n   237→                    Style(color=\"grey50\", link=sub_full_url)\n   238→                    if sub_full_url\n   239→                    else \"grey50\"\n   240→                )\n   241→                sub_headline.append(argument, style=sub_arg_style)\n   242→                sub_headline.append(\")\", style=\"grey50\")\n   243→\n   244→            sub_lines: list[RenderableType] = [sub_headline]\n   245→            if sub_full_url and sub_full_url != argument:\n   246→                sub_url_hint = Text()\n   247→                sub_url_hint.append(\"  ↳ \", style=\"grey50\")\n   248→                sub_url_hint.append(\n   249→                    sub_full_url,\n   250→                    style=Style(color=\"grey50\", link=sub_full_url),\n   251→                )\n   252→                sub_lines.append(sub_url_hint)\n   253→\n   254→            lines.append(\n   255→                BulletColumns(\n   256→                    Group(*sub_lines) if len(sub_lines) > 1 else sub_headline,\n   257→                    bullet_style=\"green\" if not sub_result.is_error else \"red\",\n   258→                )\n   259→            )\n   260→\n   261→        if self._result is not None:\n   262→            for block in self._result.display:\n   263→                if isinstance(block, BriefDisplayBlock):\n   264→                    style = \"grey50\" if not self._result.is_error else \"red\"\n   265→                    if block.text:\n   266→                        lines.append(Markdown(block.text, style=style))\n   267→                elif isinstance(block, TodoDisplayBlock):\n   268→                    markdown = self._render_todo_markdown(block)\n   269→                    if markdown:\n   270→                        lines.append(Markdown(markdown, style=\"grey50\"))\n   271→\n   272→        if self.finished:\n   273→            assert self._result is not None\n   274→            return BulletColumns(\n   275→                Group(*lines),\n   276→                bullet_style=\"green\" if not self._result.is_error else \"red\",\n   277→            )\n   278→        else:\n   279→            return BulletColumns(\n   280→                Group(*lines),"}]},"uuid":"66c75ef0-a710-495c-b717-cf2a81abf407","timestamp":"2026-02-25T08:05:59.996Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/ui/shell/visualize.py","content":"from __future__ import annotations\n\nimport asyncio\nimport json\nfrom collections import deque\nfrom collections.abc import Awaitable, Callable\nfrom contextlib import asynccontextmanager, suppress\nfrom typing import NamedTuple\n\nimport streamingjson  # type: ignore[reportMissingTypeStubs]\nfrom kosong.message import Message\nfrom kosong.tooling import ToolError, ToolOk\nfrom rich.console import Group, RenderableType\nfrom rich.live import Live\nfrom rich.markup import escape\nfrom rich.padding import Padding\nfrom rich.panel import Panel\nfrom rich.spinner import Spinner\nfrom rich.style import Style\nfrom rich.text import Text\n\nfrom kimi_cli.tools import extract_key_argument\nfrom kimi_cli.ui.shell.console import console\nfrom kimi_cli.ui.shell.keyboard import KeyboardListener, KeyEvent\nfrom kimi_cli.utils.aioqueue import QueueShutDown\nfrom kimi_cli.utils.diff import format_unified_diff\nfrom kimi_cli.utils.logging import logger\nfrom kimi_cli.utils.message import message_stringify\nfrom kimi_cli.utils.rich.columns import BulletColumns\nfrom kimi_cli.utils.rich.markdown import Markdown\nfrom kimi_cli.utils.rich.syntax import KimiSyntax\nfrom kimi_cli.wire import WireUISide\nfrom kimi_cli.wire.types import (\n    ApprovalRequest,\n    ApprovalResponse,\n    BriefDisplayBlock,\n    CompactionBegin,\n    CompactionEnd,\n    ContentPart,\n    DiffDisplayBlock,\n    ShellDisplayBlock,\n    StatusUpdate,\n    StepBegin,\n    StepInterrupted,\n    SubagentEvent,\n    TextPart,\n    ThinkPart,\n    TodoDisplayBlock,\n    ToolCall,\n    ToolCallPart,\n    ToolCallRequest,\n    ToolResult,\n    ToolReturnValue,\n    TurnBegin,\n    TurnEnd,\n    WireMessage,\n)\n\nMAX_SUBAGENT_TOOL_CALLS_TO_SHOW = 4\n\n# Truncation limits for approval request display\nMAX_PREVIEW_LINES = 4\n\n\nasync def visualize(\n    wire: WireUISide,\n    *,\n    initial_status: StatusUpdate,\n    cancel_event: asyncio.Event | None = None,\n):\n    \"\"\"\n    A loop to consume agent events and visualize the agent behavior.\n\n    Args:\n        wire: Communication channel with the agent\n        initial_status: Initial status snapshot\n        cancel_event: Event that can be set (e.g., by ESC key) to cancel the run\n    \"\"\"\n    view = _LiveView(initial_status, cancel_event)\n    await view.visualize_loop(wire)\n\n\nclass _ContentBlock:\n    def __init__(self, is_think: bool):\n        self.is_think = is_think\n        self._spinner = Spinner(\"dots\", \"Thinking...\" if is_think else \"Composing...\")\n        self.raw_text = \"\"\n\n    def compose(self) -> RenderableType:\n        return self._spinner\n\n    def compose_final(self) -> RenderableType:\n        return BulletColumns(\n            Markdown(\n                self.raw_text,\n                style=\"grey50 italic\" if self.is_think else \"\",\n            ),\n            bullet_style=\"grey50\" if self.is_think else None,\n        )\n\n    def append(self, content: str) -> None:\n        self.raw_text += content\n\n\nclass _ToolCallBlock:\n    class FinishedSubCall(NamedTuple):\n        call: ToolCall\n        result: ToolReturnValue\n\n    @staticmethod\n    def _extract_full_url(\n        json_content: str | streamingjson.Lexer, tool_name: str\n    ) -> str | None:\n        if tool_name != \"FetchURL\":\n            return None\n        json_str = (\n            json_content.complete_json()\n            if isinstance(json_content, streamingjson.Lexer)\n            else json_content\n        )\n        try:\n            args = json.loads(json_str)\n        except (json.JSONDecodeError, ValueError):\n            return None\n        if isinstance(args, dict) and args.get(\"url\"):\n            return str(args[\"url\"])\n        return None\n\n    def __init__(self, tool_call: ToolCall):\n        self._tool_name = tool_call.function.name\n        self._lexer = streamingjson.Lexer()\n        if tool_call.function.arguments is not None:\n            self._lexer.append_string(tool_call.function.arguments)\n\n        self._argument = extract_key_argument(self._lexer, self._tool_name)\n        self._full_url = self._extract_full_url(self._lexer, self._tool_name)\n        self._result: ToolReturnValue | None = None\n\n        self._ongoing_subagent_tool_calls: dict[str, ToolCall] = {}\n        self._last_subagent_tool_call: ToolCall | None = None\n        self._n_finished_subagent_tool_calls = 0\n        self._finished_subagent_tool_calls = deque[_ToolCallBlock.FinishedSubCall](\n            maxlen=MAX_SUBAGENT_TOOL_CALLS_TO_SHOW\n        )\n\n        self._spinning_dots = Spinner(\"dots\", text=\"\")\n        self._renderable: RenderableType = self._compose()\n\n    def compose(self) -> RenderableType:\n        return self._renderable\n\n    @property\n    def finished(self) -> bool:\n        return self._result is not None\n\n    def append_args_part(self, args_part: str):\n        if self.finished:\n            return\n        self._lexer.append_string(args_part)\n        # TODO: maybe don't extract detail if it's already stable\n        argument = extract_key_argument(self._lexer, self._tool_name)\n        if argument and argument != self._argument:\n            self._argument = argument\n            self._full_url = self._extract_full_url(self._lexer, self._tool_name)\n            self._renderable = BulletColumns(\n                self._build_headline_text(),\n                bullet=self._spinning_dots,\n            )\n\n    def finish(self, result: ToolReturnValue):\n        self._result = result\n        self._renderable = self._compose()\n\n    def append_sub_tool_call(self, tool_call: ToolCall):\n        self._ongoing_subagent_tool_calls[tool_call.id] = tool_call\n        self._last_subagent_tool_call = tool_call\n\n    def append_sub_tool_call_part(self, tool_call_part: ToolCallPart):\n        if self._last_subagent_tool_call is None:\n            return\n        if not tool_call_part.arguments_part:\n            return\n        if self._last_subagent_tool_call.function.arguments is None:\n            self._last_subagent_tool_call.function.arguments = tool_call_part.arguments_part\n        else:\n            self._last_subagent_tool_call.function.arguments += tool_call_part.arguments_part\n\n    def finish_sub_tool_call(self, tool_result: ToolResult):\n        self._last_subagent_tool_call = None\n        sub_tool_call = self._ongoing_subagent_tool_calls.pop(tool_result.tool_call_id, None)\n        if sub_tool_call is None:\n            return\n\n        self._finished_subagent_tool_calls.append(\n            _ToolCallBlock.FinishedSubCall(\n                call=sub_tool_call,\n                result=tool_result.return_value,\n            )\n        )\n        self._n_finished_subagent_tool_calls += 1\n        self._renderable = self._compose()\n\n    def _compose(self) -> RenderableType:\n        lines: list[RenderableType] = [\n            self._build_headline_text(),\n        ]\n\n        # Show full URL hint when URL was truncated\n        if self._full_url and self._full_url != self._argument:\n            url_hint = Text()\n            url_hint.append(\"  ↳ \", style=\"grey50\")\n            url_hint.append(self._full_url, style=Style(color=\"grey50\", link=self._full_url))\n            lines.append(url_hint)\n\n        if self._n_finished_subagent_tool_calls > MAX_SUBAGENT_TOOL_CALLS_TO_SHOW:\n            n_hidden = self._n_finished_subagent_tool_calls - MAX_SUBAGENT_TOOL_CALLS_TO_SHOW\n            lines.append(\n                BulletColumns(\n                    Text(\n                        f\"{n_hidden} more tool call{'s' if n_hidden > 1 else ''} ...\",\n                        style=\"grey50 italic\",\n                    ),\n                    bullet_style=\"grey50\",\n                )\n            )\n        for sub_call, sub_result in self._finished_subagent_tool_calls:\n            sub_args = sub_call.function.arguments or \"\"\n            argument = extract_key_argument(sub_args, sub_call.function.name)\n            sub_full_url = self._extract_full_url(sub_args, sub_call.function.name)\n\n            sub_headline = Text()\n            sub_headline.append(\"Used \")\n            sub_headline.append(sub_call.function.name, style=\"blue\")\n            if argument:\n                sub_headline.append(\" (\", style=\"grey50\")\n                sub_arg_style = (\n                    Style(color=\"grey50\", link=sub_full_url)\n                    if sub_full_url\n                    else \"grey50\"\n                )\n                sub_headline.append(argument, style=sub_arg_style)\n                sub_headline.append(\")\", style=\"grey50\")\n\n            sub_lines: list[RenderableType] = [sub_headline]\n            if sub_full_url and sub_full_url != argument:\n                sub_url_hint = Text()\n                sub_url_hint.append(\"  ↳ \", style=\"grey50\")\n                sub_url_hint.append(\n                    sub_full_url,\n                    style=Style(color=\"grey50\", link=sub_full_url),\n                )\n                sub_lines.append(sub_url_hint)\n\n            lines.append(\n                BulletColumns(\n                    Group(*sub_lines) if len(sub_lines) > 1 else sub_headline,\n                    bullet_style=\"green\" if not sub_result.is_error else \"red\",\n                )\n            )\n\n        if self._result is not None:\n            for block in self._result.display:\n                if isinstance(block, BriefDisplayBlock):\n                    style = \"grey50\" if not self._result.is_error else \"red\"\n                    if block.text:\n                        lines.append(Markdown(block.text, style=style))\n                elif isinstance(block, TodoDisplayBlock):\n                    markdown = self._render_todo_markdown(block)\n                    if markdown:\n                        lines.append(Markdown(markdown, style=\"grey50\"))\n\n        if self.finished:\n            assert self._result is not None\n            return BulletColumns(\n                Group(*lines),\n                bullet_style=\"green\" if not self._result.is_error else \"red\",\n            )\n        else:\n            return BulletColumns(\n                Group(*lines),","numLines":280,"startLine":1,"totalLines":827}},"sourceToolAssistantUUID":"55bceef3-9816-4926-b6f3-a9f72675f720"}
{"parentUuid":"66c75ef0-a710-495c-b717-cf2a81abf407","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_01GdePHbdPEazhpabJ3uGzn6","type":"message","role":"assistant","content":[{"type":"text","text":"Let me verify the `_build_headline_text` method is in place and the unused `escape` import should be checked."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":3886,"cache_read_input_tokens":36700,"cache_creation":{"ephemeral_5m_input_tokens":3886,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"global"}},"type":"assistant","uuid":"4ffc1a3c-da69-4775-9e10-099eea2fa5e2","timestamp":"2026-02-25T08:06:04.760Z"}
{"parentUuid":"4ffc1a3c-da69-4775-9e10-099eea2fa5e2","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_01GdePHbdPEazhpabJ3uGzn6","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MfeY3WbwW59GBSRedWdbhG","name":"Read","input":{"file_path":"/Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/ui/shell/visualize.py","offset":280,"limit":30},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":3886,"cache_read_input_tokens":36700,"cache_creation":{"ephemeral_5m_input_tokens":3886,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"global"}},"type":"assistant","uuid":"81b56e09-3f55-4838-a542-e7e22db4c95a","timestamp":"2026-02-25T08:06:05.624Z"}
{"parentUuid":"81b56e09-3f55-4838-a542-e7e22db4c95a","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01MfeY3WbwW59GBSRedWdbhG","toolUseID":"toolu_01MfeY3WbwW59GBSRedWdbhG","timestamp":"2026-02-25T08:06:05.674Z","uuid":"1e115fcd-1dc0-4181-9ea3-00eef84a275d"}
{"parentUuid":"81b56e09-3f55-4838-a542-e7e22db4c95a","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MfeY3WbwW59GBSRedWdbhG","type":"tool_result","content":"   280→                Group(*lines),\n   281→                bullet=self._spinning_dots,\n   282→            )\n   283→\n   284→    def _build_headline_text(self) -> Text:\n   285→        text = Text()\n   286→        text.append(\"Used \" if self.finished else \"Using \")\n   287→        text.append(self._tool_name, style=\"blue\")\n   288→        if self._argument:\n   289→            text.append(\" (\", style=\"grey50\")\n   290→            arg_style = (\n   291→                Style(color=\"grey50\", link=self._full_url)\n   292→                if self._full_url\n   293→                else \"grey50\"\n   294→            )\n   295→            text.append(self._argument, style=arg_style)\n   296→            text.append(\")\", style=\"grey50\")\n   297→        return text\n   298→\n   299→    def _render_todo_markdown(self, block: TodoDisplayBlock) -> str:\n   300→        lines: list[str] = []\n   301→        for todo in block.items:\n   302→            normalized = todo.status.replace(\"_\", \" \").lower()\n   303→            match normalized:\n   304→                case \"pending\":\n   305→                    lines.append(f\"- {todo.title}\")\n   306→                case \"in progress\":\n   307→                    lines.append(f\"- {todo.title} ←\")\n   308→                case \"done\":\n   309→                    lines.append(f\"- ~~{todo.title}~~\")"}]},"uuid":"a8630df8-1272-46fc-9d43-8c3745aa16e8","timestamp":"2026-02-25T08:06:05.674Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/ui/shell/visualize.py","content":"                Group(*lines),\n                bullet=self._spinning_dots,\n            )\n\n    def _build_headline_text(self) -> Text:\n        text = Text()\n        text.append(\"Used \" if self.finished else \"Using \")\n        text.append(self._tool_name, style=\"blue\")\n        if self._argument:\n            text.append(\" (\", style=\"grey50\")\n            arg_style = (\n                Style(color=\"grey50\", link=self._full_url)\n                if self._full_url\n                else \"grey50\"\n            )\n            text.append(self._argument, style=arg_style)\n            text.append(\")\", style=\"grey50\")\n        return text\n\n    def _render_todo_markdown(self, block: TodoDisplayBlock) -> str:\n        lines: list[str] = []\n        for todo in block.items:\n            normalized = todo.status.replace(\"_\", \" \").lower()\n            match normalized:\n                case \"pending\":\n                    lines.append(f\"- {todo.title}\")\n                case \"in progress\":\n                    lines.append(f\"- {todo.title} ←\")\n                case \"done\":\n                    lines.append(f\"- ~~{todo.title}~~\")","numLines":30,"startLine":280,"totalLines":827}},"sourceToolAssistantUUID":"81b56e09-3f55-4838-a542-e7e22db4c95a"}
{"parentUuid":"a8630df8-1272-46fc-9d43-8c3745aa16e8","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_01T3tk2kHM1VGnGTU2RoEb5f","type":"message","role":"assistant","content":[{"type":"text","text":"Good. Now let me check if `escape` is still used elsewhere in the file — it was used in the old `_get_headline_markup` but we removed that usage."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":549,"cache_read_input_tokens":40586,"cache_creation":{"ephemeral_5m_input_tokens":549,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"type":"assistant","uuid":"5ccc3dea-6415-4709-9261-effc828104b0","timestamp":"2026-02-25T08:06:09.253Z"}
{"parentUuid":"5ccc3dea-6415-4709-9261-effc828104b0","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_01T3tk2kHM1VGnGTU2RoEb5f","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019iD4hLvpuz3doL2bxU9XjY","name":"Grep","input":{"pattern":"escape\\(","path":"/Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/ui/shell/visualize.py","output_mode":"content"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":549,"cache_read_input_tokens":40586,"cache_creation":{"ephemeral_5m_input_tokens":549,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"type":"assistant","uuid":"8cc1e734-8f3f-4388-b7f3-e71e2782d6ae","timestamp":"2026-02-25T08:06:10.165Z"}
{"parentUuid":"8cc1e734-8f3f-4388-b7f3-e71e2782d6ae","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Grep","command":"callback"},"parentToolUseID":"toolu_019iD4hLvpuz3doL2bxU9XjY","toolUseID":"toolu_019iD4hLvpuz3doL2bxU9XjY","timestamp":"2026-02-25T08:06:10.625Z","uuid":"cbdaa516-d557-4fb9-a0d0-c7483e936279"}
{"parentUuid":"8cc1e734-8f3f-4388-b7f3-e71e2782d6ae","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019iD4hLvpuz3doL2bxU9XjY","type":"tool_result","content":"393:                f\"{escape(self.request.sender)} is requesting approval to \"\n394:                f\"{escape(self.request.action)}:[/yellow]\"\n462:                f\"{escape(panel.request.sender)} is requesting approval to \"\n463:                f\"{escape(panel.request.action)}:[/yellow]\""}]},"uuid":"81fa442f-ba29-49a4-a03d-4cfd88d2fb05","timestamp":"2026-02-25T08:06:10.623Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"393:                f\"{escape(self.request.sender)} is requesting approval to \"\n394:                f\"{escape(self.request.action)}:[/yellow]\"\n462:                f\"{escape(panel.request.sender)} is requesting approval to \"\n463:                f\"{escape(panel.request.action)}:[/yellow]\"","numLines":4},"sourceToolAssistantUUID":"8cc1e734-8f3f-4388-b7f3-e71e2782d6ae"}
{"parentUuid":"81fa442f-ba29-49a4-a03d-4cfd88d2fb05","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_016WJy8ec2wCBrB66pPadTR9","type":"message","role":"assistant","content":[{"type":"text","text":"`escape` is still used by `_ApprovalRequestPanel`, so the import stays. Now let me run the linter/type checker to see if there are any issues."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":248,"cache_read_input_tokens":41135,"cache_creation":{"ephemeral_5m_input_tokens":248,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"type":"assistant","uuid":"b56d070d-74a1-4d83-b6d3-a0304f53bf80","timestamp":"2026-02-25T08:06:14.167Z"}
{"parentUuid":"b56d070d-74a1-4d83-b6d3-a0304f53bf80","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_016WJy8ec2wCBrB66pPadTR9","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UKSUN3kJr1knB6uEBUXBV4","name":"Bash","input":{"command":"python -c \"import ast; ast.parse(open('src/kimi_cli/ui/shell/visualize.py').read()); print('Syntax OK')\"","description":"Check Python syntax"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":248,"cache_read_input_tokens":41135,"cache_creation":{"ephemeral_5m_input_tokens":248,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"type":"assistant","uuid":"270ffe72-82c9-4bac-8f1c-ba651bbf5b15","timestamp":"2026-02-25T08:06:15.194Z"}
{"parentUuid":"270ffe72-82c9-4bac-8f1c-ba651bbf5b15","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"Exit code 127\n(eval):1: command not found: python\n\n(eval):1: command not found: python","is_error":true,"tool_use_id":"toolu_01UKSUN3kJr1knB6uEBUXBV4"}]},"uuid":"712b7e17-f9f6-405e-aa1a-2591391b5b7e","timestamp":"2026-02-25T08:06:15.294Z","toolUseResult":"Error: Exit code 127\n(eval):1: command not found: python\n\n(eval):1: command not found: python","sourceToolAssistantUUID":"270ffe72-82c9-4bac-8f1c-ba651bbf5b15"}
{"parentUuid":"712b7e17-f9f6-405e-aa1a-2591391b5b7e","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_01T77rjxDipzNrP6a2U5Vyma","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013bRbLfhoEr3CxHwBkY2tKu","name":"Bash","input":{"command":"python3 -c \"import ast; ast.parse(open('src/kimi_cli/ui/shell/visualize.py').read()); print('Syntax OK')\"","description":"Check Python syntax"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":335,"cache_read_input_tokens":41383,"cache_creation":{"ephemeral_5m_input_tokens":335,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"type":"assistant","uuid":"818aff4f-4e2f-4f41-8848-2ec86227a239","timestamp":"2026-02-25T08:06:18.883Z"}
{"parentUuid":"818aff4f-4e2f-4f41-8848-2ec86227a239","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"Exit code 1\nTraceback (most recent call last):\n  File \"<string>\", line 1, in <module>\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/ast.py\", line 50, in parse\n    return compile(source, filename, mode, flags,\n  File \"<unknown>\", line 303\n    match normalized:\n          ^\nSyntaxError: invalid syntax\n\nTraceback (most recent call last):\n  File \"<string>\", line 1, in <module>\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/ast.py\", line 50, in parse\n    return compile(source, filename, mode, flags,\n  File \"<unknown>\", line 303\n    match normalized:\n          ^\nSyntaxError: invalid syntax","is_error":true,"tool_use_id":"toolu_013bRbLfhoEr3CxHwBkY2tKu"}]},"uuid":"fda0020b-c90a-4473-82b6-5c7d9d77fd4c","timestamp":"2026-02-25T08:06:18.993Z","toolUseResult":"Error: Exit code 1\nTraceback (most recent call last):\n  File \"<string>\", line 1, in <module>\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/ast.py\", line 50, in parse\n    return compile(source, filename, mode, flags,\n  File \"<unknown>\", line 303\n    match normalized:\n          ^\nSyntaxError: invalid syntax\n\nTraceback (most recent call last):\n  File \"<string>\", line 1, in <module>\n  File \"/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/ast.py\", line 50, in parse\n    return compile(source, filename, mode, flags,\n  File \"<unknown>\", line 303\n    match normalized:\n          ^\nSyntaxError: invalid syntax","sourceToolAssistantUUID":"818aff4f-4e2f-4f41-8848-2ec86227a239"}
{"parentUuid":"fda0020b-c90a-4473-82b6-5c7d9d77fd4c","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_01HVGXQhcqbG6vUkv5Ehbqhj","type":"message","role":"assistant","content":[{"type":"text","text":"That's just system Python 3.9 not supporting `match` syntax — the project uses a newer Python. Let me check if there's a project-specific Python."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":355,"cache_read_input_tokens":41718,"cache_creation":{"ephemeral_5m_input_tokens":355,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"type":"assistant","uuid":"f51bd665-1c91-4619-8522-bd1b65544701","timestamp":"2026-02-25T08:06:22.838Z"}
{"parentUuid":"f51bd665-1c91-4619-8522-bd1b65544701","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_01HVGXQhcqbG6vUkv5Ehbqhj","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016KgrZhWsPDbPfGCq1r6ihU","name":"Bash","input":{"command":"(uv run python -c \"import ast; ast.parse(open('src/kimi_cli/ui/shell/visualize.py').read()); print('Syntax OK')\" 2>&1 || pdm run python -c \"import ast; ast.parse(open('src/kimi_cli/ui/shell/visualize.py').read()); print('Syntax OK')\" 2>&1)","description":"Check syntax with project Python"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":355,"cache_read_input_tokens":41718,"cache_creation":{"ephemeral_5m_input_tokens":355,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"type":"assistant","uuid":"9ec6c8f3-0e80-44af-aa76-c99a7930fdab","timestamp":"2026-02-25T08:06:24.414Z"}
{"parentUuid":"9ec6c8f3-0e80-44af-aa76-c99a7930fdab","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016KgrZhWsPDbPfGCq1r6ihU","type":"tool_result","content":"Syntax OK","is_error":false}]},"uuid":"36915928-5fcd-4267-8855-2d3d4915952e","timestamp":"2026-02-25T08:06:32.069Z","toolUseResult":{"stdout":"Syntax OK","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false},"sourceToolAssistantUUID":"9ec6c8f3-0e80-44af-aa76-c99a7930fdab"}
{"parentUuid":"36915928-5fcd-4267-8855-2d3d4915952e","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_01WwxW4vegTzSGdhAfCQKm1U","type":"message","role":"assistant","content":[{"type":"text","text":"Let me also run a quick import check."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":219,"cache_read_input_tokens":42073,"cache_creation":{"ephemeral_5m_input_tokens":219,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"type":"assistant","uuid":"88312679-8e05-46bd-976e-c7ec011376c4","timestamp":"2026-02-25T08:06:35.368Z"}
{"parentUuid":"88312679-8e05-46bd-976e-c7ec011376c4","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_01WwxW4vegTzSGdhAfCQKm1U","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01945d5StmZ711YcFeu7qzu5","name":"Bash","input":{"command":"uv run python -c \"from kimi_cli.ui.shell.visualize import _ToolCallBlock; print('Import OK')\" 2>&1","description":"Verify module imports correctly"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":219,"cache_read_input_tokens":42073,"output_tokens":118,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":219},"inference_geo":"","iterations":[],"speed":"standard"}},"type":"assistant","uuid":"7326f03c-1f2e-4977-ac0e-ba902e3f5486","timestamp":"2026-02-25T08:06:36.214Z"}
{"parentUuid":"7326f03c-1f2e-4977-ac0e-ba902e3f5486","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01945d5StmZ711YcFeu7qzu5","type":"tool_result","content":"Import OK","is_error":false}]},"uuid":"056503cc-0754-435a-bf42-1f2c259dd0bf","timestamp":"2026-02-25T08:06:42.459Z","toolUseResult":{"stdout":"Import OK","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false},"sourceToolAssistantUUID":"7326f03c-1f2e-4977-ac0e-ba902e3f5486"}
{"parentUuid":"056503cc-0754-435a-bf42-1f2c259dd0bf","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_01KjmKzFygGQnKYwZzees4Ec","type":"message","role":"assistant","content":[{"type":"text","text":"Let me check if there are existing tests for this file."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":132,"cache_read_input_tokens":42292,"cache_creation":{"ephemeral_5m_input_tokens":132,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard","inference_geo":"global"}},"type":"assistant","uuid":"50bf1b87-d02b-417a-9e2b-f8d340c5cf03","timestamp":"2026-02-25T08:06:45.463Z"}
{"parentUuid":"50bf1b87-d02b-417a-9e2b-f8d340c5cf03","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_01KjmKzFygGQnKYwZzees4Ec","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0182C2ka2x1UAg738THDWWUy","name":"Glob","input":{"pattern":"tests/**/test_visualize*"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":132,"cache_read_input_tokens":42292,"output_tokens":72,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":132},"inference_geo":"","iterations":[],"speed":"standard"}},"type":"assistant","uuid":"884c26f2-8adf-425f-8368-d69bc66c39cc","timestamp":"2026-02-25T08:06:45.822Z"}
{"parentUuid":"884c26f2-8adf-425f-8368-d69bc66c39cc","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Glob","command":"callback"},"parentToolUseID":"toolu_0182C2ka2x1UAg738THDWWUy","toolUseID":"toolu_0182C2ka2x1UAg738THDWWUy","timestamp":"2026-02-25T08:06:47.481Z","uuid":"44b3ae3f-9882-4898-954f-3409fb96cbab"}
{"parentUuid":"884c26f2-8adf-425f-8368-d69bc66c39cc","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0182C2ka2x1UAg738THDWWUy","type":"tool_result","content":"No files found"}]},"uuid":"33ddc63a-516c-410b-ab47-b9dc6c6664b4","timestamp":"2026-02-25T08:06:47.480Z","toolUseResult":{"filenames":[],"durationMs":1651,"numFiles":0,"truncated":false},"sourceToolAssistantUUID":"884c26f2-8adf-425f-8368-d69bc66c39cc"}
{"parentUuid":"33ddc63a-516c-410b-ab47-b9dc6c6664b4","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_01V3mR62k9swL2PUZRYEuWhs","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TQNjQNFLhznT1pzXoVAkF4","name":"Grep","input":{"pattern":"_ToolCallBlock|visualize","path":"/Users/moonshot/dev/working/kimi/kimi-cli/tests","output_mode":"files_with_matches"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":87,"cache_read_input_tokens":42424,"cache_creation":{"ephemeral_5m_input_tokens":87,"ephemeral_1h_input_tokens":0},"output_tokens":26,"service_tier":"standard","inference_geo":"global"}},"type":"assistant","uuid":"ca0d8e12-9dd4-4811-96de-6539a581b673","timestamp":"2026-02-25T08:06:51.378Z"}
{"parentUuid":"ca0d8e12-9dd4-4811-96de-6539a581b673","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Grep","command":"callback"},"parentToolUseID":"toolu_01TQNjQNFLhznT1pzXoVAkF4","toolUseID":"toolu_01TQNjQNFLhznT1pzXoVAkF4","timestamp":"2026-02-25T08:06:51.732Z","uuid":"142706c0-f882-452a-a815-c11d844a5d52"}
{"parentUuid":"ca0d8e12-9dd4-4811-96de-6539a581b673","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TQNjQNFLhznT1pzXoVAkF4","type":"tool_result","content":"Found 1 file\ntests/ui_and_conv/test_print_final_only.py"}]},"uuid":"814cf9ab-7f1f-4968-bdbb-874130675024","timestamp":"2026-02-25T08:06:51.731Z","toolUseResult":{"mode":"files_with_matches","filenames":["tests/ui_and_conv/test_print_final_only.py"],"numFiles":1},"sourceToolAssistantUUID":"ca0d8e12-9dd4-4811-96de-6539a581b673"}
{"parentUuid":"814cf9ab-7f1f-4968-bdbb-874130675024","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_01CN8SBeAqKC1S3CksMUtLSm","type":"message","role":"assistant","content":[{"type":"text","text":"No direct tests for `_ToolCallBlock`. Let me also verify the `mcp__ide__getDiagnostics` for any issues."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":152,"cache_read_input_tokens":42511,"cache_creation":{"ephemeral_5m_input_tokens":152,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"type":"assistant","uuid":"42124a8b-2523-4a70-9f40-e3c35ee627f9","timestamp":"2026-02-25T08:06:55.435Z"}
{"parentUuid":"42124a8b-2523-4a70-9f40-e3c35ee627f9","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_01CN8SBeAqKC1S3CksMUtLSm","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UNZPDcx4hh1q2X5Cehzwo6","name":"mcp__ide__getDiagnostics","input":{"uri":"file:///Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/ui/shell/visualize.py"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":152,"cache_read_input_tokens":42511,"output_tokens":127,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":152},"inference_geo":"","iterations":[],"speed":"standard"}},"type":"assistant","uuid":"fa101cc0-13b9-4ed7-b8bd-67e496bfba5d","timestamp":"2026-02-25T08:06:55.982Z"}
{"parentUuid":"fa101cc0-13b9-4ed7-b8bd-67e496bfba5d","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"progress","data":{"type":"mcp_progress","status":"started","serverName":"ide","toolName":"getDiagnostics"},"toolUseID":"toolu_01UNZPDcx4hh1q2X5Cehzwo6","parentToolUseID":"toolu_01UNZPDcx4hh1q2X5Cehzwo6","uuid":"ca9d52e3-62a2-444a-b202-de496570a584","timestamp":"2026-02-25T08:07:01.977Z"}
{"parentUuid":"ca9d52e3-62a2-444a-b202-de496570a584","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"progress","data":{"type":"mcp_progress","status":"completed","serverName":"ide","toolName":"getDiagnostics","elapsedTimeMs":53},"toolUseID":"toolu_01UNZPDcx4hh1q2X5Cehzwo6","parentToolUseID":"toolu_01UNZPDcx4hh1q2X5Cehzwo6","uuid":"88409b44-79cb-46ec-8e15-980e61ade44c","timestamp":"2026-02-25T08:07:02.030Z"}
{"parentUuid":"fa101cc0-13b9-4ed7-b8bd-67e496bfba5d","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UNZPDcx4hh1q2X5Cehzwo6","type":"tool_result","content":[{"type":"text","text":"[\n  {\n    \"uri\": \"file:///Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/ui/shell/visualize.py\",\n    \"diagnostics\": []\n  }\n]"}]}]},"uuid":"5eaf58a9-9caf-4934-8834-6970be9c2d3a","timestamp":"2026-02-25T08:07:02.033Z","toolUseResult":[{"type":"text","text":"[\n  {\n    \"uri\": \"file:///Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/ui/shell/visualize.py\",\n    \"diagnostics\": []\n  }\n]"}],"sourceToolAssistantUUID":"fa101cc0-13b9-4ed7-b8bd-67e496bfba5d"}
{"parentUuid":"5eaf58a9-9caf-4934-8834-6970be9c2d3a","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_01SijR6qeJYe4wqcnDXwoKFc","type":"message","role":"assistant","content":[{"type":"text","text":"\n\nAll clean — zero diagnostics. Let me mark the task as complete."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":340,"cache_read_input_tokens":42663,"cache_creation":{"ephemeral_5m_input_tokens":340,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"type":"assistant","uuid":"c4541adc-e0f0-4b4e-a4e4-15bddb7a21f5","timestamp":"2026-02-25T08:07:05.288Z"}
{"parentUuid":"c4541adc-e0f0-4b4e-a4e4-15bddb7a21f5","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_01SijR6qeJYe4wqcnDXwoKFc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01YTRBwjK7ab9RVVzvoRA9Jb","name":"TaskUpdate","input":{"taskId":"1","status":"completed"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":340,"cache_read_input_tokens":42663,"cache_creation":{"ephemeral_5m_input_tokens":340,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"type":"assistant","uuid":"09862ef6-5be5-416b-a1d7-1dab4970b93a","timestamp":"2026-02-25T08:07:05.678Z"}
{"parentUuid":"09862ef6-5be5-416b-a1d7-1dab4970b93a","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01YTRBwjK7ab9RVVzvoRA9Jb","type":"tool_result","content":"Updated task #1 status"}]},"uuid":"fff6b852-20cf-4bb9-937c-987e095c2394","timestamp":"2026-02-25T08:07:05.686Z","toolUseResult":{"success":true,"taskId":"1","updatedFields":["status"],"statusChange":{"from":"in_progress","to":"completed"}},"sourceToolAssistantUUID":"09862ef6-5be5-416b-a1d7-1dab4970b93a"}
{"parentUuid":"fff6b852-20cf-4bb9-937c-987e095c2394","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_01F7u2f5t6kdKkENBSbdsiyc","type":"message","role":"assistant","content":[{"type":"text","text":"Here's a summary of all changes made to `src/kimi_cli/ui/shell/visualize.py`:\n\n### Changes\n\n1. **New imports** — `json` (stdlib) and `rich.style.Style`\n\n2. **`_ToolCallBlock._extract_full_url()` (static method)** — Parses the raw JSON arguments (from `streamingjson.Lexer` or plain string) and returns the full `url` value for FetchURL calls, `None` otherwise. Mirrors the web-side pattern `rawName === \"FetchURL\" && input?.url`.\n\n3. **`self._full_url` tracked** — Initialized in `__init__` and updated in `append_args_part` whenever the argument changes during streaming.\n\n4. **`_get_headline_markup()` → `_build_headline_text()`** — Returns a `rich.text.Text` instead of markup string. For FetchURL, the truncated argument text carries an OSC 8 hyperlink via `Style(link=full_url)`, enabling Ctrl+Click in supported terminals.\n\n5. **Full URL hint line** — When the URL is truncated (`full_url != argument`), a `↳ https://full-url...` line appears below the headline, also with an OSC 8 link.\n\n6. **Subagent tool calls** — Same treatment applied to finished subagent FetchURL calls displayed within a parent tool block.\n\n### Behavior\n\n| Scenario | Result |\n|---|---|\n| FetchURL, long URL (>50 chars) | Truncated text is Ctrl+Clickable, `↳` line shows full URL |\n| FetchURL, short URL (≤50 chars) | Text is Ctrl+Clickable, no extra hint line |\n| Non-FetchURL tools | No change in display |"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":108,"cache_read_input_tokens":43003,"cache_creation":{"ephemeral_5m_input_tokens":108,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"type":"assistant","uuid":"bd523198-004e-4b18-9374-eb50ea6675e5","timestamp":"2026-02-25T08:07:20.861Z"}
{"parentUuid":"bd523198-004e-4b18-9374-eb50ea6675e5","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"entire hooks claude-code stop"},"parentToolUseID":"b5511544-7c4b-448c-b64b-75a1a524ceea","toolUseID":"b5511544-7c4b-448c-b64b-75a1a524ceea","timestamp":"2026-02-25T08:07:20.939Z","uuid":"e6db9937-64d6-402c-a97f-57cba04f83d3"}
{"parentUuid":"e6db9937-64d6-402c-a97f-57cba04f83d3","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"system","subtype":"stop_hook_summary","hookCount":1,"hookInfos":[{"command":"entire hooks claude-code stop","durationMs":3443}],"hookErrors":[],"preventedContinuation":false,"stopReason":"","hasOutput":true,"level":"suggestion","timestamp":"2026-02-25T08:07:24.383Z","uuid":"89b1f4d7-2a4b-40a9-a4e7-d5dcd1aea9ec","toolUseID":"b5511544-7c4b-448c-b64b-75a1a524ceea"}
{"parentUuid":"89b1f4d7-2a4b-40a9-a4e7-d5dcd1aea9ec","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"system","subtype":"turn_duration","durationMs":153518,"timestamp":"2026-02-25T08:07:24.388Z","uuid":"ecd6f5cc-079c-4511-bff6-15ac9669aa1a","isMeta":false}
{"type":"file-history-snapshot","messageId":"61fd41b7-48f4-415c-bfd1-33ec425091fa","snapshot":{"messageId":"61fd41b7-48f4-415c-bfd1-33ec425091fa","trackedFileBackups":{"src/kimi_cli/ui/shell/visualize.py":{"backupFileName":"3f980b47889cf5ea@v2","version":2,"backupTime":"2026-02-25T08:15:08.611Z"}},"timestamp":"2026-02-25T08:15:08.610Z"},"isSnapshotUpdate":false}
{"parentUuid":"ecd6f5cc-079c-4511-bff6-15ac9669aa1a","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"user","message":{"role":"user","content":[{"type":"text","text":"这个效果不太好。不要下边的显示完整url了。仅仅显示缩略url即可，不需要考虑终端不兼容ctrl点击跳转了"},{"type":"image","source":{"type":"base64","media_type":"image/png","data":"iVBORw0KGgoAAAANSUhEUgAABZgAAAIECAYAAACUrktyAAAAAXNSR0IArs4c6QAAAJZlWElmTU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAIdpAAQAAAABAAAATgAAAAAAAACQAAAAAQAAAJAAAAABAASShgAHAAAAEgAAAISgAQADAAAAAQABAACgAgAEAAAAAQAABZigAwAEAAAAAQAAAgQAAAAAQVNDSUkAAABTY3JlZW5zaG90e1JOywAAAAlwSFlzAAAWJQAAFiUBSVIk8AAAAddpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDYuMC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC8iPgogICAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+NTE2PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjE0MzI8L2V4aWY6UGl4ZWxYRGltZW5zaW9uPgogICAgICAgICA8ZXhpZjpVc2VyQ29tbWVudD5TY3JlZW5zaG90PC9leGlmOlVzZXJDb21tZW50PgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4Krl8+vgAAABxpRE9UAAAAAgAAAAAAAAECAAAAKAAAAQIAAAECAAFUNfltZAoAAEAASURBVHgB7J0FnB1F9rYLDcviboEgISFokCABgia4uy4aHBaHJXhw9z8LWdzz4R5YAiwWCE6wYME1QGAhsOHjqeXcranbemUyM3nP7zfT93ZXVVc/3V23+61Tpyb67XdzHcBuu+029/jjj7vu3bu7jTfeuNARnXnmmW7s2LFu3333dfPMM09unldeecUNGTLEjRs3zn388cc+/eyzz+4mmWQS/3nRRRd1q6++uv982mmnuc8//9x/TiubfHvttZdPk/Xvu+++cyeeeKLf7/bbb+8WX3xxd//997tffvmlKtsjjzzi1y255JJummmmqdreqVMnt+aaa1atD1cceuihfl9HHnmkm2GGGcJN7uuvv3YnnXSSX3fGGWe02GZfTjjhBPftt9+6XXbZxS200EK2umoZMqraWOMK9sd+k+zee+9133zzTdKmxHXDhw/36xdccEE31VRTVdK88MILrkePHm7yySd3K6ywguvSpUtlmz6IgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIwPgg8P/+3/9zM800U6vt2nTDiTqKwHzKKae4L7/8sjTAiSee2CF0FrGrr77avfjii6lJ+/Xr58Xbe+65xz388MOp6WzDlFNO6Y4//nj7mro899xz3ahRo7xYmyaekvn77793xx13nC8nTfxN3ckfGz744AN33nnnuSmmmMKL2nH6p556yt1yyy0OYf2ggw6KN/vvBx98sF/m1eHWW291P/74Y1UZ77zzjheo4dOtW7eq7VkrllpqKd/JkJTG6pW0rdZ1/fv3d127dq01u/KJgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIQEMISGCuE6OJhyuttJKbaKKJckt77bXXvCCNdzEezEXs6KOP9oLoX/7ylxaevRdddJH76aeffDk//PCDGzRokC9um222SfQiHjp0qBsxYoT3RMYjOcsuu+wy9/rrr/skxx57bMWTFgE7FmfxmOa4EM1XXnnlqmJ79erlZplllqr14Qo8tO+77z4399xzu6S6DR482NdniSWWcOuuu26Y1X/muOxiPvzww6u2F1lx5ZVXupdfftmttdZabo011iiSpVCaZ555xhV12Md7eeTIkW7GGWd0q622Wmr5yy67bOo2bRABERABERABERABERABERABERABERABERCB1iJgmlxr7a9DeTAjqiLqTjfddO6oo44qxPCKK65whLwwr+O8TIRWGDhwoJt00kkd3tKhIW4j6rLEa5cQGojLhKlIsgsvvNC9++67bsstt3TLLLNMUhK/7rrrrnMWpiE+NhPUUzMnbEgKeREns7rF68t+X3HFFd1GG21UNptPjzD966+/OkJ15AniNe2gQCa8tPHW5vxwnmQiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIi0JYJSGCu4+xY/GVCKqSJunHxiIeImEXjLz/99NPu5ptv9iEbdtttt0pxhMwgdAYev8RKHj16tFtllVXceuutV0kTf7AYxwMGDHDTTjttvNl/t2Oyjcstt5zbbLPN/NeXXnrJXXXVVT5MRRhPmXVY37593WyzzeY/U5877rgjNeSFTxT8s7oh7Mae4HhME4YDm3XWWYNc//v42Wef+S958Zf/l6Plp/fff9+df/75rmj4kJa5G/ftggsucO+9955be+21K3G1G1e6ShIBERABERABERABERABERABERABERABERCBxhKQwFwHz9aMv7zBBhu0CD9x4403umHDhnlPaMRmPI133XXX1KNBtES8ZNI4Ql4k2YMPPugn8Qu37bjjjo5JBDGEbgTv9ddf3/Xp08evS4u//Oyzz7obbrjBLbLIIo7QHlnWmvGX0+px0003OUJZIJDbsaWlZf28887blODlFg7FJlXMqoO2iYAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiMD4JiCBuY4zYOEi9ttvP9epU6fckhAwiYOM1zF5ipgJjtttt533HLY8l1xyiffqxRP6T3/6k4/FTGgLYjInCcjENybOMZPRbb311lZMi6WF3Nh5550dMZixcMK8E0880XtKM8kek+1hhNJgv3gWH3LIIX4d/6655hr3wgsveO9nvKCz7KGHHnL33ntvqhhtYUXSPLTZD/tjtspa4y+bB3VWPcNte+21l5tvvvnCVYmfmfyQ+Nh5RkzlTTfd1Ic7Ie0BBxzg5pprrrxs2i4CIiACIiACIiACIiACIiACIiACIiACIiAC45WABOYa8dcTf5lQEvzlmcVfTktH/OXTTjvNb/7yyy8rMZpjb2cSnHXWWe7jjz92CNVMlJdkJ5xwgvc2RhBFYE6Lv0wYCgtj8cgjj7i3337bi+bhMSH4InaXib9MKI4kMZr41pS1xx57uAUWWKCq6ubNXWv8ZRPJCY+x2GKLVZVvKwj7wcSHIXfblrQkPaJ8EbO42NZpEQr7RfIrjQiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiMDwISmGukHsYqZgK+IkbsZWyfffZxXbp08Z+z/ln8ZYTPOeaYo5L0iy++cN9++62bZ555fCxn22BCa9qEgKQrIlwSO/nRRx/1Ym8cf9n2VWQ5xRRTFBJYzXt4nXXWqQo78e9//9uH5mB/eF5PNtlkVbvmIh4zZoyrNf7yySef7L766isfYqR79+5V5duKJ5980g0ePNh7LuPBXNY+/PBDd84557jJJ5/cnXTSSVXZv/7668r6IuepqgCtEAEREAEREAEREAEREAEREAEREAEREAEREIFWJiCBuUbgFn8ZL1+E1DxjIj4mqyvq/Up5TOJHfOXYI9mE5H79+rlwsj1E1uOPP96NGzfOrbvuum7VVVf11RoxYoS7/PLL3YwzzuiOOOKIvKq6008/3TFpXhh/mTKY5C+0Tz/91I0aNcohaPfs2TPc5D937tzZrbDCClXrwxXPP/+8u/baa8NVNX+uRZRl0sVbbrnFzT///G7PPffM3DcM4RCfj8xMwcaHH37Y3XPPPamhQD766CN39tln+xy1HEuwK30UAREQAREQAREQAREQAREQAREQAREQAREQgVYhIIG5RsxlQxmY92st8ZfZF5PPmRHKAg9m4i/jxRyaTcSH1zNiM4bXLftfeeWVvTgapk/6nHRsDzzwgBdX999//0qWK6+80r388suFy61kDD6cd955jkn+8NCGTWxMFojnd9r2d955x33++ec1x18mZjPlI7wjwGeZpS0S9iOpnIsuushRX2ItL7/88lVJbLJDNkhgrsKjFSIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAm2QgATmgiflvffecz///LNPTagDJqXDc3ennXYqVAIC7fvvv+969Ojhevfu7fPg+RwLxFaYxV9OC3eR5glNqAdCPoThM5ho7vvvv3dFJqYjxnAcfxlPZRM8iVG8ww47+JAUNplgrYKrHSPHPGDAADfttNPa4VeWzYy/fPHFF7uRI0cWEsg5d+eff76vI3WtxSwUSJqYrRAZtVBVHhEQAREQAREQAREQAREQAREQAREQAREQgfFJQAJzQfrm1VsweaFkCy64oNt9990T01r85W7durnddtutkoaQGYTOCAXkysY/PjCZn8VsNhE3TZCO81r85WWXXdZtvvnmlc0WSoIV66+/vvc6pi5Zx1DJnPLhrrvuckwSuMgii/jJBeNkRQRX8+YuG3/Zwo8UjRNtXPr06eOPP65r3ves+Mt0Cpj3tF1nCOuEX8Heffddh7f49ttv70N55O2LUBx4QxPrmc6MtE6MvHK0XQREQAREQAREQAREQAREQAREQAREQAREQATyCEhgziP0x/arrrrK/fbbby1S//TTT+6tt95yhKMghm9opH3llVf8KraRJralllrKi6vxer6bAIqASzozhGfCLMTxl217vGSyPsRRJq/bdddd481V3y3+Ml7KeCuHdv3117vnnnsuXOX+9re/uemnn77FuiJfCPExcOBAHy/6wAMPrAjiYV4TtWeffXZ30EEHhZsqn02QNQ/ryoaMD7fffrt77LHHvAc6IT8oP8/w1ibGNfUokj4uz+Ivk3eVVVbxorGF9whjY9vx7Lzzzt7bnXIstEYYVzsun+8I1cRw5roMjdAeM800U7hKn0VABERABERABERABERABERABERABERABESgIQQkMNeIEc/b++67z8fvxVP0pJNOalHS448/7m677Ta/Du9hJrtbY4013FRTTdUiXdqXo48+2k8KmLY9Kf5yUlrCZSA8brvttokT8cV5TOBME2wtZAX5OBaE0KTYyXG58fezzjrL4Wmd5Yl9xRVXeJEeQXa99daLi3Dm5Y14iohaxCxuNOdkv/32c3PNNVduNhPpy+yHkBpffPGF/yNG9BtvvOHGjh1btS/qQWfB6quv7rcZF66XTTbZxIdVITRH0jUWF2bnervttnNLLLGEn7wQkX6jjTZyK664Ypxc30VABERABERABERABERABERABERABERABESgbgISmEsgJI7xE0884b1fzUt0ySWX9CETpp566qqSmKDu7rvv9vGP2YiYiGi43HLLVaUNV4RhLcK0P/zwgyMsBeWcdtppYZbEzwjcCN1Fw0AkxV+2gtlGeV9++aWtqixnnXVWt+aaa3pRs7Iy4wPxqx966CHvQUw84qTYy2Q3MXuPPfZwCyywgC8Rz2fSExN70KBBXoRfa621vHifsUtHuI1LLrnEL+G39957FwodgVB84YUXek/rPffcs8pTPWmfFvoj3oYgjwfznHPOWfmbZZZZWiQL2Rx22GF+36NHj06dGNAyI2afeuqp3tt966239qtNGC/auWBlaSkCIiACIiACIiACIiACIiACIiACIiACIiACRQlIYC5AatSoUe7+++93iKxm8847rxeLi4RLwNN28ODBXqQkf+fOnR2hGdLMPHPj+MuEVLj00ku92JoU7uLGG290b775phduEanHjRvnd7HPPvu4Ll26pO2ust7iDBN/GcGYMBLE/yV+sJWFJ+1WW23lQ34gnsMmNLYjOM8222xuyy23DDf5z8QGPu+88/zn/v37u65du1alYUVS/GXzaA4zEHrk+OOPD1dVfR4xYoT7xz/+4Y8BcRrBeuaZZ65KxwpCkyDkM7kiYroJ6n379nX8FTG8hocNG1YRkYmHzTkvYiYUh2nxEMfbOstsEkKuR2J2c87ghZh+yimnZGXVNhEQAREQAREQAREQAREQAREQAREQAREQARGomYAE5gLo8ES+4YYbvFjXq1cvx0RvaQJlWnHfffedn6gNIZBwBYQtSDNiNz///PNu6aWXdgsttFBasqr1hFKgfAxhkfAT7GvxxRevSpu0Ioy/zPGdeeaZlWSIxkwYR+iG0BCMhwwZ4ieVI0axGRPU4YEcG17g7GfllVfO9DomfMbQoUP95Hcm7OJB/cILL/giO3Xq5BZeeGHvDR57Acf7tHjWiy66qNtxxx3jzS2+x6FJ8ExfddVVfX1bJGziF477zjvv9HsI4zPn7dI8vi0dIvlee+1VUwgTK0NLERABERABERABERABERABERABERABERABEcgiIIE5i06wbfjw4Y5wGPUasXjxTG6mWRiJsvsgpMIvv/xSiQf8wAMPeM/bMiI3gjPiMJ60CNxtxRDse/bsmVsdPKcJf0K85Mkmm8x7IedmakICOiQ++eSTUtcK4j0hUQipAf9Vfo9dLRMBERABERABERABERABERABERABERABERCBZhKQwNxMuipbBERABERABERABERABERABERABERABERABERABDowAQnMHfjk6tBEQAREQAREQAREQAREQAREQAREQAREQAREQAREoJkEJDA3k67KFgEREAEREAEREAEREAEREAEREAEREAEREAEREIEOTEACcwc+uTo0ERABERABERABERABERABERABERABERABERABEWgmAQnMzaSrskVABERABERABERABERABERABERABERABERABESgAxOQwNyBT64OTQREQAREQAREQAREQAREQAREQAREQAREQAREQASaSUACczPpqmwREAEREAEREAEREAEREAEREAEREAEREAEREAER6MAEJDB34JOrQxMBERABERABERABERABERABERABERABERABERCBZhKQwNxMuipbBERABERABERABERABERABERABERABERABERABDowAQnMHfjk6tBEQAREQAREQAREQAREQAREQAREQAREQAREQAREoJkEJDA3k67KFgEREAEREAEREAEREAEREAEREAEREAEREAEREIEOTEACcwc+uTo0ERABERABERABERABERABERABERABERABERABEWgmAQnMzaSrskVABERABERABERABERABERABERABERABERABESgAxOQwNyBT64OTQREQAREQAREQAREQAREQAREQAREQAREQAREQASaSUACczPpqmwREAEREAEREAEREAEREAEREAEREAEREAEREAER6MAEJDB34JOrQxMBERABERABERABERABERABERABERABERABERCBZhKQwNxMuipbBERABERABERABERABERABERABERABERABERABDowAQnMHfjk6tBEQAREQAREQAREQAREQAREQAREQAREQAREQAREoJkEJDA3k67KFgEREAEREAEREAEREAEREAEREAEREAEREAEREIEOTEACcwc+uTo0ERABERABERABERABERABERABERABERABERABEWgmAQnMzaSrskVABERABERABERABERABERABERABERABERABESgAxOQwNyBT64OTQREQAREQAREQAREQAREQAREQAREQAREQAREQASaSUACczPpqmwREAEREAEREAEREAEREAEREAEREAEREAEREAER6MAEJDB34JOrQxMBERABERABERABERABERABERABERABERABERCBZhKQwNxMuipbBERABERABERABERABERABERABERABERABERABDowAQnMHfjk6tBEQAREQAREQAREQAREQAREQAREQAREQAREQAREoJkEJDA3k67KFgEREAEREAEREAEREAEREAEREAEREAEREAEREIEOTEACcwc+uTo0ERABERABERABERABERABERABERABERABERABEWgmAQnMzaSrskVABERABERABERABERABERABERABERABERABESgAxOQwNyBT64OTQREQAREQAREQAREQAREQAREQAREQAREQAREQASaSUACczPpqmwREAEREAEREAEREAEREAEREAEREAEREAEREAER6MAEJDB34JOrQxMBERABERABERABERABERABERABERABERABERCBZhKQwNxMuipbBERABERABERABERABERABERABERABERABERABDowAQnMdZ7c2267za200kpuxhlnzCxpzJgx7rTTTnPjxo1zJ554Ymbashu//vpr9+qrr7r333/fbbfddj77GWec4X744Qe3zz77+Lo9/PDDrlevXm6qqaYqW7z74IMP3DXXXONWXXVVt/zyy6fmf+ONN9zdd9/tJp54YnfAAQekpmsvG0444QT37bffeoZdunSpu9qPP/64W3HFFQuVc/755/vz+Ze//MUtssgihfIoUesQ+Pzzz91ZZ53l/vznP7sBAwa0yk6ffPJJd++997qtttrK9ejRo+n75Fp94IEH3Oabb+4WXXTRxP3RxtD29O/f380zzzyJadrSyldeecXNPffcbppppsmt1uWXX+5GjRrlj2322WfPTV9LAtrkRx991E0yySStdh3VUk/lEQEREAEREAEREAEREAEREAEREIE8AhKY8whlbD/vvPO8+Dr11FO7Y445JiOlc88//7y79tprvdh7xBFHZKbN2/jJJ584/t555x2HaIJ4bYbo891337njjz/eC72I2uecc4778MMP3ZRTTun23XdfN/PMM1vyQksE8dGjR7s11ljDrbXWWol53nvvPXfRRRd5AZ0EG220UWEx1QpE0EFYrdcmnXRSd9JJJ9VbjDvuuOPc999/7zbddNNMYb3IjowhQjWiv9lXX31lH1ssBw0a5D777DPPfJlllmmxjS8TTTSRm2GGGarWxyuefvppx7mp1eacc87S57HWfRXNx3XyyCOPFE1eON3qq6/u5phjjtz0N954oxs2bJhbYoklKh06uZnqSEAnx8CBA/29tcoqqzjam1qMc7nAAgvkZv3mm2/cySef7Pe37bbbup49e1bl4b7g/sBoc2qx1rzf77zzTjd06FB/zxx55JG51T3qqKPcTz/95PbYY49CzHILjBLcdNNN7plnnqmsXXPNNV2/fv0q39vThzPPPNO3VWXrPMUUU/jfqbL5lF4EREAEREAEREAEREAEREAERKDtEZDAXMc5QeBFVMU6d+7s9t9//9TSTJRaYYUV3CabbJKaLm0D+8FzMhSTLS2Cavfu3b2n69JLL+1efPFFd/XVV1fq9NZbb7m///3vXjAi7YEHHuhmmWUWy565vP/++92DDz7oZpppJnf44YcnpkXsPvvss335ePvxfbrppnOINGVsyJAh7r777iuTJTEtx3booYcmbiuz8rrrrnPDhw93yy23nNtss83KZK1Ky432xBNP+PV4eyL0IxziJV2rFRH2jj322MRrpug+W0tELVof0t1xxx3e87NMniJpDzroIFfEW5Vri5EIaenxSqVDKc3oHNhvv/3SNletN2/2xRdf3LcB3F+12DrrrONWW2213KzWcUabQnv16aefVuWhDhwj7Unfvn2rtrMCYXr66adP3MbK1rzf3377bXfJJZf4usSdPEkVRGCn86cZIwguvvhiN3LkSDf55JN77/DnnnvOczzllFOSqlJ4nV2XhTOkJFxooYXcLrvskrK1evXBBx9cvbLAGmsHCyRVEhEQAREQAREQAREQAREQAREQgTZOQAJznSfozTffdJdeeqkvZamllnJbb711YokWbqFWwcJe4gk/wRBvPIoxhAAEgdAI28EQd7wd11tvPb+J8BkXXnihF8bwHEOMyBsq/sUXX7hTTz3V5yd9kiiNCHP66ae7X3/9teK1bHVFRC0zdJ76vfvuu27jjTd2vXv3Dg/Jf8bzcOzYsW7XXXf1gnqcwARhwlDgQZ1nL7/8shfi09IhIprBPc0Q3ot4E99+++3uscce88Ug3NEpQccDQtOss86aVnyL9ZwTPCuLiujPPvus+/nnn1uUUebLfPPNV0h0LVNmvWkJ2ZInshLeAQEfkTQtxENcj2WXXTZeVfWdsAb33HOPm2uuuVLDwJg4WZX5jxWEqUH4L2J4oN98882OexYveELQcA8UMcJqcA3DgBA+K6+8cm4on6eeesrdcsstFcHTPHmL7C9OQ146mtKste93RntcccUVvjpLLrmk22abbXwYjCQBHY/nH3/80TF6gHsgNu7d2WabLV6d+R2vb475yy+/dNNOO60fyYAAb4wJ31Gm4yHcGWUStiXNuA5oozE6BbLaMzoiiobyee211xyjLcp0KHIOOBd4bOO5LRMBERABERABERABERABERABEWj/BCQwN+AcmicegoOJq2GxeB2boFTE6zTMa58RsgltgSCBWIxXI0JBktcbQ5YR4GIxe8SIEY7YotSTod958ZgJr4HX9Prrr+/69OljVaks2QeCCYInoTMIoYHhPY0XdVkPNfPAQ0iOBVtivVrYizSGJuInie6VSgcfzKs8WFX6I0INnIoa/DkPCMR4y8Jp7bXXdoRnKGLWeVBURC9SZkdMw/3Gfbf77ru7BRdcsK5DxGPaDAEWgReBORYeiVFO+AprA/bcc08fysTyEtYDQc7ETVuftiTUDaIy4mBap0paXtZbPQjfUySsRri/7bff3uExzQiGX375pWo3FqKEY0nqqOrUqVOueNja9zsHQRzrhx56yHfq0M7gTUwomrK2ww47uMUWW6xwNvZBW4loHXdOWCcChdEJsMEGGxQut2hCOmXwTE/7zShaTpzO2iM6MegYLGL8PnEPle2ALFK20oiACIiACIiACIiACIiACIiACIwfAhKYG8T9X//6V6LXLcU3Mv4y5RGyAuGnW7dubrfddmNVCzPh5uijj64SfxiaPf/887dIn/QFr0mED9IilOHlh4ccIRPw/AtFEcRnRGgzYquee+65/isegFtuuaVtSl2aAGKemnFC86xElCU0QZKZoJYmQMd5TJCuRbyzTgVExr322isuOvM75w7vPc4PghPejHhEFjE8/7CiInqRMjtaGotBznEVvRbSGJiHZtr2cD37svTEciYUTWiEuSGsDqMcGO2QZ9ZRVFSQDstjwk3C4hSJD2/5uGe5d/NCJDQi/vL4uN/tOBFF6dCBjXkq27akJeeMkRqIsxaPukibZmVxvyNq01HAhJ10/MVmXr2sb4bIbO1V165d/cSF8f5r/U4HJ97TZa1sx1zZ8pVeBERABERABERABERABERABESgdQlIYG4F3uYpW0v8ZQRFJt0KjTALePQiSiI+hYbXJmIGtuGGG4abKp+JAZs1BNoEcYTPAQMG+HwmxiKM4o33wgsv+PVpE/+FgkkRD10TQBgmjvdkbIMHD3avv/66F7jXXXfdeLP3CraLOS1WdJyprCAd5r/ssst8ffKODTGO80+oknhIPUIXcZkRnooaohgeuWmhWIqW05HTERbkhhtuKDVsP40HgisxzH/77Tfv/Uo67jk7l2zjz4TDW2+91dHZRKxjQg2EZh0/RTyKTYwmf5ieEClpRueMeSpbnOqssD1hOXY9sw7vbxvdQEgQOkFCY1QDQjoiIWJobL169UoMpxOmGx/3e7j/Mp+tI2iLLbZwHFtRI7Yy1wMjPLBVgpBFSWXYRKBsw3s8qR1MyldknYUjSRuNUqSMpDTWhq600kotvPWT0rKO6wZBuuzolrTytF4EREAEREAEREAEREAEREAERKBtEDBNrrVqY5EPJvpdsPmttXbayP0QR/c///lPiyIZKr3A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oYgHcnxurYwieS1tGH8Zb2wmiDRDNKadi+MTIxjT+cHSPPDJkzbxZ2vf79TFOCaFpsELljab80JHio0UIB8CKPenCaGsMyPMUZFrwdLHy9aOvxzvv57vFn4GNr169fLhNsL5BoqUzT1KpyfC8YorrujDXOTls5E4lg5xnvj5tYRosTK0FAEREAEREAEREAEREAEREAERaA4BCczN4dqQUm1ocdLw44bsoGQho0eP9kJSWra87Wn5mr2eDoDQs7fZ+0srnzAkeLOWNeJaIzCXNc6HGQJgR7VvvvnGh3hhZAHeuI0wykzy1G9E2Wll0HlF6AFGJeQZIycQSM3+9Kc/VcWBt21pS8TWX375pbI/OqTwLi0a95tyzXOazpKkOONp+272emLlxxPPNXufWeW/8847vqMIcbQ9dvDU2nbFTIhXzuiYIsbvHx1ztGNcX6usskqRbEojAiIgAiIgAiIgAiIgAiIgAiIwHghIYB4P0LVLERABERABERABERABERABERABERABERABERABEegIBCQwd4SzqGMQAREQAREQAREQAREQAREQAREQAREQAREQAREQgfFAQALzeICuXYqACIiACIiACIiACIiACIiACIiACIiACIiACIhARyAggbkjnEUdgwiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiMBwISmMcDdO1SBERABERABERABERABERABERABERABERABERABDoCAQnMHeEs6hhEoB0ReOedd9zEE0/sunTpUrrWO+ywg89z1VVXlc57xx13uFtuucVtvvnmbv3110/Nf9pppznqeMwxx7jZZ589NV1b3HDssce6xRdf3G288cbjpXoHHXSQGzp0qNtnn33cX/7yl4bXwc7NUUcd5eaaa67c8p999lk31VRTue7du+emLZrgxhtvdJdddplbeeWV3YABA4pmy023ySabuDnmmMNdcMEFiWkHDx7srr32Wrflllv6v8REWjneCLz55ptu7733drvttpvbYostEutx/vnnu3vvvdcdeuihbpVVVklM055WXnzxxY6HyL///e81tef1HOt+++3nPv/8c3fhhRe6GWec0b344otuyJAhjjaoFuO+e+GFF9xhhx3munbtWksRhfNwr/PbcvTRR7tZZ501Nd8ee+zhJp10Ul+nzp07p6YruuGpp57y52rHHXf07VdSvrvvvtudc845btttt21KG560z3rWja/niXrqrLzFCHA/nnLKKW7s2LHu1FNPbfp9WaxWtaXiuXPFFVd0+++/f+kCDj/8cPfxxx+7M888080888yl8yuDCIiACIiACLQmAQnMrUm7De/rtttuc19//bVbdNFF3TLLLNOGazphVO3xxx93Rx55ZE0Hiwi33HLL5eZ95JFH3JdffpmbrkyCP//5z27ttdfOzLL00kv77Yh/Za2evAgSTzzxhONhfbPNNkvdNcLoK6+84hCxe/TokZou3vDMM8+4cePGxav99z/96U/+xWCrrbZK3J60knsR8aSoIbDssssuPvkDDzzgZphhhtSsL7/8snvrrbfcG2+84V599VX3+uuv+7x77rlnah428JLDcabZgw8+6J5++mk3/fTTe7EtLR3rEcLnnXferCRV2+zcXH/99bkvmwjBp59+uptyyindDTfc4MXbqgJrWDFy5MiKwHv//fd7cauGYlpksXMHj5tvvrnFNvti1+/xxx/v1llnHVutZRshQLt70003uTXWWMOLIknVOuGEE9ztt9/uWOa1k0n5WUf7RTtWr5144ompImPRsimDZ4e+ffu6k046qWi2hqRbc8013TfffON5zjnnnG7XXXf1AjEdMIccckipfdD+bbfddj4PD8Vzzz23Q9z95JNPCpWDWHzJJZcUSnvXXXc5OgJpl/iNmWSSSaryISbTLiMEY7R3U0wxRVW6ySefPFOgjjPQuUGnGPvmWp1tttniJL5tQbinEySto6Qq03hcUc8zQZm8V1xxhe/QaOShct1sv/32uUU++uij7sADD8xNl5Sgf//+vtMraVtbXkfHAb/3P/74o68m9yT3ZiOMjr5abaKJJvId6GXy2+87eejIojMyzbp16+aWXXbZFpvpkPrggw8qbV2LjfoiAiIgAiIgAm2MgATmgicEz49//OMfhVLz8jjLLLMUSlsk0aeffuqTJb0MFMlfJI09wPCwW7SH/V//+pd/QaL8I444ItGD6YwzzvBCFi+AeOtg//znP73g47/88Y+HNpjhwbfEEkukCqS8aCGMkr7oC124n7KfERp5yG2EUV97ockrDy/QWj2x8HLo06dP3i78CzUv1o00zjMCSpYZg7IC8xdffFERZcrmpT623zzhmPNdi8Bs5acdO0LMRhtt5Ddb+/DLL794kYSVto7P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qfCkzRuWTYfKL7/8UpljgfvSRi6wj8UWW8x3ENnoAttvvKQt5H5BbCEcRRzKKEzPiBt+B0JL69QL0zTyM509dCraSJGi3svUwUQgE5itsxZBmXYmzwsaMR7v5XnmmSezA7lWgZl2IvRyzusMLMPVftcbJV7BPe40DEN8lKlbrWmb8TxRpC6NFJj5XaVT3EbvxftnZA7tAd7LtHk4d4wZM6ZFWxLnwUmgmRMuxvtrxPdGX59xnZh4FfHXjPaOjuwi4YMsT9bS2hZzFOAZi04A6/ROysvItjjEGiMY6fCTiYAIiIAIiEBbJyCBua2fIdVvgiLAiwLiQBGP5SwwiKPfffedF0Sz0pXZhscGnjBmhFRo717qdiztfYlXJJ7qeUPe2/txIuRkDUGv9/gQp/AswhAA6VBYdNFFSxdLOa+++qq/P4p6YZbeiTJUEQhjMMcTJ1UlbtAKzvWTTz7pvW7pgEDQHTlypPe+LdqO47XOyCZEorSwQA2qbqliEEQRxouMgqHudMTx+5U0kqDUjutITJ0ZKlem0/P+++/3c1SEno11VCEzK0ITTIuGRqEwOgvxrsQ4F0WvK58h5x9hTxgNged8owyx2gRrRpbU0lHeqLq0Zjk2ITOiKL8d9RrtSNEJauvdV1vNz72JpY0EakS9aX8x5iGxYbaNKJcy4rYlfMbI2ge/IzbQt+xkyFnlapsIiIAIiIAINJuABOZmE1b5IiACIiACIiACTSdADNi77rrLe+LnDV1uemW0AxEQAREQAREQAREQAREQARGYgAhIYJ6ATrYOVQREQAREQAREQAREQAREQAREQAREQAREQAREQAQaSUACcyNpqiwREAEREAEREAEREAEREAEREAEREAEREAEREAERmIAISGCegE62DlUEREAEREAEREAEREAEREAEREAEREAEREAEREAEGklAAnMjaaosERABERABERABERABERABERABERABERABERABEZiACEhgnoBOtg5VBJpJ4JtvvnG33HKL38Vuu+3WzF2pbBEQAREQAREQAREQAREQgQYQuOKKK9wvv/zi1llnHTfnnHM2oEQVIQIiIAIiMCESkMA8gZ31f/zjH+63335zq622muvSpcsEdvTlD/fyB0e6z7/9yS3XbSa36qKzli9gAspx+eWXuxEjRrhZZpnFHXrooYlH/sgjj7jvvvvOLbDA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1lprWa+d37lM5Re/+EX1xz/+sWJLyp3udKdgYf2ABzyg14tVyM///u//Vve9733DpTVNjP/gBz8IP6255prVSiutNMvbWWedVWHt8oc//KG65z3vWa2yyirVxhtvPMufdSAMFsH4XXXVVSvO9SHPHEtBfnHbfPPNQxD5Be9xF8ucdtpp4eIotnKuvvrqNrnO77kd6ZVXXllxfuHll18e8gnG5OnhD394LS8/+clPwtmOWNKvttpq1XnnnRcu1iGe+9///uEyrHFW9qR14YUXVlzCgJw89KEPrSgvsOMyrRQZr2UscjzzzDOrf/3rX2GrLOXBJJR0l1lmmYqLf9g2S92ooy5yLRlIkRelnZueyoB8nHvuudUll1wSymyTTTap/v3vf1ennnpqKE94eMYznqFkZj3hNaU+XHzxxaG8iODaa6+tvv3tb4e4uEQSGbA0DtfU9Gx8JXja8CnvXduX3PKr4ym13iLHnK1KXaOexkReOIeUcqEu11FJOdTF0+TWh7zktktNvKS623aJ9ot2iWfKGcypePZRb3NxUZql7XXOeKKPci+p77n1rw8+kavUck+VwdhfFz7jCWFOPz0pPOP8j/uWXOPnN7/5TegHeX/KU55S3eUud+E1EO0k/WQdpZZfl3KI0/3xj38c+lLGoIwfubSbs93jtrpL+cVppnx37VdK6q3lK7X/s2G6vKeWA2nk1gfCSD5L213iyKEu8jKJ/HXpb8GlRF5S63sO7m1+c/kcun+35TCX87Fpa19yxj1tMlD3u3QVXMCLLqKN1L5SRg960IOC91w9UZd+rEv7ArO5cl0iL13yFwAt/DdU+ykZGFq/lCtnFsbceuQKZoveHL1/97vfrb7xjW/Mir3tkr/vfe971de//vVZ4eTw+Mc/vtp222312en5pS99qTr99NMb46AhfMlLXtKoxGsMWPPDhz/84TAov+td7zo6/zX29v3vf7/66le/Gpxf85rXBIWw/KCAO+SQQ4ICVW563vnOd65e+tKX1ipr8KOz/R73uMcF5X5duaC4J46DDz64uuiii6rb3/721b777qskZjz5HX/QNttsU6EU7JNyBjR0cl/5yldqk+cMwxe/+MWzyk8dzSMe8YiwqHDppZfOCv+CF7ygVkF91FFHhYF3HOAJT3hCdcoppwTnvi7TetOb3hSUrSiK4JFFAkuU+yte8YoK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AElEQVTu8zUBEzABEzABEzABEzABEzABEzABEzABEzABEzCBPhGwwNwnkC7GBEzABEzABEzABEzABEzABEzABEzABEzABEzABMYbAQvM4+2K+3xNwARMwARMwARMwARMwARMwARMwARMwARMwARMoE8ELDD3CaSLMQETMAETMAETMAETMAETMAETMAETMAETMAETMIHxRsAC83i74j5fEzABEzABEzABEzABEzABEzABEzABEzABEzABE+gTAQvMfQLpYkzABEzABEzABEzABEzABEzABEzABEzABEzABExgvBGwwDzerrjP1wRMwARMwARMwARMwARMwARMwARMwARMwARMwAT6RMACc59AuhgTMAETMAETMAETMAETMAETMAETMAETMAETMAETGG8ELDCPtyvu8zUBEzABEzABEzABEzABEzABEzABEzABEzABEzCBPhGwwNwnkC7GBEzABEzABEzABEzABEzABEzABEzABEzABEzABMYbAQvM4+2K+3xNwARMwARMwARMwARMwARMwARMwARMwARMwARMoE8ELDD3CaSLMQETMAETMAETMAETMAETMAETMAETMAETMAETMIHxRsAC83i74j5fEzABEzABEzABEzABEzABEzABEzABEzABEzABE+gTAQvMfQLpYkzABEzABEzABEzABEzABEzABEzABEzABEzABExgvBGwwDzerrjP1wRMwARMwARMwARMwARMwARMwARMwARMwARMwAT6RMACc59AuhgTMAETMAETMAETMAETMAETMAETMAETMAETMAETGG8ELDCPtyvu8zUBEzABEzABEzABEzABEzABEzABEzABEzABEzCBPhGwwNwnkC7GBEzABEzABEzABEzABEzABEzABEzABEzABEzABMYbAQvM4+2K+3xNwARMwARMwARMwARMwARMwARMwARMwARMwARMoE8ELDAPEeQvf/nLsMoqq4TZZputtqTnnnsufOMb3wivv/56+PrXv16bttuNTz/9dLjtttvC/fffHz7+8Y/H7N/85jfD888/H3baaad4bL/97W/DCiusEGaYYYZuiw8PPPBA+OEPfxhWX331sOKKK1bm/+tf/xouvPDCMOWUU4Zdd921Mt1o2XDwwQeHf/7zn5HhAgssMFoOu/Vxck9ceeWV4Q1veEPYf//9W+erS/j3v/89HHfccWHeeecNX/ziFyuTPvvss+HII48Mc8wxR226ygIKGy677LJwzTXXhB133DG85S1vKaQI4Uc/+lG49dZbw4c//OH4PBQTNazkeTjllFMC98R2221XTP39738/3HfffWHjjTcOyy67bDFNNysffPDB8LOf/SxMNdVUYZdddqnMevHFF4dLL700LL/88mGLLbaoTFe34R//+Ee8hsstt1zYaKON6pKGQw89NNZp++23X206bzQBEzABEzABEzABEzABEzABEzABExi7BCwwD+HaHn/88VF8nXHGGcMBBxxQW9JNN90UzjrrrCj27r333rVpmzYi4vF37733RrEM8VqGsPzMM8+Egw46KAq9iNrHHntseOihh8L0008fxTxEvW4MQXzixInhgx/8YFh33XWLWRHTTjrppCg2kQABb+WVVy6mrVqJiHbCCSdUbW69HhEO4WuoduCBBwaE0M0226xWWB/qfiZFfsTKCRMmdHa91lprhXXWWaez3OuMRPnFFlssiqt5OXPOOWdc9e1vfzvcfffdYe655+40ilSlzddXLSNYP/bYY+Ed73hH+NSnPjUo2R/+8Ifw85//PD4XX/rSlypF6EEZsxXf+ta3wt/+9rew9tprx79sc+A+RmSnoYXnrx/28MMPh2OOOSYWhXA///zzDyr2lltuCWeccUZcT8NSr40iPIM0VjWJ1Fw/riP1CvWNzQRMwARMwARMwARMwARMwARMwARMYHwSsMA8hOuOwIuoir31rW+t9Sz86U9/Gq677rrw/ve/P2y66aZd75X9PP744yEVk1UIguoSSywRhbX3vOc94U9/+lM488wzO8d01113he9+97tR/CXt7rvv3lpc+/Wvfx0uueSSMPvss4evfOUr2uWAKWI34hfe2QiGLM8yyyyhW69GPC/xwByq4b365S9/eajFRG/XG2+8Mbzvfe8LH/nIR4Zc3uRSwMknnxzuueeeMM0004R3vvOd4YYbboiesYcffviQDlH3eF0hm2++eRReSdtke+yxR7yfmtJp+x133BFOPfXUuEgjTtqrIBVot99++7D44osrW1dTvJdpWIJdVSOGGp5WXXXVsOGGG3ZVfl1iCb8LLbRQ+PznPz8g6aOPPhqOPvro+Ax+7GMfC3gf92LXX399+MlPfhJ7Onzta1+rLeKCCy4Iv/vd78IyyyxT2UhQW4A3moAJ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AYx0DAqWDiDIOlkp/rI8mpWG6fTTTx8OOuigdNWAecWxbWIwINMYXBiJ+MttsBHqhXuFRhO877F+CN66P5vE3DbHWBV/mdAYp5xySmys2W677QYVRa8FPP/x6EWkJvwLttNOO4UFFlggzuf/4KDB9vL7WAIz925pwD49b/kzgICMME6Yi5Llzzv1GKFA0udd8ZdL+fN1beIvK4Y84W7oDUG4HZ5nzg1PbZsJmIAJmIAJmIAJmIAJmIAJmIAJmMDoJWCBuctrd/XVVw+I23rHHXcE4i13awgraVzVPL+8O7WeQcPoWv6Wt7xFq2qnhKtAaMIQwxZZZJHK9AjSeFIj/lQZHsf9iL8sQY1QFXVex3jI4nk922yzhbXXXjseFh6hiO4YwvtSSy0VhbQ6Jopt22bQs1jwGP03EvGX26CTaKq0NJAQcmWopvuzLl5w230QloVnmgacJZdcsm22GJoGIRXj+Sb8y8orrxx7ADQVQhgN7vXUTjvttBimJl2XzmsfCLz0VGhrbZ53nr3zzz8/NgDJ4zwvH09pGgvaxF8mr3okqByEeOKhd3PsyuupCZiACZiACZiACZiACZiACZiACZjA5EPAAvPkcy0GHQliLFbyXhyUeARWTJw4McwyyyyVe2raXplxmDcgFi677LLDvJfJu3i8bwmlgJhHY8VQjVARXG8GwMOjv62RD8/eqaeeeoDHbNv8VenoSYAXM2EmEHYnpSmMS7+OQfVAXt5w1gvcKwzwOe+881Y2asH85Zdfbv1scR4MWsh9Q2PWav+JrW4zARMwARMwARMwARMwARMwARMwARMY/QQsMI/+a+gzMAETMAETMAETMAETMAETMAETMAETMAETMAETMIFJQsAC8yTB7p2agAmYgAmYgAmYgAmYgAmYgAmYgAmYgAmYgAmYwOgnYIF59F9Dn4EJmIAJmIAJmIAJmIAJmIAJmIAJmIAJmIAJmIAJTBICFpgnCXbv1ARMwARMwARMwARMwARMwARMwARMwARMwARMwARGPwELzKP/GvoMTMAETMAETMAETMAETMAETMAETMAETMAETMAETGCSELDA3AP2jTfeOOY69dRTwxxzzNFDCUPL8thjj4UddtghzDrrrOH73//+0ApryH3eeeeFyy+/POy3335httlmq039hz/8IVxzzTVh/vnnD5tttlltWm80ARMwgTYE7r333jDllFOGBRZYoE3yAWk++clPxuUf/OAHA9ZPjgu/+tWvwgorrDConn3Pe94TD/f6668fcNhXX311+Nvf/hbWXXfdMPvssw/Y1maBuv3nP/952HzzzcOGG25YmeUb3/hG4BoccMABYe65565MN7ltOPHEE8PNN98c9tprr7DooouOyOGJFe/L+eabr3GfXNMZZpghLLHEEo1p8wSbbrppmGeeeQLnWbJf/OIX4ayzzgpbbLFF/Cul8bpJR+DOO+8MX/jCF8L2228fPvrRjxYP5IQTTgjUC1/+8pfDaqutVkwzmlaefPLJgY+O7373uz3V5/m5Pvjgg+HZZ58Nb3/72/NNg5b//ve/h89+9rPxNzu/3YdqI1m/8KxT9371q18Nc845Z+Whc35TTTVVrPPe+ta3VqZru4Hf9FyrbbbZJnzgAx8oZrvwwgvDscceG7beeuvwqU99qpjGK03ABEzABEzABMYPAQvMXV5rxN0NNtgg5so/+LssqufkDz30UPjwhz8cBeZLLrmk53JKGe+7777Ah8+tt94afvnLX4YXXnghJvvgBz8YDj/88Dh/1113hccffzw88cQTcUr63/3udwOK+81vfhPe/OY3D1hXWuADqlebYoopwk477dRrducbAgHujaeffjq8853vDMsvv/wQSnLWfhD4/e9/H/bZZ5+eikIUe9/73teYl2f8ySefbEzXTYI3velNYb311qvNUiWw1mb678Zu8/7pT38K559/fpuiG9O87W1vCxK4mxJ/6UtfinUoYuCee+45IHnVOay11lrhH//4RxR+6wTiAYUlCzvvvHNsEPzKV74SPvKRjyRbBs4iGvA+QKRvI+Qo94QJE8Lrr7+uxQHTN77xjVHo2XLLLQesr1ugrvnWt75Vl6Sz7Y477ggf//jH4zI/crgWiC+ITG0MMefb3/52m6QD0ojVj3/840ZR+6c//Wk48sgjw/TTTx9+8pOfRLF4QGE1C9yn2267bVhwwQXD2WefXUyp63vQQQeF9ddfv5jGKycdAerdn/3sZyH9bZUfzcEHHxzOPffcwLSpnszzapnnm4b/odrXv/71SpGxbdmUwW+HtddeOxx66KFtsxXTPfroo+ETn/hErAO/+c1vNgrw/LalnnvLW94SLrroomKZbVeOZP1ywQUXhK997WuxnqAOfsMb3jDoMBGTb7vttigE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TT2vQwhq+qinkQUxYP755y+KxOKYftAjKuKVRyNQGw9BTgARBxEbD+42g9jhGcgfjYoTJ06M7yS4M897AENAQsDo1vBSpIGjW8Nr++CDD27MlgtAakxBUF5xxRUH9MYoFYZYhvcy16SugSfPy7XimvPuZz/sr40h/HJevIO5R6sMr27ipHfT0yIflBgP6TXXXLOVkFZ1HGNpfTrYpc4rDTGgdf2a5gJz6lDAvcPvLHpipA27/P6iJwf38e23395pJOCYqsJ90YiDp35T+DAaOF599dXOGAv83kXclr3rXe+Kv33pzVBn1BXcv/xuYwyFPJRRmlcD86Xrqhq90jTpPPUhzwz1X+6Jj2DMOfGs0PDGHw2n8C2ZrkneO7GUlnUjVb/0KjDnvdHa9m6oOt90fel9lG73vAmYgAmYgAmYwPgmYIG55fVHnORjeiwaHy9VP7zz88X7uCSYsB7P1+WWWy7+qM/ztV1GOMGI7yp397Z569KlMZjTAeTq8nibCUzuBKiX+JBu47Fcdy40aD3zzDN9rePwMHvttdc6u51xxhlHvZd652RGcAYPRizt7TGCux+Vu/r1r38dY8iPNDOE6SZP8lEJdIwfNGKlGnDwNO+loa4tIjx8r7322uhxy34QdAnfgPDfth7ndxI9m2icqgoL1PZ4+pkOQRRhvE0vGI6dhireXyXP/rbHpXAebdNXpSMUGyGU2thI1i84XcC0bWgUjp8GS3oBYlyLtvdVzNDwj7An9IaoCrnXkN2bTcAETMAETMAExjgBC8xj/AL79P6fAOFJLrjgghjnr00oDXMzARMwARMwARMwARMwARMwARMwARMwARMwARNoJmCBuZmRU5iACZiACZiACZiACZiACZiACZiACZiACZiACZiACRQIWGAuQPEqEzABEzABEzABEzABEzABEzABEzABEzABEzABEzCBZgIWmJsZOYUJmIAJmIAJmIAJmIAJmIAJmIAJmIAJmIAJmIAJmECBgAXmAhSvMgETMAETMAETMAETMAETMAETMAETMAETMAETMAETaCZggbmZkVOYgAmYgAmYgAmYgAmYgAmYgAmYgAmYgAmYgAmYgAkUCFhgLkDxKhMwARMwARMwARMwARMwARMwARMwARMwARMwARMwgWYCFpibGTmFCZiACZiACZiACZiACZiACZiACZiACZiACZiACZhAgYAF5gIUrzIBEzABEzABEzABEzABEzABEzABEzABEzABEzABE2gmYIG5mZFTmIAJmIAJmIAJmIAJmIAJmIAJmIAJmIAJmIAJmIAJFAhYYC5A8SoTMAETMAETMAETMAETMAETMAETMAETMAETMAETMIFmAhaYmxk5hQmYgAmYgAmYgAmYgAmYgAmYgAmYgAmYgAmYgAmYQIGABeYCFK8yARMwARMwARMwARMwARMwARMwARMwARMwARMwARNoJmCBuZmRU5iACZiACZiACZiACZiACZiACZiACZiACZiACZiACRQIWGAuQPEqEzABEzABEzABEzABEzABEzABEzABEzABEzABEzCBZgIWmJsZOYUJmIAJmIAJmIAJmIAJmIAJmIAJmIAJmIAJmIAJmECBgAXmAhSvMgETMAETMAETMAETMAETMAETMAETMAETMAETMAETaCZggbmZkVOYgAmYgAmYgAmYgAmYgAmYgAmYgAmYgAmYgAmYgAkUCFhgLkDxKhMwARMwARMwARMwARMwARMwARMwARMwARMwARMwgWYCFpibGTmFCZiACZiACZiACZiACZiACZiACZiACZiACZiACZhAgYAF5gIUrzIBEzABEzABEzABEzABEzABEzABEzABEzABEzABE2gmYIG5mZFTmIAJmIAJmIAJmIAJmIAJmIAJmIAJmIAJmIAJmIAJFAhYYC5A8SoTMAETMAETMAETMAETMAETMAETMAETMAETMAETMIFmAhaYmxk5hQmYgAmYgAmYgAmYgAmYgAmYgAmYgAmYgAmYgAmYQIGABeYCFK8yARMwARMwARMwARMwARMwARMwARMwARMwARMwARNoJmCBuZmRU5iACZiACZiACZiACZiACZiACZiACZiACZiACZiACRQIWGAuQPEqEzABEzABEzABEzABEzABEzABEzABEzABEzABEzCBZgIWmJsZOYUJmIAJmIAJmIAJmIAJmIAJmIAJmIAJmIAJmIAJmECBgAXmAhSvMgETMAETMAETMAETMAETMAETMAETMAETMAETMAETaCZggbmZkVOYgAmYgAmYgAmYgAmYgAmYgAmYgAmYgAmYgAmYgAkUCFhgLkDxKhMwARMwARMwARMwARMwARMwARMwARMwARMwARMwgWYCFpibGTmFCZiACZiACZiACZiACZiACZiACZiACZiACZiACZhAgYAF5gIUrzIBEzABEzABEzABEzABEzABEzABEzABEzABEzABE2gmYIG5mZFTjFECTzzxRPjWt74Vz+5rX/vaGD3LkTmtLbfcMrzvfe8Lu+66a9zhH//4x3DooYeGjTbaKGy77bZ9PYhNN900zDPPPOHEE08slvuLX/winHXWWWGLLbaIf8VEQ1x5yCGHhL/+9a/h85//fDzvIRY3IPtTTz0VPvGJT4QPfOAD4Stf+cqAbVrgvv3pT38aGa+88spa7ekoJHDOOeeEZZddNiywwAKNR7/ffvuFG2+8May//vphp512akzfSwL28dJLL8Xy2xxTN/v4xje+Ee69997APuabb77GrNdff32YYYYZwhJLLNGYtpSAemmWWWYJ3/72t0ubR+U6+E055ZSt7pf8BD/5yU/GVT/4wQ/yTcOyTD356quvBva70EILDcs+XKgJmIAJmIAJmIAJmIAJmMDkQcAC8+RxHSb5Ufzyl78MTz/9dHjnO98Zll9++Ul+PCNxAAcddFA477zzwrvf/e7wne98ZyR22biPv/3tb+Hcc88dlI5rstJKKw1aP9QVv/nNb8LLL78cpp566rDuuut2ikPEevjhh+Pyhhtu2FlfmvnDH/7QEbsQhDCxRQT71Kc+Fdf149+f/vSnKFgvuOCC4eyzzy4WufPOO4drrrkmHgNC3HDYHnvsEa644orI7Otf//qQdkH+v//9750yEPc4z+mnnz4+j50N/5k54IADwlve8paw1lprhX/84x/xXpl33nnTJJ4fIgHqgueff35IpfCsvve9720s44ILLgg0bnGtaTSg/q2y888/Pxx44IGdzaeeempYZpllOstDnXnsscfCPvvsE+89yvre975Xezy97I+64NZbbw0//vGPw6KLLlpbBA0oRx55ZGTzk5/8JDYq1WYobHzPe94TZp111nDJJZcM2MoPHxqqTjvttPgcD9iYLHzhC1+ovI6/+93vwpNPPpmkHvrsm970prDeeuvVFsQ5YapraxNnG7vNO9T3Aw0JF198cWyEq2oQzA7RiyZgAiZgAiZgAiZgAiZgAqOUgAXmlhcOEY0P7jZ28MEHRxGoTdo2aR599NGYbK655mqTvKc0fGw/8MAD0XNyl112aVXG1VdfHeQJtffeexc9qr75zW+Gu+66KyCCffWrX43lXn755QHBILUpppgi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CIMx0gIzx1DyLKdxjsYTGmSHYnihE/aJc8aLuY3BAJb98k4v7VMNb4S24rmymYAJmIAJmIAJmIAJmIAJjF0CFpjH7rX1mZnAsBMgdMyb3vSmAYNIaad0u5cxiGWTYKe0k8MUsbGqe/nkcHzj5RjSGMzpQKHDdf4MzodHvG14CDz66KNhrrnmGp7C/1sqHvnXXnttmH/++cM73vGOAfvCc5ceRDR2cRz0tOCYhjPsig6Afb/22mtaDDPOOONk38unc7CeMQETMAETMAETMAETMAETMIEGAhaYGwB5swmYgAmYwKQhcMstt4QLLrggDiTaFGpi0hyh92oCJmACJmACJmACJmACJmACJmACJmCB2feACZiACZiACZiACZiACZiACZiACZiACZiACZiACZhATwQsMPeEzZlMwARMwARMwARMwARMwARMwARMwARMwARMwARMwAQsMPseMAETMAETMAETMAETMAETMAETMAETMAETMAETMAET6ImABeaesDmTCZiACZiACZiACZiACZiACZiACZiACZiACZiACZiABWbfAyZgAiZgAiZgAiZgAiZgAiZgAiZgAiZgAiZgAiZgAj0RsMDcEzZnMgETMAETMAETMAETMAETMAETMAETMAETMAETMAETsMDse8AETMAETMAETMAETMAETMAETMAETMAETOD/2rufEJvaOA7gT42hZjMpSrIYhY2FKbOS2NhQRKJYKLFQFCt/olkYZUfKYpTZzIIiRcSClSyokaSEEiFJiQ0r6u156t7OnTH3PPdpvN7e+zmLuec8z+937p3PeVbfTucQIECAQJGAgLmITRMBAgQIECBAgAABAgQIECBAgAABAgQICJitAQIECBAgQIAAAQIECBAgQIAAAQIECBAoEhAwF7FpIkCAAAECBAgQIECAAAECBAgQIECAAAEBszVAgAABAgQIECBAgAABAgQIECBAgAABAkUCAuYiNk0ECBAgQIAAAQIECBAgQIAAAQIECBAgIGC2BggQIECAAAECBAgQIECAAAECBAgQIECgSEDAXMSmiQABAgQIECBAgAABAgQIECBAgAABAgQEzNYAAQIECBAgQIAAAQIECBAgQIAAAQIECBQJCJiL2DQRIECAAAECBAgQIECAAAECBAgQIECAgIDZGiBAgAABAgQIECBAgAABAgQIECBAgACBIgEBcxGbJgIECBAgQIAAAQIECBAgQIAAAQIECBAQMFsDBAgQIECAAAECBAgQIECAAAECBAgQIFAkIGAuYtNEgAABAgQIECBAgAABAgQIECBAgAABAgJma4AAAQIECBAgQIAAAQIECBAgQIAAAQIEigQEzEVsmggQIECAAAECBAgQIECAAAECBAgQIEBAwGwNECBAgAABAgQIECBAgAABAgQIECBAgECRgIC5iE0TAQIECBAgQIAAAQIECBAgQIAAAQIECAiYrQECBAgQIECAAAECBAgQIECAAAECBAgQKBIQMBexaSJAgAABAgQIECBAgAABAgQIECBAgAABAbM1QIAAAQIECBAgQIAAAQIECBAgQIAAAQJFAgLmIjZNBAgQIECAAAECBAgQIECAAAECBAgQICBgtgYIECBAgAABAgQIECBAgAABAgQIECBAoEhAwFzEpokAAQIECBAgQIAAAQIECBAgQIAAAQIEBMzWAAECBAgQIECAAAECBAgQIECAAAECBAgUCQiYi9g0ESBAgAABAgQIECBAgAABAgQIECBAgICAOWMNvHnzJnz//j2jMr9kzpw5YenSpfkNkyrPnj0bnjx5kkbHx8cnzTokQIAAAQIECBAgQIAAAQIECBAgQIDAnxcQMGcYb9u2LcSQeSa3xYsXh6tXrxaf8sCBA+Hhw4epf2Jiovg8GgkQIECAAAECBAgQIECAAAECBAgQIFAqIGDOkPuvB8wrV66s/S8uXLhQW6OAAAECBAgQIECAAAECBAgQIECAAAECnQgImDO0nj17Fn78+DGl8ufPn+HgwYNpfPXq1WHHjh1p//Lly+HBgwdp/9y5c2HWrFlTeufOnRuWLVs2ZTx3oHoHc06Pu5xzlNQQIECAAAECBAgQIECAAAECBAgQINCJgIA5U+vTp0/h8ePHLdW/fv0KJ0+eTGPxLuJNmzal/Yj69OnTtD88PBx6enpa+pYvXx4GBgZaxjo9qAbMS5Ysads+e/bs0Mlzmj9+/JjOt3DhwrbnNUmAAAECBAgQIECAAAECBAgQIECAQHcLCJgzr//169fDqVOnMqvbl504cSJs3ry5fVHNbDVgnsm7ky9evBhGR0fTt+/bty/s3bu35peYJkCAAAECBAgQIECAAAECBAgQIECgWwUEzJlX/m8GzF+/fp3yK48ePdq8o/ru3btT5hsD8VEcnWxr1qxpPg6kr68v3L9/v5N2tQQIECBAgAABAgQIECBAgAABAgQIdJGAgDnzYlcD5rGxsbBixYrUOTQ0lD63bt0ajh07lvZPnz4drl27lvYbdxfHR2bs2bMnjeXewfzq1auwc+fO1FP6Z/v27eHw4cPZ7fv37w+PHj1K9fGxH14OmE2nkAABAgQIECBAgAABAgQIECBAgEDXCQiYMy95NWCOoWsMX+PWCJjjIy9icBy3kZGRcOPGjbTfCJjjZ3zkRNxyA+bnz5+HXbt2pZ7SP50GzB8+fAhXrlxJXxd7Fy1aVPrV+ggQIECAAAECBAgQIECAAAECBAgQ+J8LCJgzL3A1YM5smbasJGAeHBwMq1atmvac1Ylv376FS5cupaFOA+bqeewTIECAAAECBAgQIECAAAECBAgQIECgnYCAuZ1OZe5vB8zxZXuNO6ArP+u3u+/fvw9btmxJcwLm3xIZJECAAAECBAgQIECAAAECBAgQIEBgBgQEzJmI8dERL168mFJ95syZ8Pnz5zS+YcOGEF+SV7fF5zfPnz+/rixUH5EhYK7lUkCAAAECBAgQIECAAAECBAgQIECAwL8sIGDOAL958+Zvq758+RLOnz/fnDt06FDo7+9vHtftbNy4sW1JNWCOL/vbvXt32/rG5Lt375ovFHQHc0PFJwECBAgQIECAAAECBAgQIECAAAECMy0gYK4RjXcuxxf4/Ynt1q1bYcGCBdOeuhowT1tUM1ESMN+7dy+ddd26dTVnN02AAAECBAgQIECAAAECBAgQIECAQDcLCJhrrn63BczDw8Ph9u3bSWX9+vVhZGSkRsg0AQIECBAgQIAAAQIECBAgQIAAAQLdKiBgzrjyb9++bal6+fJlOH78eHNsdHQ0zJs3r3kcd16/fh2OHDmSxvr6+sLY2Fjo7e1tqRkYGGg5nnwQn+18586d0NPTM3kq6zg+wmPt2rVhcHAwqz4WDQ0NtdROTEy0HDsgQIAAAQIECBAgQIAAAQIECBAgQIBAQ+BvBcz/AEuuoBPe/I/FAAAAAElFTkSuQmCC"}}]},"uuid":"61fd41b7-48f4-415c-bfd1-33ec425091fa","timestamp":"2026-02-25T08:15:04.428Z","imagePasteIds":[1],"permissionMode":"acceptEdits"}
{"parentUuid":"61fd41b7-48f4-415c-bfd1-33ec425091fa","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_01NwVCsQ6nAqPZwxcWbm9MUm","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user wants to remove the full URL hint line (the `↳` line) and only keep the truncated URL with the Ctrl+Click OSC 8 link. Let me remove the URL hint line from both the main tool call and subagent tool call sections.","signature":"EocDCkYICxgCKkBIuGWD+yx40H9nb6bGyaIxbDnKYskFt8nHxdnSiXDs9i9/qiqobDebDuBWkdzBuY/WmvEL5A49w2+m1OtHoBpwEgyMG1mCIDIUVwMqz4EaDJ1naJFsm/grjUb86yIwOEYwW8PHGbJqT2r418ppUG+frtu32FHZheQI0B22Bd0EcP4MA+nO4OcyjrC3NtXTKu4BswVISSxPAK/n++NwRy8aVz7OWz3jMl1VOJ417q1eEcdRk9ol4Mcv6HB+BoRQDPB0wvi0dqeeYwHXQIeCUybLwww5sm34kr6jzMBeUj33jDuErIJuaRLJnjbGu80LsvvxHJCfykxu2qOX29imS4Fr3hgxEUEYf9E2OfWcdCPbzXhW1cf0nTRO7vbj40KjhvJRi5J9vIen0CVY6Eq7pDjTJF1kN2Ee3iHLoY3GFY6t2GFWXFeIqmp2NnUPKz70zpJZhCO9vY1Y6WZH5KEkmO34wUYlWBdhiKAZxLfBpQc6ng+u9PcQm9EDkUGJeuLmKhgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":34226,"cache_read_input_tokens":10366,"cache_creation":{"ephemeral_5m_input_tokens":34226,"ephemeral_1h_input_tokens":0},"output_tokens":10,"service_tier":"standard","inference_geo":"global"}},"type":"assistant","uuid":"45700d0e-0f7f-46fa-9c1b-10b80b7fe48d","timestamp":"2026-02-25T08:15:14.235Z"}
{"parentUuid":"45700d0e-0f7f-46fa-9c1b-10b80b7fe48d","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_01NwVCsQ6nAqPZwxcWbm9MUm","type":"message","role":"assistant","content":[{"type":"text","text":"Understood — remove the `↳` full URL hint lines, keep only the truncated URL with the OSC 8 link for Ctrl+Click."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":34226,"cache_read_input_tokens":10366,"cache_creation":{"ephemeral_5m_input_tokens":34226,"ephemeral_1h_input_tokens":0},"output_tokens":10,"service_tier":"standard","inference_geo":"global"}},"type":"assistant","uuid":"15fc37e2-8217-4dfb-b58b-641b49003dee","timestamp":"2026-02-25T08:15:14.786Z"}
{"parentUuid":"15fc37e2-8217-4dfb-b58b-641b49003dee","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_01NwVCsQ6nAqPZwxcWbm9MUm","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018PVf3MQqxFBjPJYE2LTQpB","name":"Edit","input":{"replace_all":false,"file_path":"/Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/ui/shell/visualize.py","old_string":"        # Show full URL hint when URL was truncated\n        if self._full_url and self._full_url != self._argument:\n            url_hint = Text()\n            url_hint.append(\"  ↳ \", style=\"grey50\")\n            url_hint.append(self._full_url, style=Style(color=\"grey50\", link=self._full_url))\n            lines.append(url_hint)\n\n        if self._n_finished_subagent_tool_calls > MAX_SUBAGENT_TOOL_CALLS_TO_SHOW:","new_string":"        if self._n_finished_subagent_tool_calls > MAX_SUBAGENT_TOOL_CALLS_TO_SHOW:"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":34226,"cache_read_input_tokens":10366,"output_tokens":396,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":34226},"inference_geo":"","iterations":[],"speed":"standard"}},"type":"assistant","uuid":"f2324b0e-a310-407c-8b4e-b3f08207b3b8","timestamp":"2026-02-25T08:15:18.992Z"}
{"parentUuid":"f2324b0e-a310-407c-8b4e-b3f08207b3b8","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_018PVf3MQqxFBjPJYE2LTQpB","toolUseID":"toolu_018PVf3MQqxFBjPJYE2LTQpB","timestamp":"2026-02-25T08:15:19.076Z","uuid":"c93a4042-cc7b-470b-bd1d-00c69ed88d75"}
{"parentUuid":"f2324b0e-a310-407c-8b4e-b3f08207b3b8","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018PVf3MQqxFBjPJYE2LTQpB","type":"tool_result","content":"The file /Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/ui/shell/visualize.py has been updated successfully."}]},"uuid":"f3c0f591-6756-4adc-b281-ba7e6d7c19b4","timestamp":"2026-02-25T08:15:19.075Z","toolUseResult":{"filePath":"/Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/ui/shell/visualize.py","oldString":"        # Show full URL hint when URL was truncated\n        if self._full_url and self._full_url != self._argument:\n            url_hint = Text()\n            url_hint.append(\"  ↳ \", style=\"grey50\")\n            url_hint.append(self._full_url, style=Style(color=\"grey50\", link=self._full_url))\n            lines.append(url_hint)\n\n        if self._n_finished_subagent_tool_calls > MAX_SUBAGENT_TOOL_CALLS_TO_SHOW:","newString":"        if self._n_finished_subagent_tool_calls > MAX_SUBAGENT_TOOL_CALLS_TO_SHOW:","originalFile":"from __future__ import annotations\n\nimport asyncio\nimport json\nfrom collections import deque\nfrom collections.abc import Awaitable, Callable\nfrom contextlib import asynccontextmanager, suppress\nfrom typing import NamedTuple\n\nimport streamingjson  # type: ignore[reportMissingTypeStubs]\nfrom kosong.message import Message\nfrom kosong.tooling import ToolError, ToolOk\nfrom rich.console import Group, RenderableType\nfrom rich.live import Live\nfrom rich.markup import escape\nfrom rich.padding import Padding\nfrom rich.panel import Panel\nfrom rich.spinner import Spinner\nfrom rich.style import Style\nfrom rich.text import Text\n\nfrom kimi_cli.tools import extract_key_argument\nfrom kimi_cli.ui.shell.console import console\nfrom kimi_cli.ui.shell.keyboard import KeyboardListener, KeyEvent\nfrom kimi_cli.utils.aioqueue import QueueShutDown\nfrom kimi_cli.utils.diff import format_unified_diff\nfrom kimi_cli.utils.logging import logger\nfrom kimi_cli.utils.message import message_stringify\nfrom kimi_cli.utils.rich.columns import BulletColumns\nfrom kimi_cli.utils.rich.markdown import Markdown\nfrom kimi_cli.utils.rich.syntax import KimiSyntax\nfrom kimi_cli.wire import WireUISide\nfrom kimi_cli.wire.types import (\n    ApprovalRequest,\n    ApprovalResponse,\n    BriefDisplayBlock,\n    CompactionBegin,\n    CompactionEnd,\n    ContentPart,\n    DiffDisplayBlock,\n    ShellDisplayBlock,\n    StatusUpdate,\n    StepBegin,\n    StepInterrupted,\n    SubagentEvent,\n    TextPart,\n    ThinkPart,\n    TodoDisplayBlock,\n    ToolCall,\n    ToolCallPart,\n    ToolCallRequest,\n    ToolResult,\n    ToolReturnValue,\n    TurnBegin,\n    TurnEnd,\n    WireMessage,\n)\n\nMAX_SUBAGENT_TOOL_CALLS_TO_SHOW = 4\n\n# Truncation limits for approval request display\nMAX_PREVIEW_LINES = 4\n\n\nasync def visualize(\n    wire: WireUISide,\n    *,\n    initial_status: StatusUpdate,\n    cancel_event: asyncio.Event | None = None,\n):\n    \"\"\"\n    A loop to consume agent events and visualize the agent behavior.\n\n    Args:\n        wire: Communication channel with the agent\n        initial_status: Initial status snapshot\n        cancel_event: Event that can be set (e.g., by ESC key) to cancel the run\n    \"\"\"\n    view = _LiveView(initial_status, cancel_event)\n    await view.visualize_loop(wire)\n\n\nclass _ContentBlock:\n    def __init__(self, is_think: bool):\n        self.is_think = is_think\n        self._spinner = Spinner(\"dots\", \"Thinking...\" if is_think else \"Composing...\")\n        self.raw_text = \"\"\n\n    def compose(self) -> RenderableType:\n        return self._spinner\n\n    def compose_final(self) -> RenderableType:\n        return BulletColumns(\n            Markdown(\n                self.raw_text,\n                style=\"grey50 italic\" if self.is_think else \"\",\n            ),\n            bullet_style=\"grey50\" if self.is_think else None,\n        )\n\n    def append(self, content: str) -> None:\n        self.raw_text += content\n\n\nclass _ToolCallBlock:\n    class FinishedSubCall(NamedTuple):\n        call: ToolCall\n        result: ToolReturnValue\n\n    @staticmethod\n    def _extract_full_url(\n        json_content: str | streamingjson.Lexer, tool_name: str\n    ) -> str | None:\n        if tool_name != \"FetchURL\":\n            return None\n        json_str = (\n            json_content.complete_json()\n            if isinstance(json_content, streamingjson.Lexer)\n            else json_content\n        )\n        try:\n            args = json.loads(json_str)\n        except (json.JSONDecodeError, ValueError):\n            return None\n        if isinstance(args, dict) and args.get(\"url\"):\n            return str(args[\"url\"])\n        return None\n\n    def __init__(self, tool_call: ToolCall):\n        self._tool_name = tool_call.function.name\n        self._lexer = streamingjson.Lexer()\n        if tool_call.function.arguments is not None:\n            self._lexer.append_string(tool_call.function.arguments)\n\n        self._argument = extract_key_argument(self._lexer, self._tool_name)\n        self._full_url = self._extract_full_url(self._lexer, self._tool_name)\n        self._result: ToolReturnValue | None = None\n\n        self._ongoing_subagent_tool_calls: dict[str, ToolCall] = {}\n        self._last_subagent_tool_call: ToolCall | None = None\n        self._n_finished_subagent_tool_calls = 0\n        self._finished_subagent_tool_calls = deque[_ToolCallBlock.FinishedSubCall](\n            maxlen=MAX_SUBAGENT_TOOL_CALLS_TO_SHOW\n        )\n\n        self._spinning_dots = Spinner(\"dots\", text=\"\")\n        self._renderable: RenderableType = self._compose()\n\n    def compose(self) -> RenderableType:\n        return self._renderable\n\n    @property\n    def finished(self) -> bool:\n        return self._result is not None\n\n    def append_args_part(self, args_part: str):\n        if self.finished:\n            return\n        self._lexer.append_string(args_part)\n        # TODO: maybe don't extract detail if it's already stable\n        argument = extract_key_argument(self._lexer, self._tool_name)\n        if argument and argument != self._argument:\n            self._argument = argument\n            self._full_url = self._extract_full_url(self._lexer, self._tool_name)\n            self._renderable = BulletColumns(\n                self._build_headline_text(),\n                bullet=self._spinning_dots,\n            )\n\n    def finish(self, result: ToolReturnValue):\n        self._result = result\n        self._renderable = self._compose()\n\n    def append_sub_tool_call(self, tool_call: ToolCall):\n        self._ongoing_subagent_tool_calls[tool_call.id] = tool_call\n        self._last_subagent_tool_call = tool_call\n\n    def append_sub_tool_call_part(self, tool_call_part: ToolCallPart):\n        if self._last_subagent_tool_call is None:\n            return\n        if not tool_call_part.arguments_part:\n            return\n        if self._last_subagent_tool_call.function.arguments is None:\n            self._last_subagent_tool_call.function.arguments = tool_call_part.arguments_part\n        else:\n            self._last_subagent_tool_call.function.arguments += tool_call_part.arguments_part\n\n    def finish_sub_tool_call(self, tool_result: ToolResult):\n        self._last_subagent_tool_call = None\n        sub_tool_call = self._ongoing_subagent_tool_calls.pop(tool_result.tool_call_id, None)\n        if sub_tool_call is None:\n            return\n\n        self._finished_subagent_tool_calls.append(\n            _ToolCallBlock.FinishedSubCall(\n                call=sub_tool_call,\n                result=tool_result.return_value,\n            )\n        )\n        self._n_finished_subagent_tool_calls += 1\n        self._renderable = self._compose()\n\n    def _compose(self) -> RenderableType:\n        lines: list[RenderableType] = [\n            self._build_headline_text(),\n        ]\n\n        # Show full URL hint when URL was truncated\n        if self._full_url and self._full_url != self._argument:\n            url_hint = Text()\n            url_hint.append(\"  ↳ \", style=\"grey50\")\n            url_hint.append(self._full_url, style=Style(color=\"grey50\", link=self._full_url))\n            lines.append(url_hint)\n\n        if self._n_finished_subagent_tool_calls > MAX_SUBAGENT_TOOL_CALLS_TO_SHOW:\n            n_hidden = self._n_finished_subagent_tool_calls - MAX_SUBAGENT_TOOL_CALLS_TO_SHOW\n            lines.append(\n                BulletColumns(\n                    Text(\n                        f\"{n_hidden} more tool call{'s' if n_hidden > 1 else ''} ...\",\n                        style=\"grey50 italic\",\n                    ),\n                    bullet_style=\"grey50\",\n                )\n            )\n        for sub_call, sub_result in self._finished_subagent_tool_calls:\n            sub_args = sub_call.function.arguments or \"\"\n            argument = extract_key_argument(sub_args, sub_call.function.name)\n            sub_full_url = self._extract_full_url(sub_args, sub_call.function.name)\n\n            sub_headline = Text()\n            sub_headline.append(\"Used \")\n            sub_headline.append(sub_call.function.name, style=\"blue\")\n            if argument:\n                sub_headline.append(\" (\", style=\"grey50\")\n                sub_arg_style = (\n                    Style(color=\"grey50\", link=sub_full_url)\n                    if sub_full_url\n                    else \"grey50\"\n                )\n                sub_headline.append(argument, style=sub_arg_style)\n                sub_headline.append(\")\", style=\"grey50\")\n\n            sub_lines: list[RenderableType] = [sub_headline]\n            if sub_full_url and sub_full_url != argument:\n                sub_url_hint = Text()\n                sub_url_hint.append(\"  ↳ \", style=\"grey50\")\n                sub_url_hint.append(\n                    sub_full_url,\n                    style=Style(color=\"grey50\", link=sub_full_url),\n                )\n                sub_lines.append(sub_url_hint)\n\n            lines.append(\n                BulletColumns(\n                    Group(*sub_lines) if len(sub_lines) > 1 else sub_headline,\n                    bullet_style=\"green\" if not sub_result.is_error else \"red\",\n                )\n            )\n\n        if self._result is not None:\n            for block in self._result.display:\n                if isinstance(block, BriefDisplayBlock):\n                    style = \"grey50\" if not self._result.is_error else \"red\"\n                    if block.text:\n                        lines.append(Markdown(block.text, style=style))\n                elif isinstance(block, TodoDisplayBlock):\n                    markdown = self._render_todo_markdown(block)\n                    if markdown:\n                        lines.append(Markdown(markdown, style=\"grey50\"))\n\n        if self.finished:\n            assert self._result is not None\n            return BulletColumns(\n                Group(*lines),\n                bullet_style=\"green\" if not self._result.is_error else \"red\",\n            )\n        else:\n            return BulletColumns(\n                Group(*lines),\n                bullet=self._spinning_dots,\n            )\n\n    def _build_headline_text(self) -> Text:\n        text = Text()\n        text.append(\"Used \" if self.finished else \"Using \")\n        text.append(self._tool_name, style=\"blue\")\n        if self._argument:\n            text.append(\" (\", style=\"grey50\")\n            arg_style = (\n                Style(color=\"grey50\", link=self._full_url)\n                if self._full_url\n                else \"grey50\"\n            )\n            text.append(self._argument, style=arg_style)\n            text.append(\")\", style=\"grey50\")\n        return text\n\n    def _render_todo_markdown(self, block: TodoDisplayBlock) -> str:\n        lines: list[str] = []\n        for todo in block.items:\n            normalized = todo.status.replace(\"_\", \" \").lower()\n            match normalized:\n                case \"pending\":\n                    lines.append(f\"- {todo.title}\")\n                case \"in progress\":\n                    lines.append(f\"- {todo.title} ←\")\n                case \"done\":\n                    lines.append(f\"- ~~{todo.title}~~\")\n                case _:\n                    lines.append(f\"- {todo.title}\")\n        return \"\\n\".join(lines)\n\n\nclass _ApprovalContentBlock(NamedTuple):\n    \"\"\"A pre-rendered content block for approval request with line count.\"\"\"\n\n    text: str\n    lines: int\n    style: str = \"\"\n    lexer: str = \"\"\n\n\nclass _ApprovalRequestPanel:\n    def __init__(self, request: ApprovalRequest):\n        self.request = request\n        self.options: list[tuple[str, ApprovalResponse.Kind]] = [\n            (\"Approve once\", \"approve\"),\n            (\"Approve for this session\", \"approve_for_session\"),\n            (\"Reject, tell Kimi what to do instead\", \"reject\"),\n        ]\n        self.selected_index = 0\n\n        # Pre-render all content blocks with line counts\n        self._content_blocks: list[_ApprovalContentBlock] = []\n        last_diff_path: str | None = None\n\n        # Handle description (only if no display blocks)\n        if request.description and not request.display:\n            text = request.description.rstrip(\"\\n\")\n            self._content_blocks.append(\n                _ApprovalContentBlock(text=text, lines=text.count(\"\\n\") + 1)\n            )\n\n        # Handle display blocks\n        for block in request.display:\n            if isinstance(block, DiffDisplayBlock):\n                # File path or ellipsis\n                if block.path != last_diff_path:\n                    self._content_blocks.append(\n                        _ApprovalContentBlock(text=block.path, lines=1, style=\"bold\")\n                    )\n                    last_diff_path = block.path\n                else:\n                    self._content_blocks.append(\n                        _ApprovalContentBlock(text=\"⋮\", lines=1, style=\"dim\")\n                    )\n                # Diff content\n                diff_text = format_unified_diff(\n                    block.old_text,\n                    block.new_text,\n                    block.path,\n                    include_file_header=False,\n                ).rstrip(\"\\n\")\n                self._content_blocks.append(\n                    _ApprovalContentBlock(\n                        text=diff_text, lines=diff_text.count(\"\\n\") + 1, lexer=\"diff\"\n                    )\n                )\n            elif isinstance(block, ShellDisplayBlock):\n                text = block.command.rstrip(\"\\n\")\n                self._content_blocks.append(\n                    _ApprovalContentBlock(\n                        text=text, lines=text.count(\"\\n\") + 1, lexer=block.language\n                    )\n                )\n                last_diff_path = None\n            elif isinstance(block, BriefDisplayBlock) and block.text:\n                text = block.text.rstrip(\"\\n\")\n                self._content_blocks.append(\n                    _ApprovalContentBlock(text=text, lines=text.count(\"\\n\") + 1, style=\"grey50\")\n                )\n                last_diff_path = None\n\n        self._total_lines = sum(b.lines for b in self._content_blocks)\n        self.has_expandable_content = self._total_lines > MAX_PREVIEW_LINES\n\n    def render(self) -> RenderableType:\n        \"\"\"Render the approval menu as a panel.\"\"\"\n        content_lines: list[RenderableType] = [\n            Text.from_markup(\n                \"[yellow]⚠ \"\n                f\"{escape(self.request.sender)} is requesting approval to \"\n                f\"{escape(self.request.action)}:[/yellow]\"\n            )\n        ]\n        content_lines.append(Text(\"\"))\n\n        # Render content with line budget\n        remaining = MAX_PREVIEW_LINES\n        for block in self._content_blocks:\n            if remaining <= 0:\n                break\n            content_lines.append(self._render_block(block, remaining))\n            remaining -= min(block.lines, remaining)\n\n        if self.has_expandable_content:\n            content_lines.append(Text(\"... (truncated, ctrl-e to expand)\", style=\"dim italic\"))\n\n        lines: list[RenderableType] = []\n        if content_lines:\n            lines.append(Padding(Group(*content_lines), (0, 0, 0, 2)))\n\n        # Add menu options\n        if lines:\n            lines.append(Text(\"\"))\n        for i, (option_text, _) in enumerate(self.options):\n            if i == self.selected_index:\n                lines.append(Text(f\"→ {option_text}\", style=\"cyan\"))\n            else:\n                lines.append(Text(f\"  {option_text}\", style=\"grey50\"))\n\n        return Padding(Group(*lines), 1)\n\n    def _render_block(\n        self, block: _ApprovalContentBlock, max_lines: int | None = None\n    ) -> RenderableType:\n        \"\"\"Render a content block, optionally truncated.\"\"\"\n        text = block.text\n        if max_lines is not None and block.lines > max_lines:\n            # Truncate to max_lines\n            text = \"\\n\".join(text.split(\"\\n\")[:max_lines])\n\n        if block.lexer:\n            return KimiSyntax(text, block.lexer)\n        return Text(text, style=block.style)\n\n    def render_full(self) -> list[RenderableType]:\n        \"\"\"Render full content for pager (no truncation).\"\"\"\n        return [self._render_block(block) for block in self._content_blocks]\n\n    def move_up(self):\n        \"\"\"Move selection up.\"\"\"\n        self.selected_index = (self.selected_index - 1) % len(self.options)\n\n    def move_down(self):\n        \"\"\"Move selection down.\"\"\"\n        self.selected_index = (self.selected_index + 1) % len(self.options)\n\n    def get_selected_response(self) -> ApprovalResponse.Kind:\n        \"\"\"Get the approval response based on selected option.\"\"\"\n        return self.options[self.selected_index][1]\n\n\ndef _show_approval_in_pager(panel: _ApprovalRequestPanel) -> None:\n    \"\"\"Show the full approval request content in a pager.\"\"\"\n    with console.screen(), console.pager(styles=True):\n        # Header: matches the style in _ApprovalRequestPanel.render()\n        console.print(\n            Text.from_markup(\n                \"[yellow]⚠ \"\n                f\"{escape(panel.request.sender)} is requesting approval to \"\n                f\"{escape(panel.request.action)}:[/yellow]\"\n            )\n        )\n        console.print()\n\n        # Render full content (no truncation)\n        for renderable in panel.render_full():\n            console.print(renderable)\n\n\nclass _StatusBlock:\n    def __init__(self, initial: StatusUpdate) -> None:\n        self.text = Text(\"\", justify=\"right\")\n        self.update(initial)\n\n    def render(self) -> RenderableType:\n        return self.text\n\n    def update(self, status: StatusUpdate) -> None:\n        if status.context_usage is not None:\n            self.text.plain = f\"context: {status.context_usage:.1%}\"\n\n\n@asynccontextmanager\nasync def _keyboard_listener(\n    handler: Callable[[KeyboardListener, KeyEvent], Awaitable[None]],\n):\n    listener = KeyboardListener()\n    await listener.start()\n\n    async def _keyboard():\n        while True:\n            event = await listener.get()\n            await handler(listener, event)\n\n    task = asyncio.create_task(_keyboard())\n    try:\n        yield\n    finally:\n        task.cancel()\n        with suppress(asyncio.CancelledError):\n            await task\n        await listener.stop()\n\n\nclass _LiveView:\n    def __init__(self, initial_status: StatusUpdate, cancel_event: asyncio.Event | None = None):\n        self._cancel_event = cancel_event\n\n        self._mooning_spinner: Spinner | None = None\n        self._compacting_spinner: Spinner | None = None\n\n        self._current_content_block: _ContentBlock | None = None\n        self._tool_call_blocks: dict[str, _ToolCallBlock] = {}\n        self._last_tool_call_block: _ToolCallBlock | None = None\n        self._approval_request_queue = deque[ApprovalRequest]()\n        \"\"\"\n        It is possible that multiple subagents request approvals at the same time,\n        in which case we will have to queue them up and show them one by one.\n        \"\"\"\n        self._current_approval_request_panel: _ApprovalRequestPanel | None = None\n        self._reject_all_following = False\n        self._status_block = _StatusBlock(initial_status)\n\n        self._need_recompose = False\n\n    def _reset_live_shape(self, live: Live) -> None:\n        # Rich doesn't expose a public API to clear Live's cached render height.\n        # After leaving the pager, stale height causes cursor restores to jump,\n        # so we reset the private _shape to re-anchor the next refresh.\n        live._live_render._shape = None  # type: ignore[reportPrivateUsage]\n\n    async def visualize_loop(self, wire: WireUISide):\n        with Live(\n            self.compose(),\n            console=console,\n            refresh_per_second=10,\n            transient=True,\n            vertical_overflow=\"visible\",\n        ) as live:\n\n            async def keyboard_handler(listener: KeyboardListener, event: KeyEvent) -> None:\n                # Handle Ctrl+E specially - pause Live while the pager is active\n                if event == KeyEvent.CTRL_E:\n                    if (\n                        self._current_approval_request_panel\n                        and self._current_approval_request_panel.has_expandable_content\n                    ):\n                        await listener.pause()\n                        live.stop()\n                        try:\n                            _show_approval_in_pager(self._current_approval_request_panel)\n                        finally:\n                            # Reset live render shape so the next refresh re-anchors cleanly.\n                            self._reset_live_shape(live)\n                            live.start()\n                            live.update(self.compose(), refresh=True)\n                            await listener.resume()\n                    return\n\n                self.dispatch_keyboard_event(event)\n                if self._need_recompose:\n                    live.update(self.compose(), refresh=True)\n                    self._need_recompose = False\n\n            async with _keyboard_listener(keyboard_handler):\n                while True:\n                    try:\n                        msg = await wire.receive()\n                    except QueueShutDown:\n                        self.cleanup(is_interrupt=False)\n                        live.update(self.compose(), refresh=True)\n                        break\n\n                    if isinstance(msg, StepInterrupted):\n                        self.cleanup(is_interrupt=True)\n                        live.update(self.compose(), refresh=True)\n                        break\n\n                    self.dispatch_wire_message(msg)\n                    if self._need_recompose:\n                        live.update(self.compose(), refresh=True)\n                        self._need_recompose = False\n\n    def refresh_soon(self) -> None:\n        self._need_recompose = True\n\n    def compose(self) -> RenderableType:\n        \"\"\"Compose the live view display content.\"\"\"\n        blocks: list[RenderableType] = []\n        if self._mooning_spinner is not None:\n            blocks.append(self._mooning_spinner)\n        elif self._compacting_spinner is not None:\n            blocks.append(self._compacting_spinner)\n        else:\n            if self._current_content_block is not None:\n                blocks.append(self._current_content_block.compose())\n            for tool_call in self._tool_call_blocks.values():\n                blocks.append(tool_call.compose())\n        if self._current_approval_request_panel:\n            blocks.append(self._current_approval_request_panel.render())\n        blocks.append(self._status_block.render())\n        return Group(*blocks)\n\n    def dispatch_wire_message(self, msg: WireMessage) -> None:\n        \"\"\"Dispatch the Wire message to UI components.\"\"\"\n        assert not isinstance(msg, StepInterrupted)  # handled in visualize_loop\n\n        if isinstance(msg, StepBegin):\n            self.cleanup(is_interrupt=False)\n            self._mooning_spinner = Spinner(\"moon\", \"\")\n            self.refresh_soon()\n            return\n\n        if self._mooning_spinner is not None:\n            # any message other than StepBegin should end the mooning state\n            self._mooning_spinner = None\n            self.refresh_soon()\n\n        match msg:\n            case TurnBegin():\n                self.flush_content()\n                console.print(\n                    Panel(\n                        Text(message_stringify(Message(role=\"user\", content=msg.user_input))),\n                        padding=(0, 1),\n                    )\n                )\n            case TurnEnd():\n                pass\n            case CompactionBegin():\n                self._compacting_spinner = Spinner(\"balloon\", \"Compacting...\")\n                self.refresh_soon()\n            case CompactionEnd():\n                self._compacting_spinner = None\n                self.refresh_soon()\n            case StatusUpdate():\n                self._status_block.update(msg)\n            case ContentPart():\n                self.append_content(msg)\n            case ToolCall():\n                self.append_tool_call(msg)\n            case ToolCallPart():\n                self.append_tool_call_part(msg)\n            case ToolResult():\n                self.append_tool_result(msg)\n            case ApprovalResponse():\n                # we don't need to handle this because the request is resolved on UI\n                pass\n            case SubagentEvent():\n                self.handle_subagent_event(msg)\n            case ApprovalRequest():\n                self.request_approval(msg)\n            case ToolCallRequest():\n                logger.warning(\"Unexpected ToolCallRequest in shell UI: {msg}\", msg=msg)\n\n    def dispatch_keyboard_event(self, event: KeyEvent) -> None:\n        # handle ESC key to cancel the run\n        if event == KeyEvent.ESCAPE and self._cancel_event is not None:\n            self._cancel_event.set()\n            return\n\n        if not self._current_approval_request_panel:\n            # just ignore any keyboard event when there's no approval request\n            return\n\n        match event:\n            case KeyEvent.UP:\n                self._current_approval_request_panel.move_up()\n                self.refresh_soon()\n            case KeyEvent.DOWN:\n                self._current_approval_request_panel.move_down()\n                self.refresh_soon()\n            case KeyEvent.ENTER:\n                resp = self._current_approval_request_panel.get_selected_response()\n                self._current_approval_request_panel.request.resolve(resp)\n                if resp == \"approve_for_session\":\n                    to_remove_from_queue: list[ApprovalRequest] = []\n                    for request in self._approval_request_queue:\n                        # approve all queued requests with the same action\n                        if request.action == self._current_approval_request_panel.request.action:\n                            request.resolve(\"approve_for_session\")\n                            to_remove_from_queue.append(request)\n                    for request in to_remove_from_queue:\n                        self._approval_request_queue.remove(request)\n                elif resp == \"reject\":\n                    # one rejection should stop the step immediately\n                    while self._approval_request_queue:\n                        self._approval_request_queue.popleft().resolve(\"reject\")\n                    self._reject_all_following = True\n                self.show_next_approval_request()\n            case _:\n                # just ignore any other keyboard event\n                return\n\n    def cleanup(self, is_interrupt: bool) -> None:\n        \"\"\"Cleanup the live view on step end or interruption.\"\"\"\n        self.flush_content()\n\n        for block in self._tool_call_blocks.values():\n            if not block.finished:\n                # this should not happen, but just in case\n                block.finish(\n                    ToolError(message=\"\", brief=\"Interrupted\")\n                    if is_interrupt\n                    else ToolOk(output=\"\")\n                )\n        self._last_tool_call_block = None\n        self.flush_finished_tool_calls()\n\n        while self._approval_request_queue:\n            # should not happen, but just in case\n            self._approval_request_queue.popleft().resolve(\"reject\")\n        self._current_approval_request_panel = None\n        self._reject_all_following = False\n\n    def flush_content(self) -> None:\n        \"\"\"Flush the current content block.\"\"\"\n        if self._current_content_block is not None:\n            console.print(self._current_content_block.compose_final())\n            self._current_content_block = None\n            self.refresh_soon()\n\n    def flush_finished_tool_calls(self) -> None:\n        \"\"\"Flush all leading finished tool call blocks.\"\"\"\n        tool_call_ids = list(self._tool_call_blocks.keys())\n        for tool_call_id in tool_call_ids:\n            block = self._tool_call_blocks[tool_call_id]\n            if not block.finished:\n                break\n\n            self._tool_call_blocks.pop(tool_call_id)\n            console.print(block.compose())\n            if self._last_tool_call_block == block:\n                self._last_tool_call_block = None\n            self.refresh_soon()\n\n    def append_content(self, part: ContentPart) -> None:\n        match part:\n            case ThinkPart(think=text) | TextPart(text=text):\n                if not text:\n                    return\n                is_think = isinstance(part, ThinkPart)\n                if self._current_content_block is None:\n                    self._current_content_block = _ContentBlock(is_think)\n                    self.refresh_soon()\n                elif self._current_content_block.is_think != is_think:\n                    self.flush_content()\n                    self._current_content_block = _ContentBlock(is_think)\n                    self.refresh_soon()\n                self._current_content_block.append(text)\n            case _:\n                # TODO: support more content part types\n                pass\n\n    def append_tool_call(self, tool_call: ToolCall) -> None:\n        self.flush_content()\n        self._tool_call_blocks[tool_call.id] = _ToolCallBlock(tool_call)\n        self._last_tool_call_block = self._tool_call_blocks[tool_call.id]\n        self.refresh_soon()\n\n    def append_tool_call_part(self, part: ToolCallPart) -> None:\n        if not part.arguments_part:\n            return\n        if self._last_tool_call_block is None:\n            return\n        self._last_tool_call_block.append_args_part(part.arguments_part)\n        self.refresh_soon()\n\n    def append_tool_result(self, result: ToolResult) -> None:\n        if block := self._tool_call_blocks.get(result.tool_call_id):\n            block.finish(result.return_value)\n            self.flush_finished_tool_calls()\n            self.refresh_soon()\n\n    def request_approval(self, request: ApprovalRequest) -> None:\n        # If we're rejecting all following requests, reject immediately\n        if self._reject_all_following:\n            request.resolve(\"reject\")\n            return\n\n        self._approval_request_queue.append(request)\n\n        if self._current_approval_request_panel is None:\n            console.bell()\n            self.show_next_approval_request()\n\n    def show_next_approval_request(self) -> None:\n        \"\"\"\n        Show the next approval request from the queue.\n        If there are no pending requests, clear the current approval panel.\n        \"\"\"\n        if not self._approval_request_queue:\n            if self._current_approval_request_panel is not None:\n                self._current_approval_request_panel = None\n                self.refresh_soon()\n            return\n\n        while self._approval_request_queue:\n            request = self._approval_request_queue.popleft()\n            if request.resolved:\n                # skip resolved requests\n                continue\n            self._current_approval_request_panel = _ApprovalRequestPanel(request)\n            self.refresh_soon()\n            break\n\n    def handle_subagent_event(self, event: SubagentEvent) -> None:\n        block = self._tool_call_blocks.get(event.task_tool_call_id)\n        if block is None:\n            return\n\n        match event.event:\n            case ToolCall() as tool_call:\n                block.append_sub_tool_call(tool_call)\n            case ToolCallPart() as tool_call_part:\n                block.append_sub_tool_call_part(tool_call_part)\n            case ToolResult() as tool_result:\n                block.finish_sub_tool_call(tool_result)\n                self.refresh_soon()\n            case _:\n                # ignore other events for now\n                # TODO: may need to handle multi-level nested subagents\n                pass\n","structuredPatch":[{"oldStart":205,"oldLines":13,"newStart":205,"newLines":6,"lines":["             self._build_headline_text(),","         ]"," ","-        # Show full URL hint when URL was truncated","-        if self._full_url and self._full_url != self._argument:","-            url_hint = Text()","-            url_hint.append(\"  ↳ \", style=\"grey50\")","-            url_hint.append(self._full_url, style=Style(color=\"grey50\", link=self._full_url))","-            lines.append(url_hint)","-","         if self._n_finished_subagent_tool_calls > MAX_SUBAGENT_TOOL_CALLS_TO_SHOW:","             n_hidden = self._n_finished_subagent_tool_calls - MAX_SUBAGENT_TOOL_CALLS_TO_SHOW","             lines.append("]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"f2324b0e-a310-407c-8b4e-b3f08207b3b8"}
{"parentUuid":"f3c0f591-6756-4adc-b281-ba7e6d7c19b4","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"system","subtype":"microcompact_boundary","content":"Context microcompacted","isMeta":false,"timestamp":"2026-02-25T08:15:19.113Z","uuid":"58782d7e-36a8-466e-83e2-43f41a5b9e42","level":"info","microcompactMetadata":{"trigger":"auto","preTokens":12486,"tokensSaved":2000,"compactedToolIds":[],"clearedAttachmentUUIDs":[]}}
{"parentUuid":"58782d7e-36a8-466e-83e2-43f41a5b9e42","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_011nuBxUb477ufR6Ss1YFVK3","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016NZLr89nhTJhS2wbNDBT4t","name":"Edit","input":{"replace_all":false,"file_path":"/Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/ui/shell/visualize.py","old_string":"            sub_lines: list[RenderableType] = [sub_headline]\n            if sub_full_url and sub_full_url != argument:\n                sub_url_hint = Text()\n                sub_url_hint.append(\"  ↳ \", style=\"grey50\")\n                sub_url_hint.append(\n                    sub_full_url,\n                    style=Style(color=\"grey50\", link=sub_full_url),\n                )\n                sub_lines.append(sub_url_hint)\n\n            lines.append(\n                BulletColumns(\n                    Group(*sub_lines) if len(sub_lines) > 1 else sub_headline,\n                    bullet_style=\"green\" if not sub_result.is_error else \"red\",\n                )\n            )","new_string":"            lines.append(\n                BulletColumns(\n                    sub_headline,\n                    bullet_style=\"green\" if not sub_result.is_error else \"red\",\n                )\n            )"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":526,"cache_read_input_tokens":43545,"output_tokens":375,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":526},"inference_geo":"","iterations":[],"speed":"standard"}},"type":"assistant","uuid":"c4b66b7a-cc6a-4753-8b3c-c6d72b16368c","timestamp":"2026-02-25T08:15:25.883Z"}
{"parentUuid":"c4b66b7a-cc6a-4753-8b3c-c6d72b16368c","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_016NZLr89nhTJhS2wbNDBT4t","toolUseID":"toolu_016NZLr89nhTJhS2wbNDBT4t","timestamp":"2026-02-25T08:15:25.933Z","uuid":"fe22623b-719a-4809-b065-33c01a6bf2a2"}
{"parentUuid":"c4b66b7a-cc6a-4753-8b3c-c6d72b16368c","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016NZLr89nhTJhS2wbNDBT4t","type":"tool_result","content":"The file /Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/ui/shell/visualize.py has been updated successfully."}]},"uuid":"8a683a30-bf90-4144-8300-fd9f89661944","timestamp":"2026-02-25T08:15:25.932Z","toolUseResult":{"filePath":"/Users/moonshot/dev/working/kimi/kimi-cli/src/kimi_cli/ui/shell/visualize.py","oldString":"            sub_lines: list[RenderableType] = [sub_headline]\n            if sub_full_url and sub_full_url != argument:\n                sub_url_hint = Text()\n                sub_url_hint.append(\"  ↳ \", style=\"grey50\")\n                sub_url_hint.append(\n                    sub_full_url,\n                    style=Style(color=\"grey50\", link=sub_full_url),\n                )\n                sub_lines.append(sub_url_hint)\n\n            lines.append(\n                BulletColumns(\n                    Group(*sub_lines) if len(sub_lines) > 1 else sub_headline,\n                    bullet_style=\"green\" if not sub_result.is_error else \"red\",\n                )\n            )","newString":"            lines.append(\n                BulletColumns(\n                    sub_headline,\n                    bullet_style=\"green\" if not sub_result.is_error else \"red\",\n                )\n            )","originalFile":"from __future__ import annotations\n\nimport asyncio\nimport json\nfrom collections import deque\nfrom collections.abc import Awaitable, Callable\nfrom contextlib import asynccontextmanager, suppress\nfrom typing import NamedTuple\n\nimport streamingjson  # type: ignore[reportMissingTypeStubs]\nfrom kosong.message import Message\nfrom kosong.tooling import ToolError, ToolOk\nfrom rich.console import Group, RenderableType\nfrom rich.live import Live\nfrom rich.markup import escape\nfrom rich.padding import Padding\nfrom rich.panel import Panel\nfrom rich.spinner import Spinner\nfrom rich.style import Style\nfrom rich.text import Text\n\nfrom kimi_cli.tools import extract_key_argument\nfrom kimi_cli.ui.shell.console import console\nfrom kimi_cli.ui.shell.keyboard import KeyboardListener, KeyEvent\nfrom kimi_cli.utils.aioqueue import QueueShutDown\nfrom kimi_cli.utils.diff import format_unified_diff\nfrom kimi_cli.utils.logging import logger\nfrom kimi_cli.utils.message import message_stringify\nfrom kimi_cli.utils.rich.columns import BulletColumns\nfrom kimi_cli.utils.rich.markdown import Markdown\nfrom kimi_cli.utils.rich.syntax import KimiSyntax\nfrom kimi_cli.wire import WireUISide\nfrom kimi_cli.wire.types import (\n    ApprovalRequest,\n    ApprovalResponse,\n    BriefDisplayBlock,\n    CompactionBegin,\n    CompactionEnd,\n    ContentPart,\n    DiffDisplayBlock,\n    ShellDisplayBlock,\n    StatusUpdate,\n    StepBegin,\n    StepInterrupted,\n    SubagentEvent,\n    TextPart,\n    ThinkPart,\n    TodoDisplayBlock,\n    ToolCall,\n    ToolCallPart,\n    ToolCallRequest,\n    ToolResult,\n    ToolReturnValue,\n    TurnBegin,\n    TurnEnd,\n    WireMessage,\n)\n\nMAX_SUBAGENT_TOOL_CALLS_TO_SHOW = 4\n\n# Truncation limits for approval request display\nMAX_PREVIEW_LINES = 4\n\n\nasync def visualize(\n    wire: WireUISide,\n    *,\n    initial_status: StatusUpdate,\n    cancel_event: asyncio.Event | None = None,\n):\n    \"\"\"\n    A loop to consume agent events and visualize the agent behavior.\n\n    Args:\n        wire: Communication channel with the agent\n        initial_status: Initial status snapshot\n        cancel_event: Event that can be set (e.g., by ESC key) to cancel the run\n    \"\"\"\n    view = _LiveView(initial_status, cancel_event)\n    await view.visualize_loop(wire)\n\n\nclass _ContentBlock:\n    def __init__(self, is_think: bool):\n        self.is_think = is_think\n        self._spinner = Spinner(\"dots\", \"Thinking...\" if is_think else \"Composing...\")\n        self.raw_text = \"\"\n\n    def compose(self) -> RenderableType:\n        return self._spinner\n\n    def compose_final(self) -> RenderableType:\n        return BulletColumns(\n            Markdown(\n                self.raw_text,\n                style=\"grey50 italic\" if self.is_think else \"\",\n            ),\n            bullet_style=\"grey50\" if self.is_think else None,\n        )\n\n    def append(self, content: str) -> None:\n        self.raw_text += content\n\n\nclass _ToolCallBlock:\n    class FinishedSubCall(NamedTuple):\n        call: ToolCall\n        result: ToolReturnValue\n\n    @staticmethod\n    def _extract_full_url(\n        json_content: str | streamingjson.Lexer, tool_name: str\n    ) -> str | None:\n        if tool_name != \"FetchURL\":\n            return None\n        json_str = (\n            json_content.complete_json()\n            if isinstance(json_content, streamingjson.Lexer)\n            else json_content\n        )\n        try:\n            args = json.loads(json_str)\n        except (json.JSONDecodeError, ValueError):\n            return None\n        if isinstance(args, dict) and args.get(\"url\"):\n            return str(args[\"url\"])\n        return None\n\n    def __init__(self, tool_call: ToolCall):\n        self._tool_name = tool_call.function.name\n        self._lexer = streamingjson.Lexer()\n        if tool_call.function.arguments is not None:\n            self._lexer.append_string(tool_call.function.arguments)\n\n        self._argument = extract_key_argument(self._lexer, self._tool_name)\n        self._full_url = self._extract_full_url(self._lexer, self._tool_name)\n        self._result: ToolReturnValue | None = None\n\n        self._ongoing_subagent_tool_calls: dict[str, ToolCall] = {}\n        self._last_subagent_tool_call: ToolCall | None = None\n        self._n_finished_subagent_tool_calls = 0\n        self._finished_subagent_tool_calls = deque[_ToolCallBlock.FinishedSubCall](\n            maxlen=MAX_SUBAGENT_TOOL_CALLS_TO_SHOW\n        )\n\n        self._spinning_dots = Spinner(\"dots\", text=\"\")\n        self._renderable: RenderableType = self._compose()\n\n    def compose(self) -> RenderableType:\n        return self._renderable\n\n    @property\n    def finished(self) -> bool:\n        return self._result is not None\n\n    def append_args_part(self, args_part: str):\n        if self.finished:\n            return\n        self._lexer.append_string(args_part)\n        # TODO: maybe don't extract detail if it's already stable\n        argument = extract_key_argument(self._lexer, self._tool_name)\n        if argument and argument != self._argument:\n            self._argument = argument\n            self._full_url = self._extract_full_url(self._lexer, self._tool_name)\n            self._renderable = BulletColumns(\n                self._build_headline_text(),\n                bullet=self._spinning_dots,\n            )\n\n    def finish(self, result: ToolReturnValue):\n        self._result = result\n        self._renderable = self._compose()\n\n    def append_sub_tool_call(self, tool_call: ToolCall):\n        self._ongoing_subagent_tool_calls[tool_call.id] = tool_call\n        self._last_subagent_tool_call = tool_call\n\n    def append_sub_tool_call_part(self, tool_call_part: ToolCallPart):\n        if self._last_subagent_tool_call is None:\n            return\n        if not tool_call_part.arguments_part:\n            return\n        if self._last_subagent_tool_call.function.arguments is None:\n            self._last_subagent_tool_call.function.arguments = tool_call_part.arguments_part\n        else:\n            self._last_subagent_tool_call.function.arguments += tool_call_part.arguments_part\n\n    def finish_sub_tool_call(self, tool_result: ToolResult):\n        self._last_subagent_tool_call = None\n        sub_tool_call = self._ongoing_subagent_tool_calls.pop(tool_result.tool_call_id, None)\n        if sub_tool_call is None:\n            return\n\n        self._finished_subagent_tool_calls.append(\n            _ToolCallBlock.FinishedSubCall(\n                call=sub_tool_call,\n                result=tool_result.return_value,\n            )\n        )\n        self._n_finished_subagent_tool_calls += 1\n        self._renderable = self._compose()\n\n    def _compose(self) -> RenderableType:\n        lines: list[RenderableType] = [\n            self._build_headline_text(),\n        ]\n\n        if self._n_finished_subagent_tool_calls > MAX_SUBAGENT_TOOL_CALLS_TO_SHOW:\n            n_hidden = self._n_finished_subagent_tool_calls - MAX_SUBAGENT_TOOL_CALLS_TO_SHOW\n            lines.append(\n                BulletColumns(\n                    Text(\n                        f\"{n_hidden} more tool call{'s' if n_hidden > 1 else ''} ...\",\n                        style=\"grey50 italic\",\n                    ),\n                    bullet_style=\"grey50\",\n                )\n            )\n        for sub_call, sub_result in self._finished_subagent_tool_calls:\n            sub_args = sub_call.function.arguments or \"\"\n            argument = extract_key_argument(sub_args, sub_call.function.name)\n            sub_full_url = self._extract_full_url(sub_args, sub_call.function.name)\n\n            sub_headline = Text()\n            sub_headline.append(\"Used \")\n            sub_headline.append(sub_call.function.name, style=\"blue\")\n            if argument:\n                sub_headline.append(\" (\", style=\"grey50\")\n                sub_arg_style = (\n                    Style(color=\"grey50\", link=sub_full_url)\n                    if sub_full_url\n                    else \"grey50\"\n                )\n                sub_headline.append(argument, style=sub_arg_style)\n                sub_headline.append(\")\", style=\"grey50\")\n\n            sub_lines: list[RenderableType] = [sub_headline]\n            if sub_full_url and sub_full_url != argument:\n                sub_url_hint = Text()\n                sub_url_hint.append(\"  ↳ \", style=\"grey50\")\n                sub_url_hint.append(\n                    sub_full_url,\n                    style=Style(color=\"grey50\", link=sub_full_url),\n                )\n                sub_lines.append(sub_url_hint)\n\n            lines.append(\n                BulletColumns(\n                    Group(*sub_lines) if len(sub_lines) > 1 else sub_headline,\n                    bullet_style=\"green\" if not sub_result.is_error else \"red\",\n                )\n            )\n\n        if self._result is not None:\n            for block in self._result.display:\n                if isinstance(block, BriefDisplayBlock):\n                    style = \"grey50\" if not self._result.is_error else \"red\"\n                    if block.text:\n                        lines.append(Markdown(block.text, style=style))\n                elif isinstance(block, TodoDisplayBlock):\n                    markdown = self._render_todo_markdown(block)\n                    if markdown:\n                        lines.append(Markdown(markdown, style=\"grey50\"))\n\n        if self.finished:\n            assert self._result is not None\n            return BulletColumns(\n                Group(*lines),\n                bullet_style=\"green\" if not self._result.is_error else \"red\",\n            )\n        else:\n            return BulletColumns(\n                Group(*lines),\n                bullet=self._spinning_dots,\n            )\n\n    def _build_headline_text(self) -> Text:\n        text = Text()\n        text.append(\"Used \" if self.finished else \"Using \")\n        text.append(self._tool_name, style=\"blue\")\n        if self._argument:\n            text.append(\" (\", style=\"grey50\")\n            arg_style = (\n                Style(color=\"grey50\", link=self._full_url)\n                if self._full_url\n                else \"grey50\"\n            )\n            text.append(self._argument, style=arg_style)\n            text.append(\")\", style=\"grey50\")\n        return text\n\n    def _render_todo_markdown(self, block: TodoDisplayBlock) -> str:\n        lines: list[str] = []\n        for todo in block.items:\n            normalized = todo.status.replace(\"_\", \" \").lower()\n            match normalized:\n                case \"pending\":\n                    lines.append(f\"- {todo.title}\")\n                case \"in progress\":\n                    lines.append(f\"- {todo.title} ←\")\n                case \"done\":\n                    lines.append(f\"- ~~{todo.title}~~\")\n                case _:\n                    lines.append(f\"- {todo.title}\")\n        return \"\\n\".join(lines)\n\n\nclass _ApprovalContentBlock(NamedTuple):\n    \"\"\"A pre-rendered content block for approval request with line count.\"\"\"\n\n    text: str\n    lines: int\n    style: str = \"\"\n    lexer: str = \"\"\n\n\nclass _ApprovalRequestPanel:\n    def __init__(self, request: ApprovalRequest):\n        self.request = request\n        self.options: list[tuple[str, ApprovalResponse.Kind]] = [\n            (\"Approve once\", \"approve\"),\n            (\"Approve for this session\", \"approve_for_session\"),\n            (\"Reject, tell Kimi what to do instead\", \"reject\"),\n        ]\n        self.selected_index = 0\n\n        # Pre-render all content blocks with line counts\n        self._content_blocks: list[_ApprovalContentBlock] = []\n        last_diff_path: str | None = None\n\n        # Handle description (only if no display blocks)\n        if request.description and not request.display:\n            text = request.description.rstrip(\"\\n\")\n            self._content_blocks.append(\n                _ApprovalContentBlock(text=text, lines=text.count(\"\\n\") + 1)\n            )\n\n        # Handle display blocks\n        for block in request.display:\n            if isinstance(block, DiffDisplayBlock):\n                # File path or ellipsis\n                if block.path != last_diff_path:\n                    self._content_blocks.append(\n                        _ApprovalContentBlock(text=block.path, lines=1, style=\"bold\")\n                    )\n                    last_diff_path = block.path\n                else:\n                    self._content_blocks.append(\n                        _ApprovalContentBlock(text=\"⋮\", lines=1, style=\"dim\")\n                    )\n                # Diff content\n                diff_text = format_unified_diff(\n                    block.old_text,\n                    block.new_text,\n                    block.path,\n                    include_file_header=False,\n                ).rstrip(\"\\n\")\n                self._content_blocks.append(\n                    _ApprovalContentBlock(\n                        text=diff_text, lines=diff_text.count(\"\\n\") + 1, lexer=\"diff\"\n                    )\n                )\n            elif isinstance(block, ShellDisplayBlock):\n                text = block.command.rstrip(\"\\n\")\n                self._content_blocks.append(\n                    _ApprovalContentBlock(\n                        text=text, lines=text.count(\"\\n\") + 1, lexer=block.language\n                    )\n                )\n                last_diff_path = None\n            elif isinstance(block, BriefDisplayBlock) and block.text:\n                text = block.text.rstrip(\"\\n\")\n                self._content_blocks.append(\n                    _ApprovalContentBlock(text=text, lines=text.count(\"\\n\") + 1, style=\"grey50\")\n                )\n                last_diff_path = None\n\n        self._total_lines = sum(b.lines for b in self._content_blocks)\n        self.has_expandable_content = self._total_lines > MAX_PREVIEW_LINES\n\n    def render(self) -> RenderableType:\n        \"\"\"Render the approval menu as a panel.\"\"\"\n        content_lines: list[RenderableType] = [\n            Text.from_markup(\n                \"[yellow]⚠ \"\n                f\"{escape(self.request.sender)} is requesting approval to \"\n                f\"{escape(self.request.action)}:[/yellow]\"\n            )\n        ]\n        content_lines.append(Text(\"\"))\n\n        # Render content with line budget\n        remaining = MAX_PREVIEW_LINES\n        for block in self._content_blocks:\n            if remaining <= 0:\n                break\n            content_lines.append(self._render_block(block, remaining))\n            remaining -= min(block.lines, remaining)\n\n        if self.has_expandable_content:\n            content_lines.append(Text(\"... (truncated, ctrl-e to expand)\", style=\"dim italic\"))\n\n        lines: list[RenderableType] = []\n        if content_lines:\n            lines.append(Padding(Group(*content_lines), (0, 0, 0, 2)))\n\n        # Add menu options\n        if lines:\n            lines.append(Text(\"\"))\n        for i, (option_text, _) in enumerate(self.options):\n            if i == self.selected_index:\n                lines.append(Text(f\"→ {option_text}\", style=\"cyan\"))\n            else:\n                lines.append(Text(f\"  {option_text}\", style=\"grey50\"))\n\n        return Padding(Group(*lines), 1)\n\n    def _render_block(\n        self, block: _ApprovalContentBlock, max_lines: int | None = None\n    ) -> RenderableType:\n        \"\"\"Render a content block, optionally truncated.\"\"\"\n        text = block.text\n        if max_lines is not None and block.lines > max_lines:\n            # Truncate to max_lines\n            text = \"\\n\".join(text.split(\"\\n\")[:max_lines])\n\n        if block.lexer:\n            return KimiSyntax(text, block.lexer)\n        return Text(text, style=block.style)\n\n    def render_full(self) -> list[RenderableType]:\n        \"\"\"Render full content for pager (no truncation).\"\"\"\n        return [self._render_block(block) for block in self._content_blocks]\n\n    def move_up(self):\n        \"\"\"Move selection up.\"\"\"\n        self.selected_index = (self.selected_index - 1) % len(self.options)\n\n    def move_down(self):\n        \"\"\"Move selection down.\"\"\"\n        self.selected_index = (self.selected_index + 1) % len(self.options)\n\n    def get_selected_response(self) -> ApprovalResponse.Kind:\n        \"\"\"Get the approval response based on selected option.\"\"\"\n        return self.options[self.selected_index][1]\n\n\ndef _show_approval_in_pager(panel: _ApprovalRequestPanel) -> None:\n    \"\"\"Show the full approval request content in a pager.\"\"\"\n    with console.screen(), console.pager(styles=True):\n        # Header: matches the style in _ApprovalRequestPanel.render()\n        console.print(\n            Text.from_markup(\n                \"[yellow]⚠ \"\n                f\"{escape(panel.request.sender)} is requesting approval to \"\n                f\"{escape(panel.request.action)}:[/yellow]\"\n            )\n        )\n        console.print()\n\n        # Render full content (no truncation)\n        for renderable in panel.render_full():\n            console.print(renderable)\n\n\nclass _StatusBlock:\n    def __init__(self, initial: StatusUpdate) -> None:\n        self.text = Text(\"\", justify=\"right\")\n        self.update(initial)\n\n    def render(self) -> RenderableType:\n        return self.text\n\n    def update(self, status: StatusUpdate) -> None:\n        if status.context_usage is not None:\n            self.text.plain = f\"context: {status.context_usage:.1%}\"\n\n\n@asynccontextmanager\nasync def _keyboard_listener(\n    handler: Callable[[KeyboardListener, KeyEvent], Awaitable[None]],\n):\n    listener = KeyboardListener()\n    await listener.start()\n\n    async def _keyboard():\n        while True:\n            event = await listener.get()\n            await handler(listener, event)\n\n    task = asyncio.create_task(_keyboard())\n    try:\n        yield\n    finally:\n        task.cancel()\n        with suppress(asyncio.CancelledError):\n            await task\n        await listener.stop()\n\n\nclass _LiveView:\n    def __init__(self, initial_status: StatusUpdate, cancel_event: asyncio.Event | None = None):\n        self._cancel_event = cancel_event\n\n        self._mooning_spinner: Spinner | None = None\n        self._compacting_spinner: Spinner | None = None\n\n        self._current_content_block: _ContentBlock | None = None\n        self._tool_call_blocks: dict[str, _ToolCallBlock] = {}\n        self._last_tool_call_block: _ToolCallBlock | None = None\n        self._approval_request_queue = deque[ApprovalRequest]()\n        \"\"\"\n        It is possible that multiple subagents request approvals at the same time,\n        in which case we will have to queue them up and show them one by one.\n        \"\"\"\n        self._current_approval_request_panel: _ApprovalRequestPanel | None = None\n        self._reject_all_following = False\n        self._status_block = _StatusBlock(initial_status)\n\n        self._need_recompose = False\n\n    def _reset_live_shape(self, live: Live) -> None:\n        # Rich doesn't expose a public API to clear Live's cached render height.\n        # After leaving the pager, stale height causes cursor restores to jump,\n        # so we reset the private _shape to re-anchor the next refresh.\n        live._live_render._shape = None  # type: ignore[reportPrivateUsage]\n\n    async def visualize_loop(self, wire: WireUISide):\n        with Live(\n            self.compose(),\n            console=console,\n            refresh_per_second=10,\n            transient=True,\n            vertical_overflow=\"visible\",\n        ) as live:\n\n            async def keyboard_handler(listener: KeyboardListener, event: KeyEvent) -> None:\n                # Handle Ctrl+E specially - pause Live while the pager is active\n                if event == KeyEvent.CTRL_E:\n                    if (\n                        self._current_approval_request_panel\n                        and self._current_approval_request_panel.has_expandable_content\n                    ):\n                        await listener.pause()\n                        live.stop()\n                        try:\n                            _show_approval_in_pager(self._current_approval_request_panel)\n                        finally:\n                            # Reset live render shape so the next refresh re-anchors cleanly.\n                            self._reset_live_shape(live)\n                            live.start()\n                            live.update(self.compose(), refresh=True)\n                            await listener.resume()\n                    return\n\n                self.dispatch_keyboard_event(event)\n                if self._need_recompose:\n                    live.update(self.compose(), refresh=True)\n                    self._need_recompose = False\n\n            async with _keyboard_listener(keyboard_handler):\n                while True:\n                    try:\n                        msg = await wire.receive()\n                    except QueueShutDown:\n                        self.cleanup(is_interrupt=False)\n                        live.update(self.compose(), refresh=True)\n                        break\n\n                    if isinstance(msg, StepInterrupted):\n                        self.cleanup(is_interrupt=True)\n                        live.update(self.compose(), refresh=True)\n                        break\n\n                    self.dispatch_wire_message(msg)\n                    if self._need_recompose:\n                        live.update(self.compose(), refresh=True)\n                        self._need_recompose = False\n\n    def refresh_soon(self) -> None:\n        self._need_recompose = True\n\n    def compose(self) -> RenderableType:\n        \"\"\"Compose the live view display content.\"\"\"\n        blocks: list[RenderableType] = []\n        if self._mooning_spinner is not None:\n            blocks.append(self._mooning_spinner)\n        elif self._compacting_spinner is not None:\n            blocks.append(self._compacting_spinner)\n        else:\n            if self._current_content_block is not None:\n                blocks.append(self._current_content_block.compose())\n            for tool_call in self._tool_call_blocks.values():\n                blocks.append(tool_call.compose())\n        if self._current_approval_request_panel:\n            blocks.append(self._current_approval_request_panel.render())\n        blocks.append(self._status_block.render())\n        return Group(*blocks)\n\n    def dispatch_wire_message(self, msg: WireMessage) -> None:\n        \"\"\"Dispatch the Wire message to UI components.\"\"\"\n        assert not isinstance(msg, StepInterrupted)  # handled in visualize_loop\n\n        if isinstance(msg, StepBegin):\n            self.cleanup(is_interrupt=False)\n            self._mooning_spinner = Spinner(\"moon\", \"\")\n            self.refresh_soon()\n            return\n\n        if self._mooning_spinner is not None:\n            # any message other than StepBegin should end the mooning state\n            self._mooning_spinner = None\n            self.refresh_soon()\n\n        match msg:\n            case TurnBegin():\n                self.flush_content()\n                console.print(\n                    Panel(\n                        Text(message_stringify(Message(role=\"user\", content=msg.user_input))),\n                        padding=(0, 1),\n                    )\n                )\n            case TurnEnd():\n                pass\n            case CompactionBegin():\n                self._compacting_spinner = Spinner(\"balloon\", \"Compacting...\")\n                self.refresh_soon()\n            case CompactionEnd():\n                self._compacting_spinner = None\n                self.refresh_soon()\n            case StatusUpdate():\n                self._status_block.update(msg)\n            case ContentPart():\n                self.append_content(msg)\n            case ToolCall():\n                self.append_tool_call(msg)\n            case ToolCallPart():\n                self.append_tool_call_part(msg)\n            case ToolResult():\n                self.append_tool_result(msg)\n            case ApprovalResponse():\n                # we don't need to handle this because the request is resolved on UI\n                pass\n            case SubagentEvent():\n                self.handle_subagent_event(msg)\n            case ApprovalRequest():\n                self.request_approval(msg)\n            case ToolCallRequest():\n                logger.warning(\"Unexpected ToolCallRequest in shell UI: {msg}\", msg=msg)\n\n    def dispatch_keyboard_event(self, event: KeyEvent) -> None:\n        # handle ESC key to cancel the run\n        if event == KeyEvent.ESCAPE and self._cancel_event is not None:\n            self._cancel_event.set()\n            return\n\n        if not self._current_approval_request_panel:\n            # just ignore any keyboard event when there's no approval request\n            return\n\n        match event:\n            case KeyEvent.UP:\n                self._current_approval_request_panel.move_up()\n                self.refresh_soon()\n            case KeyEvent.DOWN:\n                self._current_approval_request_panel.move_down()\n                self.refresh_soon()\n            case KeyEvent.ENTER:\n                resp = self._current_approval_request_panel.get_selected_response()\n                self._current_approval_request_panel.request.resolve(resp)\n                if resp == \"approve_for_session\":\n                    to_remove_from_queue: list[ApprovalRequest] = []\n                    for request in self._approval_request_queue:\n                        # approve all queued requests with the same action\n                        if request.action == self._current_approval_request_panel.request.action:\n                            request.resolve(\"approve_for_session\")\n                            to_remove_from_queue.append(request)\n                    for request in to_remove_from_queue:\n                        self._approval_request_queue.remove(request)\n                elif resp == \"reject\":\n                    # one rejection should stop the step immediately\n                    while self._approval_request_queue:\n                        self._approval_request_queue.popleft().resolve(\"reject\")\n                    self._reject_all_following = True\n                self.show_next_approval_request()\n            case _:\n                # just ignore any other keyboard event\n                return\n\n    def cleanup(self, is_interrupt: bool) -> None:\n        \"\"\"Cleanup the live view on step end or interruption.\"\"\"\n        self.flush_content()\n\n        for block in self._tool_call_blocks.values():\n            if not block.finished:\n                # this should not happen, but just in case\n                block.finish(\n                    ToolError(message=\"\", brief=\"Interrupted\")\n                    if is_interrupt\n                    else ToolOk(output=\"\")\n                )\n        self._last_tool_call_block = None\n        self.flush_finished_tool_calls()\n\n        while self._approval_request_queue:\n            # should not happen, but just in case\n            self._approval_request_queue.popleft().resolve(\"reject\")\n        self._current_approval_request_panel = None\n        self._reject_all_following = False\n\n    def flush_content(self) -> None:\n        \"\"\"Flush the current content block.\"\"\"\n        if self._current_content_block is not None:\n            console.print(self._current_content_block.compose_final())\n            self._current_content_block = None\n            self.refresh_soon()\n\n    def flush_finished_tool_calls(self) -> None:\n        \"\"\"Flush all leading finished tool call blocks.\"\"\"\n        tool_call_ids = list(self._tool_call_blocks.keys())\n        for tool_call_id in tool_call_ids:\n            block = self._tool_call_blocks[tool_call_id]\n            if not block.finished:\n                break\n\n            self._tool_call_blocks.pop(tool_call_id)\n            console.print(block.compose())\n            if self._last_tool_call_block == block:\n                self._last_tool_call_block = None\n            self.refresh_soon()\n\n    def append_content(self, part: ContentPart) -> None:\n        match part:\n            case ThinkPart(think=text) | TextPart(text=text):\n                if not text:\n                    return\n                is_think = isinstance(part, ThinkPart)\n                if self._current_content_block is None:\n                    self._current_content_block = _ContentBlock(is_think)\n                    self.refresh_soon()\n                elif self._current_content_block.is_think != is_think:\n                    self.flush_content()\n                    self._current_content_block = _ContentBlock(is_think)\n                    self.refresh_soon()\n                self._current_content_block.append(text)\n            case _:\n                # TODO: support more content part types\n                pass\n\n    def append_tool_call(self, tool_call: ToolCall) -> None:\n        self.flush_content()\n        self._tool_call_blocks[tool_call.id] = _ToolCallBlock(tool_call)\n        self._last_tool_call_block = self._tool_call_blocks[tool_call.id]\n        self.refresh_soon()\n\n    def append_tool_call_part(self, part: ToolCallPart) -> None:\n        if not part.arguments_part:\n            return\n        if self._last_tool_call_block is None:\n            return\n        self._last_tool_call_block.append_args_part(part.arguments_part)\n        self.refresh_soon()\n\n    def append_tool_result(self, result: ToolResult) -> None:\n        if block := self._tool_call_blocks.get(result.tool_call_id):\n            block.finish(result.return_value)\n            self.flush_finished_tool_calls()\n            self.refresh_soon()\n\n    def request_approval(self, request: ApprovalRequest) -> None:\n        # If we're rejecting all following requests, reject immediately\n        if self._reject_all_following:\n            request.resolve(\"reject\")\n            return\n\n        self._approval_request_queue.append(request)\n\n        if self._current_approval_request_panel is None:\n            console.bell()\n            self.show_next_approval_request()\n\n    def show_next_approval_request(self) -> None:\n        \"\"\"\n        Show the next approval request from the queue.\n        If there are no pending requests, clear the current approval panel.\n        \"\"\"\n        if not self._approval_request_queue:\n            if self._current_approval_request_panel is not None:\n                self._current_approval_request_panel = None\n                self.refresh_soon()\n            return\n\n        while self._approval_request_queue:\n            request = self._approval_request_queue.popleft()\n            if request.resolved:\n                # skip resolved requests\n                continue\n            self._current_approval_request_panel = _ApprovalRequestPanel(request)\n            self.refresh_soon()\n            break\n\n    def handle_subagent_event(self, event: SubagentEvent) -> None:\n        block = self._tool_call_blocks.get(event.task_tool_call_id)\n        if block is None:\n            return\n\n        match event.event:\n            case ToolCall() as tool_call:\n                block.append_sub_tool_call(tool_call)\n            case ToolCallPart() as tool_call_part:\n                block.append_sub_tool_call_part(tool_call_part)\n            case ToolResult() as tool_result:\n                block.finish_sub_tool_call(tool_result)\n                self.refresh_soon()\n            case _:\n                # ignore other events for now\n                # TODO: may need to handle multi-level nested subagents\n                pass\n","structuredPatch":[{"oldStart":234,"oldLines":19,"newStart":234,"newLines":9,"lines":["                 sub_headline.append(argument, style=sub_arg_style)","                 sub_headline.append(\")\", style=\"grey50\")"," ","-            sub_lines: list[RenderableType] = [sub_headline]","-            if sub_full_url and sub_full_url != argument:","-                sub_url_hint = Text()","-                sub_url_hint.append(\"  ↳ \", style=\"grey50\")","-                sub_url_hint.append(","-                    sub_full_url,","-                    style=Style(color=\"grey50\", link=sub_full_url),","-                )","-                sub_lines.append(sub_url_hint)","-","             lines.append(","                 BulletColumns(","-                    Group(*sub_lines) if len(sub_lines) > 1 else sub_headline,","+                    sub_headline,","                     bullet_style=\"green\" if not sub_result.is_error else \"red\",","                 )","             )"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"c4b66b7a-cc6a-4753-8b3c-c6d72b16368c"}
{"parentUuid":"8a683a30-bf90-4144-8300-fd9f89661944","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","message":{"model":"claude-opus-4-6","id":"msg_0135go5EDf4KnCM49G67Brhy","type":"message","role":"assistant","content":[{"type":"text","text":"Done. Now the truncated URL just carries an invisible OSC 8 link for Ctrl+Click — no extra hint line below."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":426,"cache_read_input_tokens":44071,"cache_creation":{"ephemeral_5m_input_tokens":426,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"type":"assistant","uuid":"4b724623-ca50-4caf-9897-035cb007a0c0","timestamp":"2026-02-25T08:15:31.253Z"}
{"parentUuid":"4b724623-ca50-4caf-9897-035cb007a0c0","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"entire hooks claude-code stop"},"parentToolUseID":"4d1d8b63-7333-40e5-8b88-754ba1ffecca","toolUseID":"4d1d8b63-7333-40e5-8b88-754ba1ffecca","timestamp":"2026-02-25T08:15:31.379Z","uuid":"ee39c0f1-8a9b-4672-a348-304cd0203406"}
{"parentUuid":"ee39c0f1-8a9b-4672-a348-304cd0203406","isSidechain":false,"userType":"external","cwd":"/Users/moonshot/dev/working/kimi/kimi-cli","sessionId":"d2637ab1-8c63-4089-b382-8195dbd85210","version":"2.1.56","gitBranch":"fix/fetchurl-tooltip-platform-key","slug":"piped-crunching-candy","type":"system","subtype":"stop_hook_summary","hookCount":1,"hookInfos":[{"command":"entire hooks claude-code stop","durationMs":1958}],"hookErrors":[],"preventedContinuation":false,"stopReason":"","hasOutput":true,"level":"suggestion","timestamp":"2026-02-25T08:15:33.339Z","uuid":"ac20fd04-31ab-47a5-941d-c8336db2f137","toolUseID":"4d1d8b63-7333-40e5-8b88-754ba1ffecca"}
