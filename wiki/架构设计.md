# Kimi CLI 架构设计文档

## 设计原则

### 1. 模块化设计
- 每个组件职责单一，边界清晰
- 通过接口和协议定义组件间交互
- 支持独立测试和替换

### 2. 异步优先
- 所有 I/O 操作使用异步模式
- 支持并发工具调用
- 非阻塞的用户交互

### 3. 可扩展性
- 工具系统支持插件化
- 代理配置支持继承和组合
- UI 模式可独立实现

### 4. 类型安全
- 全面的类型注解
- 使用 Pydantic 进行数据验证
- 静态类型检查（pyright）

## 核心架构

### 执行流程

```
用户输入
   │
   ▼
CLI 解析参数
   │
   ▼
创建/恢复会话
   │
   ▼
加载配置和代理
   │
   ▼
初始化 KimiSoul
   │
   ▼
启动 UI 模式
   │
   ├─ Shell Mode ──► 交互式循环
   ├─ Print Mode ──► 单次执行
   ├─ ACP Mode ────► 协议服务器
   └─ Wire Mode ───► Wire 服务器
```

### 执行循环（KimiSoul）

```
开始
 │
 ├─► 检查上下文大小
 │   └─► 如果超过阈值，执行压缩
 │
 ├─► 构建消息列表
 │   └─► 包含系统提示词、历史消息、用户输入
 │
 ├─► 调用 LLM
 │   └─► 获取助手回复或工具调用
 │
 ├─► 处理工具调用
 │   ├─► 请求审批（如果需要）
 │   ├─► 执行工具
 │   ├─► 收集结果
 │   └─► 返回结果给 LLM
 │
 ├─► 更新上下文
 │   └─► 保存消息到历史
 │
 └─► 检查终止条件
     ├─► 达到最大步数？
     ├─► 用户中断？
     └─► 助手完成？
```

## 组件详解

### 1. Session（会话管理）

**职责**:
- 管理会话生命周期
- 提供会话标识符
- 管理会话历史文件路径

**设计要点**:
- 会话 ID 基于时间戳和随机数生成
- 每个工作目录可以有多个会话
- 会话历史文件使用 JSONL 格式

**关键方法**:
```python
Session.create(work_dir) -> Session      # 创建新会话
Session.continue_(work_dir) -> Session    # 继续之前的会话
```

### 2. Context（上下文管理）

**职责**:
- 管理对话历史
- 提供消息压缩功能
- 持久化消息到文件

**数据结构**:
- 消息列表：`list[Message]`
- 历史文件：JSONL 格式，每行一个消息

**压缩策略**:
- 保留用户消息和工具结果
- 合并连续的助手消息
- 移除过时的系统消息

**关键方法**:
```python
await context.restore()                    # 从文件恢复
await context.append(message)              # 添加消息
await context.get_messages() -> list[Message]  # 获取消息列表
```

### 3. Agent（代理系统）

**职责**:
- 加载代理配置
- 管理工具集
- 提供系统提示词

**加载流程**:
1. 解析 YAML 配置
2. 处理继承（`extend` 字段）
3. 加载系统提示词模板
4. 解析工具列表
5. 实例化工具类（依赖注入）
6. 加载子代理（如果有）

**依赖注入**:
工具类通过构造函数接收依赖：
- `Approval`: 审批机制
- `Runtime`: 运行时环境
- `Session`: 会话信息
- `Config`: 配置信息
- `DenwaRenji`: 工具通信中心

### 4. Runtime（运行时环境）

**职责**:
- 管理 LLM 实例
- 提供配置访问
- 管理审批机制
- 协调工具通信

**组件**:
- `llm`: LLM 实例（可选）
- `config`: 配置对象
- `session`: 会话对象
- `approval`: 审批机制
- `denwa_renji`: 工具通信中心

### 5. KimiSoul（核心执行引擎）

**职责**:
- 执行代理循环
- 处理工具调用
- 管理上下文压缩
- 错误处理和重试

**执行循环**:
```python
while True:
    # 1. 检查上下文大小，必要时压缩
    if context_size > threshold:
        await compact_context()
    
    # 2. 构建消息列表
    messages = build_messages()
    
    # 3. 调用 LLM
    response = await llm.chat(messages)
    
    # 4. 处理响应
    if response.has_tool_calls():
        results = await handle_tool_calls(response.tool_calls)
        # 继续循环
    else:
        # 完成，退出循环
        break
```

**错误处理**:
- API 连接错误：重试（指数退避）
- API 超时：重试
- 空响应：重试
- 工具错误：记录并继续

### 6. Tool System（工具系统）

**架构**:
```
Toolset
  ├─ Builtin Tools
  │   ├─ Bash
  │   ├─ ReadFile
  │   ├─ WriteFile
  │   └─ ...
  │
  └─ MCP Tools
      └─ (动态加载)
```

**工具接口**:
```python
class Tool(Protocol):
    name: str
    description: str
    params: type[BaseModel]
    
    async def __call__(self, params: Params) -> ToolReturnType:
        ...
```

**工具调用流程**:
1. LLM 生成工具调用请求
2. 查找工具实例
3. 验证参数
4. 请求审批（如果需要）
5. 执行工具
6. 收集结果
7. 返回结果给 LLM

**工具结果格式**:
```python
class ToolResult:
    success: bool
    content: str          # 详细内容
    brief: str | None     # 简短摘要
    error: str | None     # 错误信息（如果失败）
```

### 7. Approval（审批机制）

**职责**:
- 控制工具调用的执行
- 提供用户确认界面
- 支持自动批准模式

**模式**:
- **交互模式**: 需要用户确认
- **YOLO 模式**: 自动批准所有操作
- **Print 模式**: 隐式启用 YOLO

**审批流程**:
```python
if await approval.request(tool_name, action, description):
    # 用户批准，执行工具
    result = await tool.execute(params)
else:
    # 用户拒绝，返回拒绝错误
    return ToolRejectedError()
```

### 8. UI Modes（用户界面）

#### Shell Mode
- **实现**: `prompt-toolkit`
- **特性**: 
  - 交互式命令行界面
  - 命令补全
  - 快捷键支持
  - 模式切换（Shell/Agent）
  - 元命令系统

#### Print Mode
- **实现**: 简单的输入/输出
- **特性**:
  - 非交互式
  - 支持 JSON 输入/输出
  - 自动批准所有操作
  - 适合脚本和自动化

#### ACP Mode
- **实现**: Agent Client Protocol
- **特性**:
  - 标准协议支持
  - 可与编辑器/IDE 集成
  - JSON-RPC 通信

#### Wire Mode
- **实现**: 自定义 Wire 协议
- **特性**:
  - 本地 IPC 通信
  - 基于 stdio
  - 实验性功能

## 数据流

### 消息流

```
用户输入
   │
   ▼
ShellApp / PrintApp / ACPServer
   │
   ▼
KimiSoul.run()
   │
   ├─► Context.append(user_message)
   │
   ├─► Context.get_messages()
   │   └─► 构建消息列表
   │
   ├─► LLM.chat(messages)
   │   └─► 获取助手回复
   │
   ├─► 处理工具调用
   │   ├─► Approval.request()
   │   ├─► Tool.__call__()
   │   └─► Context.append(tool_result)
   │
   └─► Context.append(assistant_message)
```

### 配置流

```
配置文件 (~/.kimi/config.json)
   │
   ▼
load_config()
   │
   ▼
Config 对象
   │
   ├─► Runtime (LLM 配置)
   ├─► Agent (工具配置)
   └─► Tools (服务配置)
```

### 工具调用流

```
LLM 生成工具调用
   │
   ▼
KimiSoul.handle_tool_calls()
   │
   ├─► 查找工具实例
   ├─► 验证参数
   ├─► Approval.request()
   │   └─► 用户确认（如果需要）
   │
   ├─► Tool.__call__(params)
   │   └─► 执行工具逻辑
   │
   └─► 返回结果
       └─► Context.append(tool_result)
```

## 错误处理策略

### 1. LLM API 错误

**重试策略**:
- 连接错误：重试（指数退避）
- 超时错误：重试
- 空响应：重试
- 其他错误：记录并抛出

**实现**:
```python
@retry(
    stop=stop_after_attempt(max_retries),
    wait=wait_exponential_jitter(),
    retry=retry_if_exception_type((
        APIConnectionError,
        APITimeoutError,
        APIEmptyResponseError,
    ))
)
async def call_llm():
    ...
```

### 2. 工具执行错误

**处理策略**:
- 捕获异常
- 记录错误信息
- 返回错误结果给 LLM
- 继续执行循环

### 3. 配置错误

**验证**:
- 使用 Pydantic 验证配置结构
- 检查必需字段
- 验证引用关系（如模型引用提供者）

**错误处理**:
- 抛出 `ConfigError` 异常
- 提供清晰的错误消息
- 建议修复方法

## 性能优化

### 1. 上下文压缩

**触发条件**:
- 上下文大小接近模型限制
- 保留 `RESERVED_TOKENS` 用于新消息

**压缩策略**:
- 保留用户消息
- 保留工具结果
- 合并连续的助手消息
- 移除过时的系统消息

### 2. 异步执行

**并发**:
- 工具调用可以并发执行（如果支持）
- I/O 操作使用异步模式
- 避免阻塞主循环

### 3. 延迟加载

**策略**:
- 工具类延迟实例化
- MCP 工具按需加载
- 配置按需读取

## 扩展点

### 1. 添加新工具

**步骤**:
1. 创建工具类（继承 `CallableTool2`）
2. 定义参数模型（继承 `BaseModel`）
3. 实现 `__call__` 方法
4. 添加到代理配置

### 2. 添加新 UI 模式

**步骤**:
1. 创建 UI 目录和类
2. 实现 `run()` 方法
3. 在 `app.py` 中添加运行方法
4. 在 `cli.py` 中添加 CLI 选项

### 3. 自定义代理

**步骤**:
1. 创建 YAML 配置文件
2. 定义系统提示词
3. 选择工具列表
4. 可选：继承默认代理

### 4. 集成 MCP 工具

**步骤**:
1. 配置 MCP 服务器
2. 使用 `--mcp-config-file` 选项
3. 工具自动加载和注册

## 安全考虑

### 1. 文件系统访问

**限制**:
- 默认限制在工作目录
- 工具可以访问工作目录及其子目录
- 明确警告用户关于文件操作

### 2. Shell 命令执行

**安全措施**:
- 需要用户审批（除非 YOLO 模式）
- 明确显示要执行的命令
- 超时保护（默认 60 秒）

### 3. API 密钥管理

**安全措施**:
- 使用 `SecretStr` 类型
- 不在日志中输出密钥
- 支持环境变量覆盖

### 4. 网络请求

**安全措施**:
- 可配置的端点
- SSL 证书验证
- 超时保护

## 测试策略

### 1. 单元测试

**覆盖范围**:
- 工具功能
- 配置解析
- 消息处理
- 上下文管理

**Mock 策略**:
- LLM 调用使用 mock
- 文件操作使用临时文件
- Shell 命令使用 mock subprocess

### 2. 集成测试

**覆盖范围**:
- 端到端流程
- 工具调用链
- 会话恢复
- UI 模式切换

### 3. AI 测试

**位置**: `tests_ai/`

**用途**:
- 使用 Kimi CLI 自身进行测试
- 验证复杂场景
- 回归测试

## 未来改进方向

### 1. 性能优化
- 更智能的上下文压缩
- 工具调用并发优化
- 缓存机制

### 2. 功能增强
- 更多内置工具
- 更好的错误恢复
- 增强的调试工具

### 3. 用户体验
- 更好的 UI 反馈
- 更丰富的快捷键
- 改进的帮助系统

### 4. 可扩展性
- 插件系统
- 更多 UI 模式
- 更好的 MCP 集成

---

**文档版本**: 1.0  
**最后更新**: 2025-01-XX

